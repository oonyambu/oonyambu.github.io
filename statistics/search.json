[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "R Programing",
    "section": "",
    "text": "What is R? R is a interactive language and environment for statistical computing and graphics.\nIn an oversimplified sense, think of a programmable calculator, now think of R as a advanced programmable calculator. Difference being that you need to know how to “talk” the R-language in order to tell it to do what you want - The “talk” occurs through writing.\nEach language has its own specific syntax. This is simply a set of rules that makes the writer (you) and the reader (computer) make sense of the written sentences. Even in a calculator, you cannot write 3+3+. This will through an error. That is because the statement/sentence is syntactically incorrect.\nWhat is Rstudio?\nRStudio is an integrated development environment (IDE) for R. Think of it as a software application that provides the capability to easily run R. Note that though the original objective for Rstudio was to easily run R, Rstudio has expanded such that we can be able to use it in building various tools. These notes(website) for example was created using Quarto on Rstudio.\nRstudio has 4 panes:\nFor easier access to your code, ensure to write the code in the editor pane.\nIn this course we will learn R and its syntax."
  },
  {
    "objectID": "about.html#math-operators",
    "href": "about.html#math-operators",
    "title": "R Programing",
    "section": "Math Operators",
    "text": "Math Operators\nThese are functions used to do basic math math operations. They are subdivided into two categories:\n\nArithmetic Operators: used to carry out mathematical operations\n\n\n\nOperator\nDescription\n\n\n\n\n+\nAddition\n\n\n–\nSubtraction\n\n\n*\nMultiplication\n\n\n/\nDivision\n\n\n^ or **\nExponent\n\n\n%%\nModulus (Remainder from division)\n\n\n%/%\nInteger Division\n\n\n\n\n5**3\n\n[1] 125\n\n5^3\n\n[1] 125\n\n5%%3\n\n[1] 2\n\n5%/%3\n\n[1] 1\n\n\nOthers include\n\n\n%*% - Matrix multiplication\n%o% - Outer multiplication\n%x% - Kronecker multiplication\n\n\nRelational Operators: Used to compare between two values.\n\n\n\nOperator\nDescription\n\n\n\n\n&lt;\nLess than\n\n\n&gt;\nGreater than\n\n\n&lt;=\nLess than or equal to\n\n\n&gt;=\nGreater than or equal to\n\n\n==\nEqual to\n\n\n!=\nNot equal to\n\n\n\nLogical Operators\n\n\n\nOperator\nDescription\n\n\n\n\n&\nAND\n\n\n|\nOR\n\n\n!\nNOT\n\n\n\n\nAlthough all the functions/operators above are binary, ie work on two inputs eg x + y where x and y are your inputs, others can also accept just one input, hence considered are unary operators. eg -x to negate x and !x to negate the logical value of x\n\n-3\n\n[1] -3\n\n!TRUE\n\n[1] FALSE\n\n\nFor math computation, the order of operations (PEMDAS/BODMAS) is strictly observed."
  },
  {
    "objectID": "about.html#named-math-functions",
    "href": "about.html#named-math-functions",
    "title": "R Programing",
    "section": "Named Math functions",
    "text": "Named Math functions\nBut R is an advanced calculator. How can I compute trigonometric values? The only downside with R is that you need to know the name for the functions you want. Regarding math functions, this is simple as they are stored exactly the same way they are called in math. look at the list of math functions below:\nabs, sign, sqrt, ceiling, floor, trunc, cummax, cummin, cumprod, cumsum, log, log10, log2, log1p, acos, acosh, asin, asinh, atan, atanh, exp, expm1, cos, cosh, cospi, sin, sinh, sinpi, tan, tanh, tanpi, gamma, lgamma, digamma, trigamma\nFrom the list above, it is easy to tell what sqrt function does. ie It is the \\(\\sqrt{~~}\\) function. We can tell what exp, sin, cos, tan are. But what about atan, asin, tanh etc?\nMeaning if you need to compute \\(sin^{-1}(x)\\) you would have to know that the sine inverse function is represented as asin in R whereby the a stands for arc ie arc sine function. In other languages, the same function will have a different name. eg in python we use arcsin instead.\nFrom now on, you are expected to know the function names that you would use before using it. If you are not sure what the function is, you can Google."
  },
  {
    "objectID": "about.html#numericdouble-integer",
    "href": "about.html#numericdouble-integer",
    "title": "R Programing",
    "section": "numeric(Double, Integer)",
    "text": "numeric(Double, Integer)\nDoubles - real numbers\nInteger - Whole numbers. You could append the letter L at the end.\n\ntypeof(5)\n\n[1] \"double\"\n\ntypeof(5L)\n\n[1] \"integer\"\n\n\nInternally stored as double to have more space ie precise representation.\n\n0.1+0.2 == 0.3\n\n[1] FALSE"
  },
  {
    "objectID": "about.html#character",
    "href": "about.html#character",
    "title": "R Programing",
    "section": "Character",
    "text": "Character\nstrings, names\n\ntypeof(\"a\")\n\n[1] \"character\""
  },
  {
    "objectID": "about.html#logical",
    "href": "about.html#logical",
    "title": "R Programing",
    "section": "Logical",
    "text": "Logical\n\ntypeof(TRUE)\n\n[1] \"logical\""
  },
  {
    "objectID": "about.html#complex",
    "href": "about.html#complex",
    "title": "R Programing",
    "section": "Complex",
    "text": "Complex\nMust contain an i at the end for it to be considered as complex.\n\ntypeof(5+1i)\n\n[1] \"complex\"\n\n\nThe other main type is raw"
  },
  {
    "objectID": "about.html#naming-variables",
    "href": "about.html#naming-variables",
    "title": "R Programing",
    "section": "Naming Variables",
    "text": "Naming Variables\nOne usually decides on the name to use for his/her variables. The rules followed in coming up with a variable name are:\n\nIdentifiers can be a combination of letters, digits, period (.) and underscore (_) ONLY.\nIt must start with a letter or a period. If it starts with a period, it cannot be followed by a digit.\nReserved words and Constants in R cannot be used as identifiers.\n\nVariable and function names should be lowercase. Use an underscore (_) to separate words within a name. Generally, variable names should be nouns and function names should be verbs. Strive for names that are concise and meaningful.\n    # Good\n    day_one\n    day_1\n\n    # Bad\n    first_day_of_the_month\n    DayOne\n    dayone\n    djm1"
  },
  {
    "objectID": "about.html#the-assignment-operator",
    "href": "about.html#the-assignment-operator",
    "title": "R Programing",
    "section": "The Assignment Operator",
    "text": "The Assignment Operator\nIn order to make use of the variables, we need to be able to assign values to the variable. This is done by the help of the assignment operator. Often a language will restrict the assignment operator to only one symbol, =. That is not the case with R. In R we have many assignment operators.\n\nThe left assignment operator. &lt;- or =\n\nx &lt;- 3\ny = 2\na &lt;- b &lt;- 4 # assigning 4 to both a and b\nd = e = 5 # assigning 5 to both d and e\n\nThe right assignment operator -&gt;\n\n10 -&gt; x # assigning 10 to x\n\n\nExample of using a variable\n\nx &lt;- 10 # create a variable x with the value 10\nx # implicitly print the value of x. We could also use print(x)\n\n[1] 10\n\nx * 2 # Multiply x by 2 ie 10*2\n\n[1] 20\n\nx &lt;- x + 2 # increment x by 2\nx #x is now 12\n\n[1] 12\n\n\nNote: Refrain from using inbuilt function names as variables. eg c &lt;- 3. c is a function in R and hence should not be used as a variable name.\nNote: There is an assign function which can also be used to assign values to variables. The variable need to be written in literal form ie with quotes\n\nassign(\"var_1\", 3)\nvar_1\n\n[1] 3\n\n\nSo far we have avoided the use of literal strings/characters. But they too can be used in assignment. Although this is a bad practice.\n\n\"var_2\" &lt;- 39 # DO NOT USE THIS THOUGH IT WORKS\nvar_2\n\n[1] 39"
  },
  {
    "objectID": "about.html#reserved-words.",
    "href": "about.html#reserved-words.",
    "title": "R Programing",
    "section": "Reserved Words.",
    "text": "Reserved Words.\nWhile variables names could be anything, there are words reserved in R such that they cannot be changed nor can they be used as variables\n\n\n\n\n\n\n\n\n\n\nif\nelse\nrepeat\nwhile\nfunction\n\n\n\n\nfor\nin\nnext\nbreak\nTRUE\n\n\nFALSE\nNULL\nInf\nNaN\nNA\n\n\nNA_integer_\nNA_real_\nNA_complex_\nNA_character_\n…1, …2\n\n\n\n\nTRUE &lt;- 1\n\nError in TRUE &lt;- 1: invalid (do_set) left-hand side to assignment\n\n\n\nif &lt;- 2\n\nError: &lt;text&gt;:1:4: unexpected assignment\n1: if &lt;-\n       ^"
  },
  {
    "objectID": "about.html#constants",
    "href": "about.html#constants",
    "title": "R Programing",
    "section": "Constants",
    "text": "Constants\nThese are rvalues. They cannot be on the left hand side of the assignment operator. Though common in lower level languages, R does not have much constants in it. Examples include numbers eg 5, literal strings/characters eg ’hello' , complex numbers -a number patched with the letter i eg 5i , 3+9i , integers eg 5L, hexadecimals-numbers preceded by 0X or 0x eg 0xff ,logical values eg TRUE\n\n5\n\n[1] 5\n\n3+9i\n\n[1] 3+9i\n\n0xff \n\n[1] 255\n\nTRUE\n\n[1] TRUE\n\n\nThe value \\(\\pi\\) which is a constant in nature is just a normal variable in R. It can be changed. Hence be careful when dealing with these types of values\n\npi\n\n[1] 3.141593\n\npi &lt;-4\npi # pi changed\n\n[1] 4\n\nrm(pi)#To remove the current stored variable pi and revert back to the original pi\npi\n\n[1] 3.141593\n\n\nNOTE: The variables F and T store the logical values false and true simultaneously. Though logical, they can be changed. Hence refrain from using them, or simply refrain from having variables named as F or T\n\nT\n\n[1] TRUE\n\nT &lt;- FALSE # Change the T\nT # changed T\n\n[1] FALSE\n\nrm(T) #remove the variable T and revert back to the original T\nT\n\n[1] TRUE"
  },
  {
    "objectID": "about1.html",
    "href": "about1.html",
    "title": "About1",
    "section": "",
    "text": "A vector is substantially a list that contains elements of the same kind. There are two types of vectors, Atomic Vectors and Generic Vectors. We will first talk of those that are one dimensional and atomic. By atomic we mean that the elements within the vector cannot by themselves hold other elements. Due to the simplicity structure, we can manipulate all the elements within a vector simultaneously.\n\n\nDifferent functions have been provided in R to be able to create vector. The most common function is the c function which is used for concatenation. Eg To create a vector that contains the elements 1 to 5, we could do the following.\n\nc(1, 2, 3, 4, 5)\n\n[1] 1 2 3 4 5\n\nc(10, 100, 20, -4)\n\n[1]  10 100  20  -4\n\nc(2, 2, 2)\n\n[1] 2 2 2\n\n\nAt times we need to generate a sequence of numbers. The : operator is used for this task.\n\n1:5\n\n[1] 1 2 3 4 5\n\n0.1:5.1\n\n[1] 0.1 1.1 2.1 3.1 4.1 5.1\n\n\nNotice that the sequence has an increment of 1. This is too restrictive. What if we need a sequence with increment of say 2 or even 0.2? We then use the function seq.\n\nseq(10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nseq(1, 10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nseq(1, 2, 0.1)\n\n [1] 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0\n\nseq(1, 2, length.out = 11)\n\n [1] 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0\n\nseq(c(1,4,6,8,-2))\n\n[1] 1 2 3 4 5\n\n\nOther vector functions include rep for repetition and length to determine the length.\nExamples:\n\nrep(2, 4)\n\n[1] 2 2 2 2\n\nrep(c(2,3), 4)\n\n[1] 2 3 2 3 2 3 2 3\n\nrep(c(2,3), each = 4)\n\n[1] 2 2 2 2 3 3 3 3\n\nrep(c(2,3), c(4,4))\n\n[1] 2 2 2 2 3 3 3 3\n\n\nWith vectors, we can easily carry out arithmetic manipulations for each element simultaneously. That is because most of R’s functions are VECTORIZED, meaning that the function will operate on all elements of a vector without needing to loop through and act on each element one at a time. This makes writing code more concise, easy to read, and less error prone.\n\nc(1,2,3) + c(6,7,8)\n\n[1]  7  9 11\n\nlog(c(-4, 10, 6, 8))\n\nWarning in log(c(-4, 10, 6, 8)): NaNs produced\n\n\n[1]      NaN 2.302585 1.791759 2.079442\n\n\nNotice that log(-4) produced NaN while the others gave results. This shows that the computation of rest do not depend on the one with a warning. Also, NaN is a numeric variable that stands for not a number.\n\n\n\nWe can see vector recycling, when we perform some kind of operations like addition, subtraction. . . .etc on two vectors of unequal length. The vector with a small length will be repeated as long as the operation completes on the longer vector. If we perform an addition operation on a vector of equal length the first value of vector1 is added with the first value of vector 2 like that. So, the repetition of small length vector as long as completion of operation on long length vector is known as vector recycling. This is the special property of vectors is available in R language. Let us see the implementation of vector recycling.\n\n# creating vector with\n# 1 to 6 values\nvec1 &lt;- 1:6\n\n# creating vector with 1:2\n# values\nvec2 &lt;- 1:2\n\n# adding vector1 and vector2\nprint(vec1 + vec2)\n\n[1] 2 4 4 6 6 8\n\n\nIn vector recycling, the length of the long length vector should be the multiple of the length of a small length vector. If not we will get a warning that longer object length is not a multiple of shorter object length. Here the longer object length is multiple of the shortest object length. So, we didn’t get a warning message.\n\n# creating vector with 10 to 14 values\nvec1 &lt;- 10:14\n\n# creating vector with 3 to 5 values\nvec2 &lt;- 3:5\n\n# adding vector1 and vector2\nprint(vec1 + vec2)\n\nWarning in vec1 + vec2: longer object length is not a multiple of shorter\nobject length\n\n\n[1] 13 15 17 16 18\n\n\nThe notion of vector recycling is the main idea behind R programming language.\n\n\n\n\nvec1 &lt;- c(-3,-2,-2,-1,-1,1,2,3,3)\nlength(vec1)\nabs(vec1)\nsum(vec1) \nmean(vec1) \nmedian(vec1) \nmin(vec1)\nwhich.min(vec1)\nmax(vec1)\nwhich.max(vec1)\nvar(vec1)\nsd(vec1)\ncov(vec1,vec1)\ncor(vec1, vec1)\ntable(vec1)\nsort(vec1)\nsort(vec1, decreasing = TRUE)\nrank(vec1)\nrank(vec1,ties.method = 'first')\nrank(vec1,ties.method = 'last')\norder(vec1)\nwhich(vec1&gt;=3) # Indices of vector 1 where it is greater than 3\ndiff(vec3)\nunique(vec1)\nduplicated(vec1)\nall(vec1&gt;0)\nany(vec1&gt;0)\nvec2 &lt;- c(5,-2,-1,1,3,-3,7)\nmatch(vec1, vec2) #Position of vec1 in vec2. Why NA?\nmatch(vec1, vec2, 0)\nvec1 %in% vec2\nmatch(vec1, vec2, 0) &gt; 0\nvec2 %in% vec1\nfindInterval(vec2,c(-2,0,2))\n\ninner product, euclidean norm\n\nvec3 &lt;- c(1,3,5)\nvec3%*%vec3\n\n     [,1]\n[1,]   35\n\nsum(vec3^2)\n\n[1] 35\n\nsqrt(sum(vec3^2))\n\n[1] 5.91608\n\nnorm(vec3, '2') #euclidean norm\n\n[1] 5.91608\n\n\n\n\n\nIn computing, an attribute is defined as a piece of information which determines the properties of a field or tag in a database or a string of characters in a display. This is quite a lot of jargon. As for now, understand an attribute to be an extra information contained within an object. This information is not the main information, but rather the object carries it along and it gives more description to the object itself. NB: So far we have not tackled what an object is. In this lesson, take a vector to be the object.\nThe common attribute that a vector can posses is the element names. That is each element in the vector can contain a name. Lets look at the example below.\n\nvec3 &lt;- c(a = 1, b = 3, c = 5)\nvec3\n\na b c \n1 3 5 \n\n\nThe first element of the vector above is named as a while the last element is d. These names are NOT the values of the vector. The vector still has the values 1, 3, 5 and in addition each element is named.\nNotice that we can still do math manipulation on the vector as the values are numeric:\n\nvec3 * 5\n\n a  b  c \n 5 15 25 \n\n\nHow can we access the names? By using the names function:\n\nnames(vec3)\n\n[1] \"a\" \"b\" \"c\"\n\n\nIt is also possible to set the names to a vector that does not contain names:\n\nvec_4 &lt;- c(1, 3, 5)\nnames(vec_4) &lt;- c(\"a\", \"b\", \"c\")\nvec_4\n\na b c \n1 3 5 \n\n\nTo remove the names, we simply set the names to NULL\n\nnames(vec_4) &lt;- NULL\nvec_4\n\n[1] 1 3 5\n\n\nOf course we can add attributes to a vector by using the attr or the attributes functions.\n\npoint &lt;- c(3,4,5)\nattr(point, 'names') &lt;- c('a', 'b', 'c')\npoint\n\na b c \n3 4 5 \n\n\nNotice that R realized the metadata we added and printed the information accordingly.\nSometimes we need to add metadata that is not recognized by R. For example, assume we are calculating the value of a function but at the same time need the gradient score at that particular point. We could save this extra information as an attribute.\n\npoint &lt;- c(3,4,5)\nattr(point, 'gradient') &lt;- 10\npoint\n\n[1] 3 4 5\nattr(,\"gradient\")\n[1] 10\n\n\nMore information on this later.\n\n\n\nThis is the process of extracting components/elements from the vector to obtain a smaller vector. Notice that in R, an atomic object of length 1 is still considered a vector of length 1.\nTo accomplish this, we use the extracting functions. ie [ or [[ or even getElement, together with either the element position or name in case where the elements contain names.\n\n\n\nvec3 &lt;- c(a = 1, b = 3, c = 5, d = NA) # d is a missing value\nvec3[1] #Get the first element\n\na \n1 \n\nvec3['a'] #Get element named a\n\na \n1 \n\nvec3[-2] #remove the second element\n\n a  c  d \n 1  5 NA \n\nvec3[-c(2,4)]\n\na c \n1 5 \n\ngetElement(vec3, 'b')\n\n[1] 3\n\ngetElement(vec3, 2)\n\n[1] 3\n\nvec3[vec3&gt;3]\n\n   c &lt;NA&gt; \n   5   NA \n\nvec3[vec3&lt;=2]\n\n   a &lt;NA&gt; \n   1   NA \n\nvec3[vec3&gt;6]\n\n&lt;NA&gt; \n  NA \n\nvec3[!is.na(vec3)]\n\na b c \n1 3 5 \n\nna.omit(vec3)\n\na b c \n1 3 5 \nattr(,\"na.action\")\nd \n4 \nattr(,\"class\")\n[1] \"omit\"\n\n\nVec3 above contains a missing value represented by NA. Notice that I do not have quotes around NA as it is a special value in R.\nHow would I compute sum of vec3?\n\nsum(vec3)\n\n[1] NA\n\nsum(na.omit(vec3))\n\n[1] 9\n\nsum(vec3, na.rm = TRUE)\n\n[1] 9\n\nmax(vec3, na.rm = TRUE)\n\n[1] 5\n\n\nNote that the getElement function was introduced recently and does not support extracting more than one elements.\nFor vectors, the [[ is used when you desire to drop the attributes. eg Notice the difference between the following two commands\n\nvec3[1]\n\na \n1 \n\nvec3[[1]]\n\n[1] 1\n\n\nor even\n\nvec3[['a']]\n\n[1] 1\n\n\nThe extraction functions can also be used to replace values in a vector\n\nvec3 # Remind ourselves what vec3 is\n\n a  b  c  d \n 1  3  5 NA \n\nvec3[3] &lt;- 10\nvec3['c'] &lt;- 5\n\nWhat happens if you use a position that does not exist?\n\nvec3[-10]\n\n a  b  c  d \n 1  3  5 NA \n\nvec3[0]\n\nnamed numeric(0)\n\n\nReplace many at once\n\nindex &lt;- vec3&gt;1 & !is.na(vec3)\nvec3[index] &lt;- vec3[index] + 10\nvec3\n\n a  b  c  d \n 1 13 15 NA \n\n\n\n\n\n\nSuppose 5 exams were taken by 2 students. The score of the exams are 98,90,70,92,87. Suppose you have a second vector which contains the student who did the exam, ie 1,2,1,1,2 whereby student 1 scored grades 98,70,92 and student 2 scored the grades 90,87. How can we find the mean for each student? what about the sum? sd?max? etc.\nThis is considered as grouping of data. Many functions can be used to manipulate this. The well known one is tapply:\n\nmarks &lt;- c(98,90,70,92,87)\nstudent &lt;- c(1,2,1,1,2)\ntapply(marks, student, mean)\n\n       1        2 \n86.66667 88.50000 \n\ntapply(marks, student, max)\n\n 1  2 \n98 90 \n\n\nSuppose we wanted to replace the values with their average instead of only computing the means?\nOne way we could do that is get the students, match them against their grade means then replace:\n\nmarks &lt;- c(98,90,70,92,87)\nstudent &lt;- c(1,2,1,1,2)\nmeans &lt;- tapply(marks, student, mean)\nmeans[student]\n\n       1        2        1        1        2 \n86.66667 88.50000 86.66667 86.66667 88.50000 \n\n\nAt the same time we could use a function known as ave:\n\nmarks &lt;- c(98,90,70,92,87)\nstudent &lt;- c(1,2,1,1,2)\nave(marks, student)\n\n[1] 86.66667 88.50000 86.66667 86.66667 88.50000\n\n\nWhat about if there was an NA how would you approach that?\n\nmarks &lt;- c(98,90,70,92,87, NA)\nstudent &lt;- c(1,2,1,1,2,2)\ntapply(marks, student, mean, na.rm =TRUE) # The na.rm =TRUE is for the mean and not tapply\n\n       1        2 \n86.66667 88.50000 \n\n\n\n\n\n\nSet Operations: Given that the first vector A contains the values 3,3,4,4,4,10,-2 while the second vector B contains the values 4,3,6,-1 obtain the following in R:\n\na. The unique values of A and of B\nb. The frequency of `A` ie a table showing the number of times each unique element occurs. eg 3 occurs 2 times\nc. Which values in A are in B? What about values in B that are in A?\nd. Obtain the position of the elements in A in the vector B ie the first element in A is in position 2 in B\ne. What is the intersection, union, set difference of the unique values of A and B?\nf. Obtain the position of the duplicated values in A\ng. Find the cumulative sum, product, cumulative minimum and maximum of A\n\n\n\n\nGiven the data 4,7,2,8,1,1,2 compute the standard deviation. \\(sd = \\sqrt{\\frac{1}{n-1}\\sum_{i=1}^n(x_i - \\bar x)^2}\\) where \\(\\bar x = \\frac{1}{n}\\sum_{i=1}^nx_i\\)\nTriangle numbers: Obtain the first 5 triangle numbers.\nFinite Differences and Polynomials: Given the following x and y values, determine the polynomial that generated the values given:\n x    y\n 1    4\n 4  109\n 7  772\n10 2641\n13 6364\nUse the differemHint: Use the diff function. Check here on how to solve\nNB: We will revisit Q3 after looking at loops and conditionals. But you can still solve it."
  },
  {
    "objectID": "about1.html#vector-creation",
    "href": "about1.html#vector-creation",
    "title": "About1",
    "section": "",
    "text": "Different functions have been provided in R to be able to create vector. The most common function is the c function which is used for concatenation. Eg To create a vector that contains the elements 1 to 5, we could do the following.\n\nc(1, 2, 3, 4, 5)\n\n[1] 1 2 3 4 5\n\nc(10, 100, 20, -4)\n\n[1]  10 100  20  -4\n\nc(2, 2, 2)\n\n[1] 2 2 2\n\n\nAt times we need to generate a sequence of numbers. The : operator is used for this task.\n\n1:5\n\n[1] 1 2 3 4 5\n\n0.1:5.1\n\n[1] 0.1 1.1 2.1 3.1 4.1 5.1\n\n\nNotice that the sequence has an increment of 1. This is too restrictive. What if we need a sequence with increment of say 2 or even 0.2? We then use the function seq.\n\nseq(10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nseq(1, 10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nseq(1, 2, 0.1)\n\n [1] 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0\n\nseq(1, 2, length.out = 11)\n\n [1] 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0\n\nseq(c(1,4,6,8,-2))\n\n[1] 1 2 3 4 5\n\n\nOther vector functions include rep for repetition and length to determine the length.\nExamples:\n\nrep(2, 4)\n\n[1] 2 2 2 2\n\nrep(c(2,3), 4)\n\n[1] 2 3 2 3 2 3 2 3\n\nrep(c(2,3), each = 4)\n\n[1] 2 2 2 2 3 3 3 3\n\nrep(c(2,3), c(4,4))\n\n[1] 2 2 2 2 3 3 3 3\n\n\nWith vectors, we can easily carry out arithmetic manipulations for each element simultaneously. That is because most of R’s functions are VECTORIZED, meaning that the function will operate on all elements of a vector without needing to loop through and act on each element one at a time. This makes writing code more concise, easy to read, and less error prone.\n\nc(1,2,3) + c(6,7,8)\n\n[1]  7  9 11\n\nlog(c(-4, 10, 6, 8))\n\nWarning in log(c(-4, 10, 6, 8)): NaNs produced\n\n\n[1]      NaN 2.302585 1.791759 2.079442\n\n\nNotice that log(-4) produced NaN while the others gave results. This shows that the computation of rest do not depend on the one with a warning. Also, NaN is a numeric variable that stands for not a number."
  },
  {
    "objectID": "about1.html#vector-recycling",
    "href": "about1.html#vector-recycling",
    "title": "About1",
    "section": "",
    "text": "We can see vector recycling, when we perform some kind of operations like addition, subtraction. . . .etc on two vectors of unequal length. The vector with a small length will be repeated as long as the operation completes on the longer vector. If we perform an addition operation on a vector of equal length the first value of vector1 is added with the first value of vector 2 like that. So, the repetition of small length vector as long as completion of operation on long length vector is known as vector recycling. This is the special property of vectors is available in R language. Let us see the implementation of vector recycling.\n\n# creating vector with\n# 1 to 6 values\nvec1 &lt;- 1:6\n\n# creating vector with 1:2\n# values\nvec2 &lt;- 1:2\n\n# adding vector1 and vector2\nprint(vec1 + vec2)\n\n[1] 2 4 4 6 6 8\n\n\nIn vector recycling, the length of the long length vector should be the multiple of the length of a small length vector. If not we will get a warning that longer object length is not a multiple of shorter object length. Here the longer object length is multiple of the shortest object length. So, we didn’t get a warning message.\n\n# creating vector with 10 to 14 values\nvec1 &lt;- 10:14\n\n# creating vector with 3 to 5 values\nvec2 &lt;- 3:5\n\n# adding vector1 and vector2\nprint(vec1 + vec2)\n\nWarning in vec1 + vec2: longer object length is not a multiple of shorter\nobject length\n\n\n[1] 13 15 17 16 18\n\n\nThe notion of vector recycling is the main idea behind R programming language."
  },
  {
    "objectID": "about1.html#vector-manipulation",
    "href": "about1.html#vector-manipulation",
    "title": "About1",
    "section": "",
    "text": "vec1 &lt;- c(-3,-2,-2,-1,-1,1,2,3,3)\nlength(vec1)\nabs(vec1)\nsum(vec1) \nmean(vec1) \nmedian(vec1) \nmin(vec1)\nwhich.min(vec1)\nmax(vec1)\nwhich.max(vec1)\nvar(vec1)\nsd(vec1)\ncov(vec1,vec1)\ncor(vec1, vec1)\ntable(vec1)\nsort(vec1)\nsort(vec1, decreasing = TRUE)\nrank(vec1)\nrank(vec1,ties.method = 'first')\nrank(vec1,ties.method = 'last')\norder(vec1)\nwhich(vec1&gt;=3) # Indices of vector 1 where it is greater than 3\ndiff(vec3)\nunique(vec1)\nduplicated(vec1)\nall(vec1&gt;0)\nany(vec1&gt;0)\nvec2 &lt;- c(5,-2,-1,1,3,-3,7)\nmatch(vec1, vec2) #Position of vec1 in vec2. Why NA?\nmatch(vec1, vec2, 0)\nvec1 %in% vec2\nmatch(vec1, vec2, 0) &gt; 0\nvec2 %in% vec1\nfindInterval(vec2,c(-2,0,2))\n\ninner product, euclidean norm\n\nvec3 &lt;- c(1,3,5)\nvec3%*%vec3\n\n     [,1]\n[1,]   35\n\nsum(vec3^2)\n\n[1] 35\n\nsqrt(sum(vec3^2))\n\n[1] 5.91608\n\nnorm(vec3, '2') #euclidean norm\n\n[1] 5.91608"
  },
  {
    "objectID": "about1.html#vector-attributes",
    "href": "about1.html#vector-attributes",
    "title": "About1",
    "section": "",
    "text": "In computing, an attribute is defined as a piece of information which determines the properties of a field or tag in a database or a string of characters in a display. This is quite a lot of jargon. As for now, understand an attribute to be an extra information contained within an object. This information is not the main information, but rather the object carries it along and it gives more description to the object itself. NB: So far we have not tackled what an object is. In this lesson, take a vector to be the object.\nThe common attribute that a vector can posses is the element names. That is each element in the vector can contain a name. Lets look at the example below.\n\nvec3 &lt;- c(a = 1, b = 3, c = 5)\nvec3\n\na b c \n1 3 5 \n\n\nThe first element of the vector above is named as a while the last element is d. These names are NOT the values of the vector. The vector still has the values 1, 3, 5 and in addition each element is named.\nNotice that we can still do math manipulation on the vector as the values are numeric:\n\nvec3 * 5\n\n a  b  c \n 5 15 25 \n\n\nHow can we access the names? By using the names function:\n\nnames(vec3)\n\n[1] \"a\" \"b\" \"c\"\n\n\nIt is also possible to set the names to a vector that does not contain names:\n\nvec_4 &lt;- c(1, 3, 5)\nnames(vec_4) &lt;- c(\"a\", \"b\", \"c\")\nvec_4\n\na b c \n1 3 5 \n\n\nTo remove the names, we simply set the names to NULL\n\nnames(vec_4) &lt;- NULL\nvec_4\n\n[1] 1 3 5\n\n\nOf course we can add attributes to a vector by using the attr or the attributes functions.\n\npoint &lt;- c(3,4,5)\nattr(point, 'names') &lt;- c('a', 'b', 'c')\npoint\n\na b c \n3 4 5 \n\n\nNotice that R realized the metadata we added and printed the information accordingly.\nSometimes we need to add metadata that is not recognized by R. For example, assume we are calculating the value of a function but at the same time need the gradient score at that particular point. We could save this extra information as an attribute.\n\npoint &lt;- c(3,4,5)\nattr(point, 'gradient') &lt;- 10\npoint\n\n[1] 3 4 5\nattr(,\"gradient\")\n[1] 10\n\n\nMore information on this later."
  },
  {
    "objectID": "about1.html#vector-sub-setting",
    "href": "about1.html#vector-sub-setting",
    "title": "About1",
    "section": "",
    "text": "This is the process of extracting components/elements from the vector to obtain a smaller vector. Notice that in R, an atomic object of length 1 is still considered a vector of length 1.\nTo accomplish this, we use the extracting functions. ie [ or [[ or even getElement, together with either the element position or name in case where the elements contain names.\n\n\n\nvec3 &lt;- c(a = 1, b = 3, c = 5, d = NA) # d is a missing value\nvec3[1] #Get the first element\n\na \n1 \n\nvec3['a'] #Get element named a\n\na \n1 \n\nvec3[-2] #remove the second element\n\n a  c  d \n 1  5 NA \n\nvec3[-c(2,4)]\n\na c \n1 5 \n\ngetElement(vec3, 'b')\n\n[1] 3\n\ngetElement(vec3, 2)\n\n[1] 3\n\nvec3[vec3&gt;3]\n\n   c &lt;NA&gt; \n   5   NA \n\nvec3[vec3&lt;=2]\n\n   a &lt;NA&gt; \n   1   NA \n\nvec3[vec3&gt;6]\n\n&lt;NA&gt; \n  NA \n\nvec3[!is.na(vec3)]\n\na b c \n1 3 5 \n\nna.omit(vec3)\n\na b c \n1 3 5 \nattr(,\"na.action\")\nd \n4 \nattr(,\"class\")\n[1] \"omit\"\n\n\nVec3 above contains a missing value represented by NA. Notice that I do not have quotes around NA as it is a special value in R.\nHow would I compute sum of vec3?\n\nsum(vec3)\n\n[1] NA\n\nsum(na.omit(vec3))\n\n[1] 9\n\nsum(vec3, na.rm = TRUE)\n\n[1] 9\n\nmax(vec3, na.rm = TRUE)\n\n[1] 5\n\n\nNote that the getElement function was introduced recently and does not support extracting more than one elements.\nFor vectors, the [[ is used when you desire to drop the attributes. eg Notice the difference between the following two commands\n\nvec3[1]\n\na \n1 \n\nvec3[[1]]\n\n[1] 1\n\n\nor even\n\nvec3[['a']]\n\n[1] 1\n\n\nThe extraction functions can also be used to replace values in a vector\n\nvec3 # Remind ourselves what vec3 is\n\n a  b  c  d \n 1  3  5 NA \n\nvec3[3] &lt;- 10\nvec3['c'] &lt;- 5\n\nWhat happens if you use a position that does not exist?\n\nvec3[-10]\n\n a  b  c  d \n 1  3  5 NA \n\nvec3[0]\n\nnamed numeric(0)\n\n\nReplace many at once\n\nindex &lt;- vec3&gt;1 & !is.na(vec3)\nvec3[index] &lt;- vec3[index] + 10\nvec3\n\n a  b  c  d \n 1 13 15 NA"
  },
  {
    "objectID": "about1.html#advanced-vector-functions",
    "href": "about1.html#advanced-vector-functions",
    "title": "About1",
    "section": "",
    "text": "Suppose 5 exams were taken by 2 students. The score of the exams are 98,90,70,92,87. Suppose you have a second vector which contains the student who did the exam, ie 1,2,1,1,2 whereby student 1 scored grades 98,70,92 and student 2 scored the grades 90,87. How can we find the mean for each student? what about the sum? sd?max? etc.\nThis is considered as grouping of data. Many functions can be used to manipulate this. The well known one is tapply:\n\nmarks &lt;- c(98,90,70,92,87)\nstudent &lt;- c(1,2,1,1,2)\ntapply(marks, student, mean)\n\n       1        2 \n86.66667 88.50000 \n\ntapply(marks, student, max)\n\n 1  2 \n98 90 \n\n\nSuppose we wanted to replace the values with their average instead of only computing the means?\nOne way we could do that is get the students, match them against their grade means then replace:\n\nmarks &lt;- c(98,90,70,92,87)\nstudent &lt;- c(1,2,1,1,2)\nmeans &lt;- tapply(marks, student, mean)\nmeans[student]\n\n       1        2        1        1        2 \n86.66667 88.50000 86.66667 86.66667 88.50000 \n\n\nAt the same time we could use a function known as ave:\n\nmarks &lt;- c(98,90,70,92,87)\nstudent &lt;- c(1,2,1,1,2)\nave(marks, student)\n\n[1] 86.66667 88.50000 86.66667 86.66667 88.50000\n\n\nWhat about if there was an NA how would you approach that?\n\nmarks &lt;- c(98,90,70,92,87, NA)\nstudent &lt;- c(1,2,1,1,2,2)\ntapply(marks, student, mean, na.rm =TRUE) # The na.rm =TRUE is for the mean and not tapply\n\n       1        2 \n86.66667 88.50000"
  },
  {
    "objectID": "about1.html#exercise-3",
    "href": "about1.html#exercise-3",
    "title": "About1",
    "section": "",
    "text": "Set Operations: Given that the first vector A contains the values 3,3,4,4,4,10,-2 while the second vector B contains the values 4,3,6,-1 obtain the following in R:\n\na. The unique values of A and of B\nb. The frequency of `A` ie a table showing the number of times each unique element occurs. eg 3 occurs 2 times\nc. Which values in A are in B? What about values in B that are in A?\nd. Obtain the position of the elements in A in the vector B ie the first element in A is in position 2 in B\ne. What is the intersection, union, set difference of the unique values of A and B?\nf. Obtain the position of the duplicated values in A\ng. Find the cumulative sum, product, cumulative minimum and maximum of A\n\n\n\n\nGiven the data 4,7,2,8,1,1,2 compute the standard deviation. \\(sd = \\sqrt{\\frac{1}{n-1}\\sum_{i=1}^n(x_i - \\bar x)^2}\\) where \\(\\bar x = \\frac{1}{n}\\sum_{i=1}^nx_i\\)\nTriangle numbers: Obtain the first 5 triangle numbers.\nFinite Differences and Polynomials: Given the following x and y values, determine the polynomial that generated the values given:\n x    y\n 1    4\n 4  109\n 7  772\n10 2641\n13 6364\nUse the differemHint: Use the diff function. Check here on how to solve\nNB: We will revisit Q3 after looking at loops and conditionals. But you can still solve it."
  },
  {
    "objectID": "about1.html#matrix-arithmetic",
    "href": "about1.html#matrix-arithmetic",
    "title": "About1",
    "section": "Matrix arithmetic",
    "text": "Matrix arithmetic\n\nA &lt;- matrix(c(1,0,2,3,4,5),nrow = 3, byrow = TRUE)\nB &lt;- matrix(1:6, ncol=3)\n\nThe arithmetic operators work on these matrices the same way they work on a vector. ie element-wise.\n\nA + 1\n\n     [,1] [,2]\n[1,]    2    1\n[2,]    3    4\n[3,]    5    6\n\nA + A\n\n     [,1] [,2]\n[1,]    2    0\n[2,]    4    6\n[3,]    8   10\n\nA^-1\n\n     [,1]      [,2]\n[1,] 1.00       Inf\n[2,] 0.50 0.3333333\n[3,] 0.25 0.2000000\n\n\nWhat if I tried adding A to B above?\n\nB+A\n\nError in B + A: non-conformable arrays\n\n\nWhat about matrix multiplication? Recall that the number of columns for the first matrix need to be equal to the number of Rows in the second matrix otherwise it wont work.\n\nA%*%B\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    8   18   28\n[3,]   14   32   50\n\nB%*%A\n\n     [,1] [,2]\n[1,]   27   34\n[2,]   34   42\n\nA%*%A\n\nError in A %*% A: non-conformable arguments\n\nA%*%t(A) # t is the transpose function\n\n     [,1] [,2] [,3]\n[1,]    1    2    4\n[2,]    2   13   23\n[3,]    4   23   41\n\ncrossprod(A) # t(A) %*% A\n\n     [,1] [,2]\n[1,]   21   26\n[2,]   26   34\n\ntcrossprod(A)\n\n     [,1] [,2] [,3]\n[1,]    1    2    4\n[2,]    2   13   23\n[3,]    4   23   41\n\ncrossprod(A, B)\n\nError in crossprod(A, B): non-conformable arguments\n\n\nYou can find inverse of a square matrix:\n\nD &lt;- B %*% A\nsolve(D)\n\n          [,1]      [,2]\n[1,] -1.909091  1.545455\n[2,]  1.545455 -1.227273\n\nE &lt;- A %*% B\nE\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    8   18   28\n[3,]   14   32   50\n\nG &lt;- crossprod(A)\nsolve(G)\n\n           [,1]       [,2]\n[1,]  0.8947368 -0.6842105\n[2,] -0.6842105  0.5526316"
  },
  {
    "objectID": "about1.html#other-matrix-functions",
    "href": "about1.html#other-matrix-functions",
    "title": "About1",
    "section": "Other matrix functions",
    "text": "Other matrix functions\n\nt(A)\n\n     [,1] [,2] [,3]\n[1,]    1    2    4\n[2,]    0    3    5\n\ndiag(D)\n\n[1] 27 42\n\ndiag(E)\n\n[1]  1 18 50\n\nupper.tri(E)\n\n      [,1]  [,2]  [,3]\n[1,] FALSE  TRUE  TRUE\n[2,] FALSE FALSE  TRUE\n[3,] FALSE FALSE FALSE\n\nlower.tri(E)\n\n      [,1]  [,2]  [,3]\n[1,] FALSE FALSE FALSE\n[2,]  TRUE FALSE FALSE\n[3,]  TRUE  TRUE FALSE\n\ncol(A)\n\n     [,1] [,2]\n[1,]    1    2\n[2,]    1    2\n[3,]    1    2\n\nrow(A)\n\n     [,1] [,2]\n[1,]    1    1\n[2,]    2    2\n[3,]    3    3\n\nncol(A)\n\n[1] 2\n\nnrow(A)\n\n[1] 3\n\ndiag(D) &lt;- 1\ndiag(1:4)\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    0    0    0\n[2,]    0    2    0    0\n[3,]    0    0    3    0\n[4,]    0    0    0    4\n\ncolMeans(A)\n\n[1] 2.333333 2.666667\n\nrowMeans(A)\n\n[1] 0.5 2.5 4.5\n\ncolSums(A)\n\n[1] 7 8\n\nrowSums(A)\n\n[1] 1 5 9\n\nrbind(A, A)\n\n     [,1] [,2]\n[1,]    1    0\n[2,]    2    3\n[3,]    4    5\n[4,]    1    0\n[5,]    2    3\n[6,]    4    5\n\ncbind(A,A,A)\n\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    1    0    1    0    1    0\n[2,]    2    3    2    3    2    3\n[3,]    4    5    4    5    4    5\n\nmax.col(A)\n\n[1] 1 2 2"
  },
  {
    "objectID": "about1.html#matrix-attributes",
    "href": "about1.html#matrix-attributes",
    "title": "About1",
    "section": "Matrix Attributes:",
    "text": "Matrix Attributes:\ncolumn names, row names\n\nMat1 &lt;- matrix(1:4, 2)\nMat1\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\ncolnames(Mat1) &lt;- c(\"column1\", \"column2\") # Set column names\nMat1\n\n     column1 column2\n[1,]       1       3\n[2,]       2       4\n\nrownames(Mat1) &lt;- c(\"row1\", \"row2\")\nMat1\n\n     column1 column2\nrow1       1       3\nrow2       2       4\n\n\n\nmat2 &lt;- matrix(1:4, 2, dimnames = list(c(\"row1\", \"row2\"), c(\"column1\", \"column2\")))\nmat2\n\n     column1 column2\nrow1       1       3\nrow2       2       4\n\ndimnames(mat2)\n\n[[1]]\n[1] \"row1\" \"row2\"\n\n[[2]]\n[1] \"column1\" \"column2\"\n\ndimnames(mat2) &lt;- NULL\ndimnames(mat2) &lt;-  list(c(\"row1\", \"row2\"), c(\"column1\", \"column2\"))\nmat2\n\n     column1 column2\nrow1       1       3\nrow2       2       4\n\ndimnames(mat2) &lt;-  list(rows = c(\"row1\", \"row2\"),columns= c(\"column1\", \"column2\"))\nmat2\n\n      columns\nrows   column1 column2\n  row1       1       3\n  row2       2       4"
  },
  {
    "objectID": "about1.html#matrix-sub-setting",
    "href": "about1.html#matrix-sub-setting",
    "title": "About1",
    "section": "Matrix Sub-setting",
    "text": "Matrix Sub-setting\n\nA[1,1] # row 1, column 1\n\n[1] 1\n\nA[2,] # row 1\n\n[1] 2 3\n\nA[,2] # column 1\n\n[1] 0 3 5\n\nA[,2,drop = FALSE] # maintain the structure of the original object ie matrix/array\n\n     [,1]\n[1,]    0\n[2,]    3\n[3,]    5\n\nA[1,2] &lt;- -3"
  },
  {
    "objectID": "about1.html#exercise",
    "href": "about1.html#exercise",
    "title": "About1",
    "section": "Exercise",
    "text": "Exercise\n\n(Work by hand) Suppose we are interested in solving a problem with the unknowns(parameters) being the values of a symmetric matrix with dimension \\(p \\times p\\) . Since the lower triangle of the matrix is equal to the upper triangle, we only need to solve just the lower triangle and the main diagonal. In that case, if P = 2, we need to solve for 3 parameters. If p = 3 we need to solve for 6 parameters, ie 3 in the main diagonal and 3 in the lower triangle. What is the number of parameters to be solved for, in terms of p?\nParameter Optimization: (Continuation on the above) Given a vector x of length p, where p is the number of parameters, write R code to turn the vector into a symmetric matrix.\nHint:\n\nx &lt;- 1:3 # the given vector\np &lt;- length(x) # The number of parameters\n\n# Should output\nmatrix(c(1,2,2,3), 2) \n\n     [,1] [,2]\n[1,]    1    2\n[2,]    2    3\n\nx &lt;- 1:6 #The given vector\n#Should output\nmatrix(c(1,2,3,2,4,5,3,5,6),3)\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    2    4    5\n[3,]    3    5    6\n\n\nMake use of the functions: t, lower.tri,upper.tri\nGiven the matrix z below, Use R to:\n\nz &lt;- matrix(1:16,4)\nz\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    5    9   13\n[2,]    2    6   10   14\n[3,]    3    7   11   15\n[4,]    4    8   12   16\n\n\n\n\nObtain the diagonal elements of matrix shown below. ie 1,6,11,16\nObtain the anti-diagonal elements of matrix shown below. ie 4,7,10,13\nObtain the elements adjacent to the main diagonal but off by 1. ie 2,7,12,5,10,15\nObtain the elements adjacent to the anti-diagonal but off by 1. ie 3,6,9,8,11,14\n\n\nHint: Use the functions col, row and the relational operator ==\nLinear Regression: For simple prediction purposes, we desire to obtain parameters that would reduce the bias between the actual value and the predicted value. Given the model as \\(\\mathbf{Y = X\\beta +\\epsilon}\\) we desire to have a \\(\\beta\\) such that \\(\\mathbf{Y\\approx X\\beta}\\) . ie the error term tends to 0 often written as \\(\\mathbf{\\mathbb{E}(Y) = X\\beta}\\) . This is often referred to as linear regression.\nThe optimal $\\beta$ that reduced the mean squared errors is computed as\n\\[\n\\hat\\beta = \\mathbf{(X^\\top X)^{-1}X^\\top Y}\n\\]\nGiven the data below, solve for the parameters \\(\\beta =\\begin{bmatrix}\\beta_0\\\\\\beta_1\\end{bmatrix}\\)\n\nx1 &lt;- c(3,6,3,3,5,8,9,10,4)\nY &lt;- 2.3 + 3*x1 + rnorm(x1, 0, 0.001) # ie B= (2.3, 3)\n\nHint: X must contain a column of 1’s\n\\[\n\\begin{aligned}y_i = &\\beta_0 + \\beta_1x_i + \\epsilon_i\\\\ = &\\big[1~~x_i\\big] \\begin{bmatrix}\\beta_0\\\\\\beta_1\\end{bmatrix} +\\epsilon_i\\end{aligned}\n\\]\nOne Hot Encoding: Given a vector that represents a class unto which an object belongs to, write a program that would transform the data vector into dummy matrix.\nExample\n\nmy_vec &lt;- c(2,1,1,2,3,4,3,2) # there are 4 classes.\n\nThen the one hot encoded data will look like:\n     1    2    3    4  Classes\n1    0    1    0    0  The 1st element is in class2\n2    1    0    0    0  The 2nd element is in class1\n3    1    0    0    0  The 3nd element is in class1\n4    0    1    0    0   :\n5    0    0    1    0   :\n6    0    0    0    1\n7    0    0    1    0\n8    0    1    0    0\nHint: use diag\nClassification: Also write a program that would revert back the dummy matrix into the original vector of classes. The matrix is given below\n\nmat1 &lt;- matrix(c(0L, 1L, 1L, 0L, 0L, 0L, 0L, 0L, 1L, 0L, 0L, 1L, 0L, 0L, 0L, \n1L, 0L, 0L, 0L, 0L, 1L, 0L, 1L, 0L, 0L, 0L, 0L, 0L, 0L, 1L, 0L, \n0L), 8)"
  },
  {
    "objectID": "about1.html#conditionals",
    "href": "about1.html#conditionals",
    "title": "About1",
    "section": "Conditionals",
    "text": "Conditionals\nThe basic form of an if statement in R is as follows:\nif (condition) true_action\nif (condition) true_action else false_action\nIf condition is TRUE, true_action is evaluated; if condition is FALSE, the optional false_action is evaluated.\n\na &lt;- -3\nif(a &lt; 0) print('Negative number')\n\n[1] \"Negative number\"\n\n\n\na &lt;- 3\nif(a &lt; 0) print('Negative number')\n\n\na &lt;- 3\nif(a &lt; 0) print('Negative number') else print('positive number')\n\n[1] \"positive number\"\n\n\nNote that you cannot start a new line with the else condition, unless in an enclosed environment, something of which we have not tackled. To be safe, always write else in the same line as if. If you have multiple statements to be evaluated, use curly braces as shown below:\n\nx &lt;- -3\nif(x&lt;0){ # The opening curly bracket must be in the same line as if\n  print('X is negative')\n} else { # The else statement must be immediately after }\n  print('x is positive')\n}\n\n[1] \"X is negative\"\n\n\nDO not do this:\n\nx &lt;- -3\nif(x&lt;0)\n  print('x is negative')\nelse\n  print('x is positive')\n\nError: &lt;text&gt;:4:1: unexpected 'else'\n3:   print('x is negative')\n4: else\n   ^\n\n\nNote that when R parses the statements above, else is taken to be a stand alone and not part of the if statement, hence cannot be parsed.\n\n{\n  x &lt;- -3\nif(x&lt;0)\n  print('x is negative')\nelse\n  print('x is positive')\n}\n\n[1] \"x is negative\"\n\n\nNote that I have enclosed all the work in curly braces, hence they form a scope thus parsed as one entity.\nIn case you have multiple statements you must use { for each part. ie:\n\nx &lt;- -3\nif(x&lt;0){\n  print('x is negative')\n  print('This is what we want')\n} else{\n  print('x is positive')\n  print('This is what we want')\n}\n\n[1] \"x is negative\"\n[1] \"This is what we want\"\n\n\nAnother example:\n\nx &lt;- -3\ny &lt;- if(x &gt; 0) x else 0 # What is the value of y?\ny\n\n[1] 0\n\n\nBecause that was a small statement, we were able to assign all of it to the variable y.\nSometimes you need to evaluate a lot of statements before you find the value of y\n\nx &lt;- -3\nif(x&gt;0){\n  z &lt;- 3\n  y &lt;- z * x\n} else {\n  z &lt;- -0.03\n  p &lt;- z*10\n  y &lt;- x * p\n}\ny\n\n[1] 0.9\n\n\nSometimes we use else if: ie nested\n\nx &lt;- 57\nif(x &lt; 25) \"small\" else if(x&lt;75) \"medium\" else \"large\"\n\n[1] \"medium\"\n\n\nThe above could also be written as:\n\nx &lt;- 100\nif(x &lt; 25) {\n  \"small\"\n} else if(x&lt;75) {\n  \"medium\"\n}else {\n  \"large\"\n}\n\n[1] \"large\"\n\n\n\nx &lt;- 5\nif(x &lt; 75) {\n  if(x &lt; 25)\n  \"small\"\n  else{\n  \"medium\"\n  }\n} else {\n  \"large\"\n}\n\n[1] \"small\"\n\n\nThe above is called a nested if-statement. ie we have an if inside another if.\nSometimes It becomes tedious to write all the if else statements:\n\nx &lt;- \"c\"\nif (x == \"a\") {\n    \"option 1\"\n} else if (x == \"b\") {\n    \"option 2\" \n} else if (x == \"c\") {\n    \"option 3\"\n} else if (x == \"d\") {\n    \"option 4\"\n}else {\n    \"option 5\"\n}\n\n[1] \"option 3\"\n\n\nThis can succinctly be written using the switch function:\n\nx &lt;- \"c\"\nswitch(x,\n    a = \"option 1\",\n    b = \"option 2\",\n    c = \"option 3\",\n    d = \"option 4\",\n    \"option 5\"\n  )\n\n[1] \"option 3\"\n\n\nIf using | conditional statements:\n\nx &lt;- \"cow\"\nif(x == \"cow\" | x == \"horse\" | x == \"dog\") {\n  4\n} else if(x == \"human\" | x == \"bird\") {\n  2\n} else if (x == \"plant\") {\n  0\n} else {\n  \"Unknown input\"\n}\n\n[1] 4\n\n\nFor the switchfunction, if multiple inputs have the same output, you can leave the right hand side of = empty and the input will “fall through” to the next value.\n\nx &lt;- \"cow\"\n switch(x,\n    cow = ,\n    horse = ,\n    dog = 4,\n    human = ,\n    chicken = 2,\n    plant = 0,\n    \"Unknown input\"\n  )\n\n[1] 4\n\n\nNotice what happens when x is a vector:\n\nx &lt;- -3:3\nif(x &gt; 0) x else 0\n\nError in if (x &gt; 0) x else 0: the condition has length &gt; 1\n\n\nThis shows you that if can only work on a single element rather than a vector.\nNote that there is a vectorized function ifelse\nusage: ifelse(condition, true_action, false_action)\n\nx &lt;- -1:3\nifelse(x &gt; 0, x, 0)\n\n[1] 0 0 1 2 3\n\n\n\nifelse(x&lt;0, print('x is Negative'), print('x is positive'))\n\n[1] \"x is Negative\"\n[1] \"x is positive\"\n\n\n[1] \"x is Negative\" \"x is positive\" \"x is positive\" \"x is positive\"\n[5] \"x is positive\"\n\n\nWhat happened? Notice that while if and else statements were control flows, the ifelse is a function which returns a value. It is only advisable to use it where values need to be returned rather than printed.\nIt is also possible to use switch() with a numeric x, but is harder to read, and has undesirable failure modes if x is a not a whole number. I recommend using switch() only with character inputs."
  },
  {
    "objectID": "about1.html#loops",
    "href": "about1.html#loops",
    "title": "About1",
    "section": "Loops",
    "text": "Loops\n\nfor - loop\nThis iterates over items in a vector.\nhey have the following basic form:\nfor (item in vector) perform_action\nFor each item in vector, perform_action is called once; updating the value of item each time.\n\nx &lt;- 1:3\nfor (i in x) {\n  print(i)\n}\n\n[1] 1\n[1] 2\n[1] 3\n\n\nWe can also use indexing. ie\n\nx &lt;- c(10, 20, 30, -10)\n\nfor (i in seq_along(x)) {\n  cat(\"iteration: \", i, \"X = \", x[i], \"\\n\")\n}\n\niteration:  1 X =  10 \niteration:  2 X =  20 \niteration:  3 X =  30 \niteration:  4 X =  -10 \n\n\nNow we can compute the means, sds of the columns of a matrix using for-loop:\n\nA &lt;- matrix(1:24, 4,6)\nA\n\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    1    5    9   13   17   21\n[2,]    2    6   10   14   18   22\n[3,]    3    7   11   15   19   23\n[4,]    4    8   12   16   20   24\n\nn &lt;- ncol(A)\nB &lt;- numeric(n) # We know we have 6 columns, so we will end up with 6 values\nC &lt;- numeric(n)\n\nfor (i in seq_len(n)){\n  B[i] &lt;- mean(A[,i])\n  C[i] &lt;- sd(A[,i])\n}\nD &lt;- cbind(means = B, sds = C)\nD\n\n     means      sds\n[1,]   2.5 1.290994\n[2,]   6.5 1.290994\n[3,]  10.5 1.290994\n[4,]  14.5 1.290994\n[5,]  18.5 1.290994\n[6,]  22.5 1.290994\n\n\nThe apply function you used before is a wrapper of for-loop\n\n\nwhile loop\nUnlike the for-loop, this takes a condition and as long as the condition is satisfied, the iteration is carried out.\nwhile(condition) perform_action\n\nx &lt;- 0\nwhile (x &lt; 5){\n  print(x)\n  x &lt;- x + 1 # increase x by 1\n}\n\n[1] 0\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n\n\nNotice that The increment statement is at the very end. Depending on the nature of the problem, you can change the position of the increment statement and the condition for the loop to terminate.\n\n\nLoop Termination\nThere are two ways to terminate a loop early:\n\nnext exits the current iteration.\nbreak exits the entire for loop.\n\n\nfor (i in seq_len(10)) {\n  if (i &lt; 3) \n    next\n\n  print(i)\n  \n  if (i &gt;= 5)\n    break\n}\n\n[1] 3\n[1] 4\n[1] 5\n\nn &lt;- 0\nwhile(TRUE) {\n  print(n)\n  if(n&gt;=4) break\n  n &lt;- n + 1\n}\n\n[1] 0\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n\n\n\n\nrepeat loop\nAlmost similar to a while loop with the exception that it uses break statement to terminate.\n\nerror &lt;- 0\nrepeat {\n  # do something\n  error &lt;- error + 1\n  if(error &gt; 5) break\n}"
  },
  {
    "objectID": "about1.html#repeat-loop-1",
    "href": "about1.html#repeat-loop-1",
    "title": "About1",
    "section": "repeat loop",
    "text": "repeat loop"
  },
  {
    "objectID": "about1.html#named-functions",
    "href": "about1.html#named-functions",
    "title": "About1",
    "section": "Named functions",
    "text": "Named functions"
  },
  {
    "objectID": "about1.html#anonymous-functions",
    "href": "about1.html#anonymous-functions",
    "title": "About1",
    "section": "Anonymous functions",
    "text": "Anonymous functions"
  },
  {
    "objectID": "about1.html#recursive-functions",
    "href": "about1.html#recursive-functions",
    "title": "About1",
    "section": "Recursive functions",
    "text": "Recursive functions"
  },
  {
    "objectID": "control_flows.html",
    "href": "control_flows.html",
    "title": "Control Flows",
    "section": "",
    "text": "There are two primary tools for control flow: choices and loops. Choices, like if statements and switch() calls, allow you to run different code depending on the input. Loops, like for and while, allow you to repeatedly run code, typically with changing options"
  },
  {
    "objectID": "control_flows.html#conditionals",
    "href": "control_flows.html#conditionals",
    "title": "Control Flows",
    "section": "Conditionals",
    "text": "Conditionals\nThe basic form of an if statement in R is as follows:\nif (condition) true_action\nif (condition) true_action else false_action\nIf condition is TRUE, true_action is evaluated; if condition is FALSE, the optional false_action is evaluated.\n\na &lt;- -3\nif(a &lt; 0) print('Negative number')\n\n[1] \"Negative number\"\n\n\n\na &lt;- 3\nif(a &lt; 0) print('Negative number')\n\n\na &lt;- 3\nif(a &lt; 0) print('Negative number') else print('positive number')\n\n[1] \"positive number\"\n\n\nNote that you cannot start a new line with the else condition, unless in an enclosed environment, something of which we have not tackled. To be safe, always write else in the same line as if. If you have multiple statements to be evaluated, use curly braces as shown below:\n\nx &lt;- -3\nif(x&lt;0){ # The opening curly bracket must be in the same line as if\n  print('X is negative')\n} else { # The else statement must be immediately after }\n  print('x is positive')\n}\n\n[1] \"X is negative\"\n\n\nDO not do this:\n\nx &lt;- -3\nif(x&lt;0)\n  print('x is negative')\nelse\n  print('x is positive')\n\nError: &lt;text&gt;:4:1: unexpected 'else'\n3:   print('x is negative')\n4: else\n   ^\n\n\nNote that when R parses the statements above, else is taken to be a stand alone and not part of the if statement, hence cannot be parsed.\n\n{\n  x &lt;- -3\nif(x&lt;0)\n  print('x is negative')\nelse\n  print('x is positive')\n}\n\n[1] \"x is negative\"\n\n\nNote that I have enclosed all the work in curly braces, hence they form a scope thus parsed as one entity.\nIn case you have multiple statements you must use { for each part. ie:\n\nx &lt;- -3\nif(x&lt;0){\n  print('x is negative')\n  print('This is what we want')\n} else{\n  print('x is positive')\n  print('This is not what we want')\n}\n\n[1] \"x is negative\"\n[1] \"This is what we want\"\n\n\nAnother example:\n\nx &lt;- -3\ny &lt;- if(x &gt; 0) x else 0 # What is the value of y?\ny\n\n[1] 0\n\n\nBecause that was a small statement, we were able to assign all of it to the variable y.\nSometimes you need to evaluate a lot of statements before you find the value of y\n\nx &lt;- -3\nif(x&gt;0){\n  z &lt;- 3\n  y &lt;- z * x\n} else {\n  z &lt;- -0.03\n  p &lt;- z*10\n  y &lt;- x * p\n}\ny\n\n[1] 0.9\n\n\nSometimes we use else if: ie nested\n\nx &lt;- 57\nif(x &lt; 25) \"small\" else if(x&lt;75) \"medium\" else \"large\"\n\n[1] \"medium\"\n\n\nThe above could also be written as:\n\nx &lt;- 100\nif(x &lt; 25) {\n  \"small\"\n} else if(x&lt;75) {\n  \"medium\"\n}else {\n  \"large\"\n}\n\n[1] \"large\"\n\n\n\nx &lt;- 5\nif(x &lt; 75) {\n  if(x &lt; 25)\n  \"small\"\n  else{\n  \"medium\"\n  }\n} else {\n  \"large\"\n}\n\n[1] \"small\"\n\n\nThe above is called a nested if-statement. ie we have an if inside another if.\nSometimes It becomes tedious to write all the if else statements:\n\nx &lt;- \"c\"\nif (x == \"a\") {\n    \"option 1\"\n} else if (x == \"b\") {\n    \"option 2\" \n} else if (x == \"c\") {\n    \"option 3\"\n} else if (x == \"d\") {\n    \"option 4\"\n}else {\n    \"option 5\"\n}\n\n[1] \"option 3\"\n\n\nThis can succinctly be written using the switch function:\n\nx &lt;- \"c\"\nswitch(x,\n    a = \"option 1\",\n    b = \"option 2\",\n    c = \"option 3\",\n    d = \"option 4\",\n    \"option 5\"\n  )\n\n[1] \"option 3\"\n\n\nIf using | conditional statements:\n\nx &lt;- \"cow\"\nif(x == \"cow\" | x == \"horse\" | x == \"dog\") {\n  4\n} else if(x == \"human\" | x == \"bird\") {\n  2\n} else if (x == \"plant\") {\n  0\n} else {\n  \"Unknown input\"\n}\n\n[1] 4\n\n\nFor the switchfunction, if multiple inputs have the same output, you can leave the right hand side of = empty and the input will “fall through” to the next value.\n\nx &lt;- \"cow\"\n switch(x,\n    cow = ,\n    horse = ,\n    dog = 4,\n    human = ,\n    chicken = 2,\n    plant = 0,\n    \"Unknown input\"\n  )\n\n[1] 4\n\n\nNotice what happens when x is a vector:\n\nx &lt;- -3:3\nif(x &gt; 0) x else 0\n\nError in if (x &gt; 0) x else 0: the condition has length &gt; 1\n\n\nThis shows you that if can only work on a single element rather than a vector.\nNote that there is a vectorized function ifelse\nusage: ifelse(condition, true_action, false_action)\n\nx &lt;- -1:3\nifelse(x &gt; 0, x, 0)\n\n[1] 0 0 1 2 3\n\n\n\nifelse(x&lt;0, print('x is Negative'), print('x is positive'))\n\n[1] \"x is Negative\"\n[1] \"x is positive\"\n\n\n[1] \"x is Negative\" \"x is positive\" \"x is positive\" \"x is positive\"\n[5] \"x is positive\"\n\n\nWhat happened? Notice that while if and else statements were control flows, the ifelse is a function which returns a value. It is only advisable to use it where values need to be returned rather than printed.\nIt is also possible to use switch() with a numeric x, but is harder to read, and has undesirable failure modes if x is a not a whole number. I recommend using switch() only with character inputs."
  },
  {
    "objectID": "control_flows.html#loops",
    "href": "control_flows.html#loops",
    "title": "Control Flows",
    "section": "Loops",
    "text": "Loops\n\nfor - loop\nThis iterates over items in a vector.\nhey have the following basic form:\nfor (item in vector) perform_action\nFor each item in vector, perform_action is called once; updating the value of item each time.\n\nx &lt;- 1:3\nfor (i in x) {\n  print(i)\n}\n\n[1] 1\n[1] 2\n[1] 3\n\n\nWe can also use indexing. ie\n\nx &lt;- c(10, 20, 30, -10)\n\nfor (i in seq_along(x)) {\n  cat(\"iteration: \", i, \"X = \", x[i], \"\\n\")\n}\n\niteration:  1 X =  10 \niteration:  2 X =  20 \niteration:  3 X =  30 \niteration:  4 X =  -10 \n\n\nNow we can compute the means, sds of the columns of a matrix using for-loop:\n\nA &lt;- matrix(1:24, 4,6)\nA\n\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    1    5    9   13   17   21\n[2,]    2    6   10   14   18   22\n[3,]    3    7   11   15   19   23\n[4,]    4    8   12   16   20   24\n\nn &lt;- ncol(A)\nB &lt;- numeric(n) # We know we have 6 columns, so we will end up with 6 values\nC &lt;- numeric(n)\n\nfor (i in seq_len(n)){\n  B[i] &lt;- mean(A[,i])\n  C[i] &lt;- sd(A[,i])\n}\nB #The means\n\n[1]  2.5  6.5 10.5 14.5 18.5 22.5\n\nC # The standard deviations\n\n[1] 1.290994 1.290994 1.290994 1.290994 1.290994 1.290994\n\n\n\n\nwhile loop\nUnlike the for-loop, this takes a condition and as long as the condition is satisfied, the iteration is carried out.\nwhile(condition) perform_action\n\nx &lt;- 0\nwhile (x &lt; 5){\n  print(x)\n  x &lt;- x + 1 # increase x by 1\n}\n\n[1] 0\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n\n\nNotice that The increment statement is at the very end. Depending on the nature of the problem, you can change the position of the increment statement and the condition for the loop to terminate.\n\n\nLoop Termination\nThere are two ways to terminate a loop early:\n\nnext exits the current iteration.\nbreak exits the entire for loop.\n\n\nfor (i in seq_len(10)) {\n  if (i &lt; 3) \n    next\n\n  print(i)\n  \n  if (i &gt;= 5)\n    break\n}\n\n[1] 3\n[1] 4\n[1] 5\n\nn &lt;- 0\nwhile(TRUE) {\n  print(n)\n  if(n&gt;=4) break\n  n &lt;- n + 1\n}\n\n[1] 0\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n\n\n\n\nrepeat loop\nAlmost similar to a while loop with the exception that it uses break statement to terminate.\n\nerror &lt;- 0\nrepeat {\n  # do something\n  error &lt;- error + 1\n  if(error &gt; 5) break\n}\n\nExamples:\n\nmy_cumsum &lt;- function(x){\n  result &lt;- rep(0, length(x))\n  result[1] &lt;- x[1]\n  for(i in seq(2,length(x))) result[i] &lt;- result[i-1] + x[i]\n  result\n}\nmy_cumsum(1:10)\n\n [1]  1  3  6 10 15 21 28 36 45 55\n\nmy_sum &lt;- function(x){\n  result &lt;- 0\n  for(i in x) result &lt;- result + i\n  result\n}\nmy_sum(1:10)\n\n[1] 55\n\nmy_sum1 &lt;- function(x){\n  result &lt;- 0\n  for(i in seq_along(x)) result &lt;- result + x[i]\n  result\n}\nmy_sum1(1:10)\n\n[1] 55\n\nmy_max &lt;- function(x){\n  result  &lt;- x[1]\n  for(i in x){\n    if(i&gt;result) result &lt;-i\n  }\n  result\n}\nmy_max(c(3,8,10,2,-1))\n\n[1] 10\n\nrowMax &lt;- function(x){\n  results &lt;- c()\n  for(i in seq(nrow(x))){\n    mid_result &lt;- x[i, 1]\n    for(j in seq(ncol(x))){\n      if(x[i,j]&gt;mid_result) mid_result &lt;- x[i,j]\n    }\n      results[i] &lt;- mid_result\n  }\n  results\n}\nrowMax(matrix(1:24, 4,6)) \n\n[1] 21 22 23 24"
  },
  {
    "objectID": "control_flows.html#quick-lesson-on-control-characters-2for-printing-on-screen.",
    "href": "control_flows.html#quick-lesson-on-control-characters-2for-printing-on-screen.",
    "title": "Control Flows",
    "section": "Quick Lesson on Control Characters [2]for printing on screen.",
    "text": "Quick Lesson on Control Characters [2]for printing on screen.\nThese characters enable one to neatly print elements on the screen.\n\n\\b backspace- Deletes one element to the left- Moves cursor one element to the left\n\ncat(\"This iss\\b good\\n\") # One s has been deleted\n\nThis iss\b good\n\n\n\\n new line/line feed - prints the next text in a new line. Moves cursor to a new line.\n\ncat(\"First line\\nSecond Line\\n\\nThiiird line\")\n\nFirst line\nSecond Line\n\nThiiird line\n\n\n\\r carriage return - Moves cursor to the beggining of the current line\n\ncat(\"This replaced by \\rthat \\n\")\n\nThis replaced by \nthat \n\n\n\\t tab - Moves cursor 4-spaces ahead\n\ncat(\"Hello\\tWorld\\n\")\n\nHello   World\n\n\n\nNote that instead of cat we could use print though print does not easily append strings together as cat.\n\n{\n  cat(\"\\t\\t|----------------------------------------\\n\")\n  cat(\"\\t\\t|A\\t|B\\t|C\\tD\\t|E\\t|\\n\")\n  cat(\"\\t\\t|----------------------------------------\\n\")\n  for(i in seq_len(5)){\n    cat(\"Iteration\", i)\n    for(j in seq_len(5)){\n      cat(\"\\t|\", j, sep='')\n    }\n    cat(\"\\t|\\n\")\n  }\n}\n\n        |----------------------------------------\n        |A  |B  |C  D   |E  |\n        |----------------------------------------\nIteration 1 |1  |2  |3  |4  |5  |\nIteration 2 |1  |2  |3  |4  |5  |\nIteration 3 |1  |2  |3  |4  |5  |\nIteration 4 |1  |2  |3  |4  |5  |\nIteration 5 |1  |2  |3  |4  |5  |\n\n\nOf course we can control the number of digits/ the width of the text to be printed using sprintf function.\nNotice how I used extra curly braces {} to wrap the whole code as one. By removing the outermost braces, the behavior changes. The code needs to be run as a single unit and that’s why we put the extra braces"
  },
  {
    "objectID": "Data Modeling.html",
    "href": "Data Modeling.html",
    "title": "Data Modeling",
    "section": "",
    "text": "This is the idea of fitting a specific model to the data. This model can then be used predict a new observation that was previously in the data. We aim at quantifying the relationship between some variables of interest that are not random and the random variables. A model can be described as either a mathematical formula, or even a generic relation between the variables."
  },
  {
    "objectID": "Data Modeling.html#simple-linear-model-regression",
    "href": "Data Modeling.html#simple-linear-model-regression",
    "title": "Data Modeling",
    "section": "Simple Linear Model /Regression",
    "text": "Simple Linear Model /Regression\nSo far we have done some simple data modelling using linear and quadratic equations. ie in a perfect world, a linear model between one variable \\(x\\) and another \\(y\\) can be described as \\(y= mx + b\\) ie using the equation of a line. Instead of using \\(m\\) and \\(b\\) we will use \\(\\alpha\\) to denote the intercept and \\(\\beta\\) to denote the slope. ie \\(y = \\alpha + \\beta x\\). Once we solve for \\(\\alpha\\) and \\(\\beta\\) we can estimate what the value of \\(y\\) will be that corresponds to any given \\(x\\). All the points will line on this equation. To represent the different data points, we will use the subscript \\(i\\). Thus our equation becomes:\n\\[\ny_i = \\alpha + \\beta x_i\n\\]\nwhere \\((x_i, y_i)\\) represents the \\(i^{th}\\) point. We can therefore have \\((x_1,y_1), x_2,y_2), \\cdots, (x_n,y_n)\\) to represent \\(n\\) data points. example:\n\n\n\n\\(i\\)\n\\(x_i\\)\n\\(y_i = 2x_i + 1\\)\n\\((x_i, y_i)\\)\n\n\n\n\n\\(1\\)\n\\(1.0\\)\n\\(3.0\\)\n\\((1.0, 3.0)\\)\n\n\n\\(2\\)\n\\(1.5\\)\n\\(4.0\\)\n\\((1.5, 4.0)\\)\n\n\n\\(3\\)\n\\(2.0\\)\n\\(5.0\\)\n\\((2.0, 5.0)\\)\n\n\n\\(4\\)\n\\(2.5\\)\n\\(6.0\\)\n\\((2.5, 6.0)\\)\n\n\n\\(5\\)\n\\(3.0\\)\n\\(7.0\\)\n\\((3.0, 7.0)\\)\n\n\n\nIn the case of perfect world, we can use any two points above to find the slope \\(\\beta\\) and the intercept \\(\\alpha\\) and we will obtain the equation \\(y = 2x + 1\\)\nBut we are not in a perfect world. In this world, there are errors involved in the measuring/reading/recording of the \\(x_i\\) and \\(y_i\\) and many other associated errors. Therefore we end up with points that resemble the true values, but are not themselves true. Because of these errors, not all the points will fit on the line. The equation will now be \\(y_i =\\alpha + \\beta x_i + \\epsilon_i\\). We therefore need to find a line which would be described as being closer to the true line. If we use any two points, we will have different results. Thus we need to use all the points rather than any two points. The approximate equation can be obtained by forcing the error terms to be zero or as close as possible to zero. ie the closer the \\(\\epsilon\\) is to 0 the better our equation is.\nHow do we set up the problem? Having the equation \\(y_i = \\alpha + \\beta x_i + \\epsilon_i\\) we can rewrite the equation as \\(\\epsilon_i = y_i - (\\alpha + \\beta x_i)\\) . This becomes a root finding problem. ie we find \\(\\alpha\\) and \\(\\beta\\) such that \\(e_i = 0\\). Previously we noted that a root finding problem can be written as a minimization problem. In this case, we will use squared errors ie\n\\[\nL = \\sum_i\\epsilon_i^2 = \\sum_i (y_i - \\hat y_i)^2 \\quad\\text{where}\\quad \\hat y_i = \\alpha + \\beta x_i\n\\]\nThe objective is to minimize the loss function \\(L\\). The values of \\(\\alpha\\) and \\(\\beta\\) that gives the minimal loss value denote the best linear model.\nAnalytically, we could solve this minimization problem using calculus, ie find the derivative, equate to zero and solve for both \\(\\alpha\\) and \\(\\beta\\) simultaneously:\n\\[\n\\begin{aligned}\n\\frac{\\partial L}{\\partial \\alpha} : &-2\\sum_{i}(y_i - \\alpha - \\beta x_i) = 0\\\\\n\\implies &\\sum_iy_i - \\beta\\sum_ix_i - n\\alpha = 0\n\\implies \\alpha = \\frac{\\sum_iy_i - \\beta\\sum_ix_i}{n}\\\\\n\\therefore\\quad &\\boxed{\\hat \\alpha = \\bar y - \\hat \\beta\\bar x}\\\\\n\\end{aligned}\n\\]\n\\[\n\\begin{aligned}\n\\frac{\\partial L}{\\partial \\beta} : &-2\\sum_{i}(y_i - \\hat y_i)x_i = \\sum_{i}\\Big[y_i -  (\\alpha+\\beta x_i)\\Big]x_i = 0\\\\\n\\implies&\\sum_{i}\\Big[y_i -  (\\bar y - \\beta \\bar x + \\beta x_i)\\Big]x_i = \\sum_{i}\\Big[(y_i - \\bar y)  - \\beta(x_i - \\bar x)\\Big]x_i\\\\\n0&= \\sum_{i}(y_i - \\bar y)x_i  - \\beta\\sum_i(x_i - \\bar x)x_i\\\\\n\\implies &\\boxed{\\hat \\beta = \\frac{\\sum_{i}(y_i - \\bar y)x_i}{\\sum_i(x_i - \\bar x)x_i} = \\frac{\\sum_i(y_i - \\bar y)(x_i - \\bar x)}{\\sum_i(x_i - \\bar x)^2}}\n\\end{aligned}\n\\]\nThese two gives us the closed form solution for a simple linear model.\nExample:\nSuppose we have the following data, find the equation of the line that best describes the data.\n\n\n\n\nx\ny\n\n\n\n\n1\n5.1\n3.5\n\n\n2\n4.9\n3\n\n\n3\n4.7\n3.2\n\n\n4\n4.6\n3.1\n\n\n5\n5\n3.6\n\n\n6\n5.4\n3.9\n\n\n\n\nRPython\n\n\n\nx &lt;- c(5.1, 4.9, 4.7, 4.6, 5, 5.4)\ny &lt;- c(3.5, 3, 3.2, 3.1, 3.6, 3.9)\n\ny_mean &lt;- mean(y)\nx_mean &lt;- mean(x)\n\nb &lt;- sum((y - y_mean)*x) / sum((x - x_mean)*x)\na &lt;- y_mean - b*x_mean\ncat('a =', a, '\\tb =', b)\n\na = -1.685944   b = 1.024096\n\n\n\n\n\nimport numpy as np\n\nx = np.array([5.1, 4.9, 4.7, 4.6, 5, 5.4])\ny = np.array([3.5, 3, 3.2, 3.1, 3.6, 3.9])\n\ny_mean = np.mean(y)\nx_mean = np.mean(x)\n\nb = np.sum((y - y_mean)*x) / np.sum((x - x_mean)*x)\na = y_mean - b*x_mean\nprint('a = ', a, '\\tb = ', b)\n\na =  -1.6859437751003128    b =  1.0240963855421508\n\n\n\n\n\nThe formulation of \\(\\alpha\\) and \\(\\beta\\) is limited to only one predictor variable \\(x\\) What if we had many predictors?"
  },
  {
    "objectID": "data modelling1.html",
    "href": "data modelling1.html",
    "title": "Data Modeling",
    "section": "",
    "text": "This is the idea of fitting a specific model to the data. This model can then be used predict a new observation that was previously in the data. We aim at quantifying the relationship between some variables of interest that are not random and the random variables. A model can be described as either a mathematical formula, or even a generic relation between the variables."
  },
  {
    "objectID": "data modelling1.html#simple-linear-model-regression",
    "href": "data modelling1.html#simple-linear-model-regression",
    "title": "Data Modeling",
    "section": "Simple Linear Model /Regression",
    "text": "Simple Linear Model /Regression\nSo far we have done some simple data modelling using linear and quadratic equations. ie in a perfect world, a linear model between one variable \\(x\\) and another \\(y\\) can be described as \\(y= mx + b\\) ie using the equation of a line. Instead of using \\(m\\) and \\(b\\) we will use \\(\\alpha\\) to denote the intercept and \\(\\beta\\) to denote the slope. ie \\(y = \\alpha + \\beta x\\). Once we solve for \\(\\alpha\\) and \\(\\beta\\) we can estimate what the value of \\(y\\) will be that corresponds to any given \\(x\\). All the points will line on this equation. To represent the different data points, we will use the subscript \\(i\\). Thus our equation becomes:\n\\[ y_i = \\alpha + \\beta x_i \\]\nwhere \\((x_i, y_i)\\) represents the \\(i^{th}\\) point. We can therefore have \\((x_1,y_1), x_2,y_2), \\cdots, (x_n,y_n)\\) to represent \\(n\\) data points. example:\n\n\n\n\\(i\\)\n\\(x_i\\)\n\\(y_i = 2x_i + 1\\)\n\\((x_i, y_i)\\)\n\n\n\n\n\\(1\\)\n\\(1.0\\)\n\\(3.0\\)\n\\((1.0, 3.0)\\)\n\n\n\\(2\\)\n\\(1.5\\)\n\\(4.0\\)\n\\((1.5, 4.0)\\)\n\n\n\\(3\\)\n\\(2.0\\)\n\\(5.0\\)\n\\((2.0, 5.0)\\)\n\n\n\\(4\\)\n\\(2.5\\)\n\\(6.0\\)\n\\((2.5, 6.0)\\)\n\n\n\\(5\\)\n\\(3.0\\)\n\\(7.0\\)\n\\((3.0, 7.0)\\)\n\n\n\nIn the case of perfect world, we can use any two points above to find the slope \\(\\beta\\) and the intercept \\(\\alpha\\) and we will obtain the equation \\(y = 2x + 1\\)\nBut we are not in a perfect world. In this world, there are errors involved in the measuring/reading/recording of the \\(x_i\\) and \\(y_i\\) and many other associated errors. Therefore we end up with points that resemble the true values, but are not themselves true. Because of these errors, not all the points will fit on the line. The equation will now be \\(y_i =\\alpha + \\beta x_i + \\epsilon_i\\). We therefore need to find a line which would be described as being closer to the true line. If we use any two points, we will have different results. Thus we need to use all the points rather than any two points. The approximate equation can be obtained by forcing the error terms to be zero or as close as possible to zero. ie the closer the \\(\\epsilon\\) is to 0 the better our equation is.\nHow do we set up the problem? Having the equation \\(y_i = \\alpha + \\beta x_i + \\epsilon_i\\) we can rewrite the equation as \\(\\epsilon_i = y_i - (\\alpha + \\beta x_i)\\) . This becomes a root finding problem. ie we find \\(\\alpha\\) and \\(\\beta\\) such that \\(e_i = 0\\). Previously we noted that a root finding problem can be written as a minimization problem. In this case, we will use squared errors ie\n\\[ L = \\sum_i\\epsilon_i^2 = \\sum_i (y_i - \\hat y_i)^2 \\quad\\text{where}\\quad \\hat y_i = \\alpha + \\beta x_i \\]\nThe objective is to minimize the loss function \\(L\\). The values of \\(\\alpha\\) and \\(\\beta\\) that gives the minimal loss value denote the best linear model.\nAnalytically, we could solve this minimization problem using calculus, ie find the derivative, equate to zero and solve for both \\(\\alpha\\) and \\(\\beta\\) simultaneously:\n\\[ \\begin{aligned} \\frac{\\partial L}{\\partial \\alpha} : &-2\\sum_{i}(y_i - \\alpha - \\beta x_i) = 0\\\\ \\implies &\\sum_iy_i - \\beta\\sum_ix_i - n\\alpha = 0 \\implies \\alpha = \\frac{\\sum_iy_i - \\beta\\sum_ix_i}{n}\\\\ \\therefore\\quad &\\boxed{\\hat \\alpha = \\bar y - \\hat \\beta\\bar x}\\\\ \\end{aligned} \\]\n\\[ \\begin{aligned} \\frac{\\partial L}{\\partial \\beta} : &-2\\sum_{i}(y_i - \\hat y_i)x_i = \\sum_{i}\\Big[y_i -  (\\alpha+\\beta x_i)\\Big]x_i = 0\\\\ \\implies&\\sum_{i}\\Big[y_i -  (\\bar y - \\beta \\bar x + \\beta x_i)\\Big]x_i = \\sum_{i}\\Big[(y_i - \\bar y)  - \\beta(x_i - \\bar x)\\Big]x_i\\\\ 0&= \\sum_{i}(y_i - \\bar y)x_i  - \\beta\\sum_i(x_i - \\bar x)x_i\\\\ \\implies &\\boxed{\\hat \\beta = \\frac{\\sum_{i}(y_i - \\bar y)x_i}{\\sum_i(x_i - \\bar x)x_i} = \\frac{\\sum_i(y_i - \\bar y)(x_i - \\bar x)}{\\sum_i(x_i - \\bar x)^2}} \\end{aligned} \\]\nThese two gives us the closed form solution for a simple linear model.\nExample:\nSuppose we have the following data, find the equation of the line that best describes the data.\n\n\n\n\nx\ny\n\n\n\n\n1\n5.1\n3.5\n\n\n2\n4.9\n3\n\n\n3\n4.7\n3.2\n\n\n4\n4.6\n3.1\n\n\n5\n5\n3.6\n\n\n6\n5.4\n3.9\n\n\n\n\nRPython\n\n\n\nx &lt;- c(5.1, 4.9, 4.7, 4.6, 5, 5.4) \ny &lt;- c(3.5, 3, 3.2, 3.1, 3.6, 3.9)\ny_mean &lt;- mean(y)\nx_mean &lt;- mean(x) \nb &lt;- sum((y - y_mean)*x) / sum((x - x_mean)*x) \na &lt;- y_mean - b*x_mean\ncat('a =', a, '\\tb =', b)\n\na = -1.685944   b = 1.024096\n\n\n\n\n\nimport numpy as np  \nx = np.array([5.1, 4.9, 4.7, 4.6, 5, 5.4]) \ny = np.array([3.5, 3, 3.2, 3.1, 3.6, 3.9]) \ny_mean = np.mean(y) \nx_mean = np.mean(x) \nb = np.sum((y - y_mean)*x) / np.sum((x - x_mean)*x) \na = y_mean - b*x_mean\nprint('a = ', a, '\\tb = ', b)\n\na =  -1.6859437751003128    b =  1.0240963855421508\n\n\n\n\n\nThe formulation of \\(\\alpha\\) and \\(\\beta\\) is limited to only one predictor variable \\(x\\) What if we had many predictors?"
  },
  {
    "objectID": "example.html",
    "href": "example.html",
    "title": "data generation",
    "section": "",
    "text": "data generation\nmu = list(mu_A = c(2, 3), mu_B = c(0, 0),mu_C = c(2,-2))\nsigma = list(sigma_A = matrix(c(3, 0, 0, 1), 2), sigma_B = matrix(c(1, 0, 0, 1), 2), sigma_C = matrix(c(3, 2.5, 2.5, 3), 2))\nset.seed(150) X = data.frame(do.call(rbind, Map(rmvnorm, 30, mu, sigma)), Var1 = gl(3,30), Var2 = “1”) names(X)[1:2] &lt;- c(“x”, “y”)\nfn &lt;- function(center, sigma, level){ data.frame(ellipse(sigma, centre = center, level = level)) } levels &lt;-c(0.4, 0.6, 0.8, 0.9, 0.95) names(levels) &lt;- levels\n\n\nTRUE MEANS/VAR\nd &lt;- sapply(levels, Map, f = fn, center = mu, sigma=sigma)|&gt; array2DF()|&gt; transform(Var1 = factor(as.integer(factor(Var1))*7))\n#ESTIMATE e &lt;- sapply(levels, Map, f = fn, center = by(X[1:2], X[,3], colMeans), sigma = by(X[1:2], X[,3], cov))\nggplot(X, aes(x, y, col = Var1, fill = Var2)) + geom_point() + stat_ellipse(data = array2DF(e), ) + geom_path(data = d, stat=“ellipse”) + scale_color_manual(values=c(1,4,3,2,1,1,2,2,2))\n\n\n\n\n Back to top"
  },
  {
    "objectID": "functions.html",
    "href": "functions.html",
    "title": "Functions",
    "section": "",
    "text": "A function in R is an object containing multiple interrelated statements that are run together in a predefined order every time the function is called. Functions in R can be built-in or created by the user (user-defined). The main purpose of creating a user-defined function is to optimize our program, avoid the repetition of the same block of code used for a specific task that is frequently performed in a particular project, prevent us from inevitable and hard-to-debug errors related to copy-paste operations, and make the code more readable. A good practice is creating a function whenever we’re supposed to run a certain set of commands more than twice."
  },
  {
    "objectID": "functions.html#function-name",
    "href": "functions.html#function-name",
    "title": "Functions",
    "section": "Function Name",
    "text": "Function Name\nThis is the name of the function object that will be stored in the R environment after the function definition and used for calling that function. It should be concise but clear and meaningful so that the user who reads our code can easily understand what exactly this function does. For example, if we need to create a function for calculating the circumference of a circle with a known radius, we’d better call this function circumference rather than function_1 or circumference_of_a_circle. (Side note: While commonly we use verbs in function names, it’s ok to use just a noun if that noun is very descriptive and unambiguous.)\n\nhello &lt;- function(){\n  cat(\"hello world\\n\")\n}\nhello()\n\nhello world"
  },
  {
    "objectID": "functions.html#function-parameters",
    "href": "functions.html#function-parameters",
    "title": "Functions",
    "section": "Function Parameters",
    "text": "Function Parameters\nSometimes, they are called formal arguments. Function parameters are the variables in the function definition placed inside the parentheses and separated with a comma that will be set to actual values (called arguments) each time we call the function. For example:\n\nhello2 &lt;- function(name){\n  cat(\"hello\", name, \"\\n\")\n}\nhello2(\"Class\")\n\nhello Class \n\n\n\ncircumference &lt;- function(r){\n    cat(2*pi*r, \"\\n\")\n}\ncircumference(2)\n\n12.56637 \n\ncircumference(10)\n\n62.83185 \n\n\nAlso, we can set some parameters with default values, such that if we do not pass in an argument, the default value is used.\n\nhello3 &lt;- function(name = 'World'){\n  cat(\"hello\", name,\"\\n\")\n}\nhello3()\n\nhello World \n\nhello3('Class')\n\nhello Class"
  },
  {
    "objectID": "functions.html#function-body",
    "href": "functions.html#function-body",
    "title": "Functions",
    "section": "Function Body",
    "text": "Function Body\nThe function body is a set of commands inside the curly braces that are run in a predefined order every time we call the function. In other words, in the function body, we place what exactly we need the function to do:\n\nmy_std &lt;- function(x){\n  mu &lt;- mean(x)\n  n &lt;- length(x)\n  variance &lt;- sum((x-mu)^2)/(n-1)\n  return(sqrt(variance))\n}\nmy_std(1:10)\n\n[1] 3.02765\n\n\nSo far I have been using cat in the function above, I did not use cat, I used a different function: return yet still there was a value printed in the screen. Why is that the case? Well cat Only displays the values on the screen. We are not able to access what is displayed, neither can we reuse the displayed message. On the other hand, return gives back a result to the user. That is to say we can store the value into a variable and reuse it."
  },
  {
    "objectID": "functions.html#passing-arguments",
    "href": "functions.html#passing-arguments",
    "title": "Functions",
    "section": "Passing Arguments",
    "text": "Passing Arguments\nWhen we call an R function, we can pass the arguments by position or by name. Passing by position simply means that the argument occupying a specified position will be treated as the parameter that occupied that position during function definition. On the other hand passing by name means the arguments will be matched to their corresponding names\neg\n\nSurface_Area &lt;- function(h, r){\n  2*pi*r*(r+h)\n}\nSurface_Area(10, 7) # position 1:h=10, position 2:r=7\n\n[1] 747.6991\n\nSurface_Area(h=10, r=7)# passing by name\n\n[1] 747.6991\n\nSurface_Area(r=7, h=10)# passing by name\n\n[1] 747.6991\n\n\nNotice that when passing by name, it does not matter the position of the parameters.\n\nSurface_Area(7, h=10)# Since h has been matched, the remaining unnamed parameters are matched by position.\n\n[1] 747.6991\n\n\nAnother interesting Idea to note is that R will always return the last evaluated statement in a scope. ie {}"
  },
  {
    "objectID": "functions.html#return-statement",
    "href": "functions.html#return-statement",
    "title": "Functions",
    "section": "Return Statement:",
    "text": "Return Statement:\nUsed only within the context of a function and thus cannot be used outside of a function. Without any specification, R often returns the last evaluated statement within a scope. ie body of statements enclosed within curly braces. So the last value of the function will be returned regardless as to whether return function was used explicitly or not. Thus in the function above, although we did not explicitly use the function return, the last evaluated statement is 2*pi*r*(r+h).\nThe return function can also be used to short-circuit a function. ie The function will run statements until it meets the return function and everything else afterwards will be ignored. This can be used to quickly solve issues. For example, assume you have a function that only works with positive numbers. If the number is negative, there is no need to continue. Just return NA or any default value.\n\nx_doubled_sqrt &lt;- function(x){\n  if(x&lt;0) return(NA)\n  y &lt;- 2*x\n  sqrt(y)\n}\nx_doubled_sqrt(-3)\n\n[1] NA\n\nx_doubled_sqrt(4.5)\n\n[1] 3\n\n\nNote that I did not have to use else statement. Though the results will be the same, it is easier to see that the function is short-circuited the moment a number less than 0 is encountered. The statements beneath this return statement are not evaluated.\nFun fact: All the logical operators in all languages are short-circuited. eg, we know that TRUE|…. will return TRUE. Since the first part of the logical | operator has been evaluated to TRUE, there is no need to evaluate the second part of the | operator.Similarly we know that FALSE & … will return FALSE, there is also no need to evaluate the second part of the expression. Thus both | and & are short-circuited.\nHere is a fun example of a function that interacts with the user\n\nemployee_details &lt;- function(){\n  cat(\"Good Morning. Welcome to today's game\\n\")\n  name &lt;- readline(\"What is your name? \")\n  count &lt;- 0\n  repeat{\n    age &lt;- readline(\"Enter your date and Month of birth: \")\n    date &lt;- suppressWarnings(lubridate::dmy(paste(age,\"-2023\")))\n    \n\n    if(is.na(date)){\n      count &lt;- count + 1\n       switch(sample(letters[1:4],1),\n         a = cat(\"crap my bad. I couldn't recognize that date\\n\"),\n         b =cat(\"Are you sure your date is correct?\\n\"),\n         c = cat(\"Seems that we are at an impasse. Can't recognize that\\n\"),\n          d = cat(\"Sorry, try again\\n\")\n    )}\n    else break\n    if(count&gt;5){\n      cat(\"Go back to school and learn what a date is!!\\n\")\n      break\n    }\n  }\n  if(count&lt;=5){\n  zodiac &lt;- as.character(DescTools::Zodiac(date))\n  a &lt;- sample(c('You will be successful', \n                'Naah You are a failure',\n                'Let me tell you a secret- your dad isnt even ...',\n                'Congratulations! I envy you.',\n                'You sure you want this?'), 1)\n  \n  cat(\"Your zodiac is: \",zodiac,\".\\n\", a,\"\\n\" , sep='')\n  }\n}\n\nTry playing with the above, providing both correct and incorrect information :\n\nemployee_details()\n\nGood Morning. Welcome to today's game\nWhat is your name? \nEnter your date and Month of birth: \nAre you sure your date is correct?\nEnter your date and Month of birth: \ncrap my bad. I couldn't recognize that date\nEnter your date and Month of birth: \nSeems that we are at an impasse. Can't recognize that\nEnter your date and Month of birth: \nSorry, try again\nEnter your date and Month of birth: \nAre you sure your date is correct?\nEnter your date and Month of birth: \ncrap my bad. I couldn't recognize that date\nGo back to school and learn what a date is!!"
  },
  {
    "objectID": "here/example.knit.html",
    "href": "here/example.knit.html",
    "title": "Example Document",
    "section": "",
    "text": "You can use the tutorial package to convert static code chunks into ‘fiddles’, i.e. editors where people can experiment with your code. If you specify the ex and type properties, tutorial knows what to do:\n\neyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJhIDwtIDJcbmIgPC0gM1xuXG5hICsgYiJ9\n\nYou can also create interactive exercises right inside your R Markdown document. Suppose you want to explain people how variable assignment works in R. Create an exercise with a certain identifier, create_a in this case. Then, in different R code chunks, specify the elements of the exercise by setting the type inside the code chunk options.\n\neyJsYW5ndWFnZSI6InIiLCJwcmVfZXhlcmNpc2VfY29kZSI6ImIgPC0gNSIsInNhbXBsZSI6IiMgQ3JlYXRlIGEgdmFyaWFibGUgYSwgZXF1YWwgdG8gNVxuXG5cbiMgUHJpbnQgb3V0IGEiLCJzb2x1dGlvbiI6IiMgQ3JlYXRlIGEgdmFyaWFibGUgYSwgZXF1YWwgdG8gNVxuYSA8LSA1XG5cbiMgUHJpbnQgb3V0IGFcbmEiLCJzY3QiOiJ0ZXN0X29iamVjdChcImFcIilcbnRlc3Rfb3V0cHV0X2NvbnRhaW5zKFwiYVwiLCBpbmNvcnJlY3RfbXNnID0gXCJNYWtlIHN1cmUgdG8gcHJpbnQgYGFgLlwiKVxuc3VjY2Vzc19tc2coXCJHcmVhdCFcIikifQ==\n\n\neyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6ImEgPSA1XG5iID0gNFxuYSArIGIifQ==\n\n\n\n\n Back to top"
  },
  {
    "objectID": "here/naive_bayes.knit.html",
    "href": "here/naive_bayes.knit.html",
    "title": "Naive Bayes",
    "section": "",
    "text": "Assumes that all features are independent of one another. And each impact the response y differently.\nThe cummulative impact is just a multiplication of each of the individual impacts.\nWe all know the bayes theorem. I will not bore you with the math. Lets look at a simple example:\nConsider a data set with 1500 observations and the following output classes:\nThe Predictor variables are categorical in nature i.e., they store two values, either True or False:\n\\[\n\\begin{array}{|c|c|c|c|c|}\n\\hline \\text { Type } & \\text { Swim } & \\text { Wings } & \\text { Green } & \\text { Sharp teeth } \\\\\n\\hline \\text { Cat } & 450 / 500 & 0 & 0 & 500 / 500 \\\\\n\\hline \\text { Parrot } & 50 / 500 & 500 / 500 & 400 / 500 & 0 \\\\\n\\hline \\text { Turtle } & 500 / 500 & 0 & 100 / 500 & 50 / 500 \\\\\n\\hline\n\\end{array}\n\\]\nFrom the above table, we can summarise that:\nNow, with the available data, let’s classify the following observation into one of the output classes (Cats, Parrot or Turtle) by using the Naive Bayes Classifier. \\[\n\\begin{array}{|c|c|c|c|c|}\n& \\hline\\text { Swim } & \\text { Wings } & \\text { Green } & \\text { Sharp Teeth } \\\\\n\\hline \\text { Observation } & \\text { True } & \\text { False } & \\text { True } & \\text { False }\\\\\\hline\n\\end{array}\n\\]\nThe goal here is to predict whether the animal is a Cat, Parrot or a Turtle based on the defined predictor variables (swim, wings, green, sharp teeth).\nTo solve this, we will use the Naive Bayes approach, Assume we have\n\\[\nP(\\text{variable}_j \\mid X\\in \\text{Class}_k) = P(V_j\\mid k)\\text{ and }P(X\\in \\text{Class}_k) = P(C = k)\n\\]\nWe can compute the probability of belonging to class \\(k\\) given the variables as:\nThen the probability that a new observation \\(X\\) belongs to class \\(k\\) can be computed as:\n\\[\n\\begin{aligned}P(X\\in \\text{Class}_k \\mid \\text{variable}_1\\cdots\\text{ variable}_p )=&\\frac{P(V_1 \\mid C = k)P(V_2\\mid C = k)  \\cdots  P(V_p \\mid C = k)P(C= k)}{P( Multiple Evidences)}\\\\\n\\propto&P(X\\in\\text{Class}_k)\\prod_j^p P(\\text{Variable}_i\\mid X\\in \\text{Class}_k)\n\\end{aligned}\n\\]\nNote that I ignored the denominator as it is a normalizing constant.\nIn the observation, the variables Swim and Green are true and the outcome can be any one of the animals (Cat, Parrot, Turtle). To check if the animal is a cat: \\[\n\\begin{aligned}\nP( Cat \\mid Swim, Green )=&\\frac{P( Swim \\mid Cat ) \\times P (Green \\mid Cat ) \\times P(Cat)}{P( Swim, Green )}\\\\\n=&\\frac{0.9 * 0 * 0.333}{P( Swim, Green)}=0\n\\end{aligned}\n\\]\nTo check if the animal is a Parrot: \\[\n\\begin{aligned}\nP(Parrot| Swim, Green) =& \\frac{P(Swim|Parrot) P(Green|Parrot) P(Parrot)}{P(Swim, Green)}\\\\\n=&\\frac{ 0.1 * 0.80 * 0.333}{P(Swim, Green)}\\\\\n=& \\frac{0.0264}{ P(Swim, Green)}\n\\end{aligned}\n\\]\nTo check if the animal is a Turtle: \\[\n\\begin{aligned}\nP(Turtle| Swim, Green) =&\\frac{ P(Swim|Turtle)  P(Green|Turtle)  P(Turtle)}{ P(Swim, Green)}\\\\\n=&\\frac{ 1 * 0.2 * 0.333}{ P(Swim, Green)}\\\\\n= &\\frac{0.0666}{ P(Swim, Green)}\\\\\n\\end{aligned}\n\\]\nFor all the above calculations the denominator is the same i.e, \\(P(Swim, Green)\\), thus wont impact the solution. The value of P(Turtle| Swim, Green) is greater than P(Parrot| Swim, Green), therefore we can correctly predict the class of the animal as Turtle.\nWhat if the variable is continuous? How do we proceed? We compute the likelihood for being in class \\(k\\)using the normal density and then include the prior. ie:\nTaking\n\\[\n\\begin{array}{}\n\\mathcal{L}(\\text{Variable}_i | X\\in \\text{Class}_k) = \\mathcal{N}(\\nu_i;~\\mu_k, ~\\sigma_k)\n\\end{array}\n\\]\nWe can compute the likelihood of belonging in class \\(k\\) as:\n\\[p(X\\in \\text{Class}_k \\mid \\text{V}_1\\cdots\\text{V}_p )\\propto P(C = k)\\prod_{j=1}^p\\mathcal{N}(\\nu_j ,~\\mu_k, ~\\sigma_k)\\]\nNote that to perform the computation, use the log-likelihood for stability as the likelihood produces numbers which are essentially 0. Then afterwards exponentiate the results before normalizing.\nie\n\\[\n\\ell = \\log P(C=k) + \\sum_{j=1}^p\\log \\mathcal{N}(\\nu_j ,~\\mu_k, ~\\sigma_k)\n\\]\nFor example:\nassume we had the data below\nWe want to predict the class of some new observations below:\nSolution:\nThe implementation above involves numeric variables. Naive Bayes does assume that the continuous variables are independent of one another and are normally distributed. For categorical variables, the implementation is as shown in the first example.\nThere are packages written that do the naive bayes classification."
  },
  {
    "objectID": "here/naive_bayes.knit.html#python-2",
    "href": "here/naive_bayes.knit.html#python-2",
    "title": "Naive Bayes",
    "section": "Python",
    "text": "Python\n\neyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6ImltcG9ydCBwYW5kYXMgYXMgcGRcbmNyYWJzID0gKHBkLnJlYWRfY3N2KFwiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL29vbnlhbWJ1L0VDT040MzAvbWFpbi9ob3JzZXNob2VfY3JhYi5jc3ZcIiwgXG4gICAgICAgIGR0eXBlID0geydjb2xvcic6J2NhdGVnb3J5JywgJ3NwaW5lJzonY2F0ZWdvcnknLCAnd2lkdGgnOidmbG9hdCcsIFxuICAgICAgICAnc2F0ZWxsJzonaW50JywgJ3dlaWdodCc6J2ludCcsICd5JzonY2F0ZWdvcnknfSkpXG5cbnRyYWluID0gY3JhYnMuaGVhZCgxMzApXG50ZXN0ID0gY3JhYnMudGFpbCgtMTMwKSJ9\n\n:::\nYour function should match the following results for the head\n\neyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIyBQcm9iYWJpbGl0aWVzXG5wcmVkaWN0KGUxMDcxOjpuYWl2ZUJheWVzKHl+Lix0cmFpbiksIHRlc3QsIHR5cGUgPSAncmF3Jyl8PmhlYWQoKVxuIyBBY2N1cmFjeVxuTWV0cmljczo6YWNjdXJhY3kodGVzdCR5LCBwcmVkaWN0KGUxMDcxOjpuYWl2ZUJheWVzKHl+Lix0cmFpbiksIHRlc3QpKSJ9\n\n\n\\n\n%s"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to Online Study",
    "section": "",
    "text": "Laptop/Desktop - macOS, windows OS, linux OS eg Ubuntu etc. Preferably Windows OS for now.\nA second Screen - a monitor, TV, another laptop etc\n\n\nIf the second screen is a monitor, it should have a HDMI compatibility. Old ones have VGA input thus you will need to get a HDMI to VGA adapter/converter. If your laptop has USB-C port only then you will need a USB-C to HDMI adapter depending on what your second screen has.\nFor the TV screen, it must be HDMI compatibility. If not, we do not need it.\nIf Laptop, it must satisfy the requirements in 1. above\nHave a HDMI cable to connect to the second screen from your laptop, if the second screen is any of the first 2 above. -Note that casting is prone to lags hence not recommended.\nif using old computers, you do not need the HDMI but rather the VGA is sufficient.\n\n\nA webcam, if not using a laptop with webcam compatibility.\nWiFi.\n\n\n\n\nRegarding software, all programs should be downloaded and installed in a folder in a drive separate from the main drive of the computer. Preferably D/E/G if windows. eg C:\\online_school\\Programs\n\nR & Rstudio: Go to the page RStudio Desktop. Follow the two steps provided on downloading and installing R and Rstudio\nPython: Go to the page Anaconda | Anaconda Distribution and download Anaconda.\nIf windows go to MSYS2 follow the instructions on how to install it.\nThe video below will give a description on how to install to the preferred folder."
  },
  {
    "objectID": "index.html#hardware",
    "href": "index.html#hardware",
    "title": "Welcome to Online Study",
    "section": "",
    "text": "Laptop/Desktop - macOS, windows OS, linux OS eg Ubuntu etc. Preferably Windows OS for now.\nA second Screen - a monitor, TV, another laptop etc\n\n\nIf the second screen is a monitor, it should have a HDMI compatibility. Old ones have VGA input thus you will need to get a HDMI to VGA adapter/converter. If your laptop has USB-C port only then you will need a USB-C to HDMI adapter depending on what your second screen has.\nFor the TV screen, it must be HDMI compatibility. If not, we do not need it.\nIf Laptop, it must satisfy the requirements in 1. above\nHave a HDMI cable to connect to the second screen from your laptop, if the second screen is any of the first 2 above. -Note that casting is prone to lags hence not recommended.\nif using old computers, you do not need the HDMI but rather the VGA is sufficient.\n\n\nA webcam, if not using a laptop with webcam compatibility.\nWiFi."
  },
  {
    "objectID": "index.html#software",
    "href": "index.html#software",
    "title": "Welcome to Online Study",
    "section": "",
    "text": "Regarding software, all programs should be downloaded and installed in a folder in a drive separate from the main drive of the computer. Preferably D/E/G if windows. eg C:\\online_school\\Programs\n\nR & Rstudio: Go to the page RStudio Desktop. Follow the two steps provided on downloading and installing R and Rstudio\nPython: Go to the page Anaconda | Anaconda Distribution and download Anaconda.\nIf windows go to MSYS2 follow the instructions on how to install it.\nThe video below will give a description on how to install to the preferred folder."
  },
  {
    "objectID": "intro_dataModeling.html",
    "href": "intro_dataModeling.html",
    "title": "Introduction",
    "section": "",
    "text": "This is the idea of fitting a specific model to the data. This model can then be used predict a new observation that was previously in the data. We aim at quantifying the relationship between some variables of interest that are not random and the random variables. A model can be described as either a mathematical formula, or even a generic relation between the variables.\n\n\n\n Back to top"
  },
  {
    "objectID": "kmeans.html",
    "href": "kmeans.html",
    "title": "K means Clustering Algorithm",
    "section": "",
    "text": "Clustering is the grouping together of observations that share common features. The distinction between classification and clustering is that with classification, we tend to have the response variable \\(y\\) , that is, we already know the class to which our training data set observations \\(X\\) belong to. We then try to extract information from the features/predictors \\(X\\) to understand as to why the observations are classified as they are in \\(y\\). Then from this “learned” knowledge/model we try to determine what class a new observation \\(X_{new}\\) belongs to, carry out prediction.\nFor clustering, we do not have the response variable \\(y\\). We just have data, which seems to show some grouping structure. We then try to learn some knowledge about the data, in order to be able to group a new observation.\nSuppose we have the data as shown in the image below\n\n\n\n\n\n\n\n\nFrom the image on the left, we can note that there exists some grouping in the data. To our human eye, we can easily tell that there are 2 clusters. Given a new observation, depending how do we determine which cluster to put it in? How can we tell the computer to do the same?\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "linear_models.html",
    "href": "linear_models.html",
    "title": "Data Modeling",
    "section": "",
    "text": "This is the idea of fitting a specific model to the data. This model can then be used predict a new observation that was previously in the data. We aim at quantifying the relationship between some variables of interest that are not random and the random variables. A model can be described as either a mathematical formula, or even a generic relation between the variables."
  },
  {
    "objectID": "linear_models.html#simple-linear-model-regression",
    "href": "linear_models.html#simple-linear-model-regression",
    "title": "Data Modeling",
    "section": "Simple Linear Model /Regression",
    "text": "Simple Linear Model /Regression\nSo far we have done some simple data modelling using linear and quadratic equations. ie in a perfect world, a linear model between one variable \\(x\\) and another \\(y\\) can be described as \\(y= mx + b\\) ie using the equation of a line. Instead of using \\(m\\) and \\(b\\) we will use \\(\\alpha\\) to denote the intercept and \\(\\beta\\) to denote the slope. ie \\(y = \\alpha + \\beta x\\). Once we solve for \\(\\alpha\\) and \\(\\beta\\) we can estimate what the value of \\(y\\) will be that corresponds to any given \\(x\\). All the points will line on this equation. To represent the different data points, we will use the subscript \\(i\\). Thus our equation becomes:\n\\[ y_i = \\alpha + \\beta x_i \\]\nwhere \\((x_i, y_i)\\) represents the \\(i^{th}\\) point. We can therefore have \\((x_1,y_1), x_2,y_2), \\cdots, (x_n,y_n)\\) to represent \\(n\\) data points. example:\n\n\n\n\\(i\\)\n\\(x_i\\)\n\\(y_i = 2x_i + 1\\)\n\\((x_i, y_i)\\)\n\n\n\n\n\\(1\\)\n\\(1.0\\)\n\\(3.0\\)\n\\((1.0, 3.0)\\)\n\n\n\\(2\\)\n\\(1.5\\)\n\\(4.0\\)\n\\((1.5, 4.0)\\)\n\n\n\\(3\\)\n\\(2.0\\)\n\\(5.0\\)\n\\((2.0, 5.0)\\)\n\n\n\\(4\\)\n\\(2.5\\)\n\\(6.0\\)\n\\((2.5, 6.0)\\)\n\n\n\\(5\\)\n\\(3.0\\)\n\\(7.0\\)\n\\((3.0, 7.0)\\)\n\n\n\nIn the case of perfect world, we can use any two points above to find the slope \\(\\beta\\) and the intercept \\(\\alpha\\) and we will obtain the equation \\(y = 2x + 1\\)\nBut we are not in a perfect world. In this world, there are errors involved in the measuring/reading/recording of the \\(x_i\\) and \\(y_i\\) and many other associated errors. Therefore we end up with points that resemble the true values, but are not themselves true. Because of these errors, not all the points will fit on the line. The equation will now be \\(y_i =\\alpha + \\beta x_i + \\epsilon_i\\). We therefore need to find a line which would be described as being closer to the true line. If we use any two points, we will have different results. Thus we need to use all the points rather than any two points. The approximate equation can be obtained by forcing the error terms to be zero or as close as possible to zero. ie the closer the \\(\\epsilon\\) is to 0 the better our equation is.\nHow do we set up the problem? Having the equation \\(y_i = \\alpha + \\beta x_i + \\epsilon_i\\) we can rewrite the equation as \\(\\epsilon_i = y_i - (\\alpha + \\beta x_i)\\) . This becomes a root finding problem. ie we find \\(\\alpha\\) and \\(\\beta\\) such that \\(e_i = 0\\). Previously we noted that a root finding problem can be written as a minimization problem. In this case, we will use squared errors ie\n\\[ L = \\sum_i\\epsilon_i^2 = \\sum_i (y_i - \\hat y_i)^2 \\quad\\text{where}\\quad \\hat y_i = \\alpha + \\beta x_i \\]\nThe objective is to minimize the loss function \\(L\\). The values of \\(\\alpha\\) and \\(\\beta\\) that gives the minimal loss value denote the best linear model.\nAnalytically, we could solve this minimization problem using calculus, ie find the derivative, equate to zero and solve for both \\(\\alpha\\) and \\(\\beta\\) simultaneously:\n\\[ \\begin{aligned} \\frac{\\partial L}{\\partial \\alpha} : &-2\\sum_{i}(y_i - \\alpha - \\beta x_i) = 0\\\\ \\implies &\\sum_iy_i - \\beta\\sum_ix_i - n\\alpha = 0 \\implies \\alpha = \\frac{\\sum_iy_i - \\beta\\sum_ix_i}{n}\\\\ \\therefore\\quad &\\boxed{\\hat \\alpha = \\bar y - \\hat \\beta\\bar x}\\\\ \\end{aligned} \\]\n\\[ \\begin{aligned} \\frac{\\partial L}{\\partial \\beta} : &-2\\sum_{i}(y_i - \\hat y_i)x_i = \\sum_{i}\\Big[y_i -  (\\alpha+\\beta x_i)\\Big]x_i = 0\\\\ \\implies&\\sum_{i}\\Big[y_i -  (\\bar y - \\beta \\bar x + \\beta x_i)\\Big]x_i = \\sum_{i}\\Big[(y_i - \\bar y)  - \\beta(x_i - \\bar x)\\Big]x_i\\\\ 0&= \\sum_{i}(y_i - \\bar y)x_i  - \\beta\\sum_i(x_i - \\bar x)x_i\\\\ \\implies &\\boxed{\\hat \\beta = \\frac{\\sum_{i}(y_i - \\bar y)x_i}{\\sum_i(x_i - \\bar x)x_i} = \\frac{\\sum_i(y_i - \\bar y)(x_i - \\bar x)}{\\sum_i(x_i - \\bar x)^2}} \\end{aligned} \\]\nThese two gives us the closed form solution for a simple linear model.\nExample:\nSuppose we have the following data, find the equation of the line that best describes the data.\n\n\n\n\nx\ny\n\n\n\n\n1\n5.1\n3.5\n\n\n2\n4.9\n3\n\n\n3\n4.7\n3.2\n\n\n4\n4.6\n3.1\n\n\n5\n5\n3.6\n\n\n6\n5.4\n3.9\n\n\n\n\nRPython\n\n\n\nx &lt;- c(5.1, 4.9, 4.7, 4.6, 5, 5.4) \ny &lt;- c(3.5, 3, 3.2, 3.1, 3.6, 3.9)  \ny_mean &lt;- mean(y) \nx_mean &lt;- mean(x) \nb &lt;- sum((y - y_mean)*x) / sum((x - x_mean)*x)\na &lt;- y_mean - b*x_mean \ncat('a =', a, '\\tb =', b)\n\na = -1.685944   b = 1.024096\n\n\n\n\n\nimport numpy as np\nx = np.array([5.1, 4.9, 4.7, 4.6, 5, 5.4]) \ny = np.array([3.5, 3, 3.2, 3.1, 3.6, 3.9]) \ny_mean = np.mean(y)\nx_mean = np.mean(x)\nb = np.sum((y - y_mean)*x) / np.sum((x - x_mean)*x) \na = y_mean - b*x_mean \nprint('a = ', a, '\\tb = ', b)\n\na =  -1.6859437751003128    b =  1.0240963855421508\n\n\n\n\n\nThe formulation of \\(\\alpha\\) and \\(\\beta\\) is limited to only one predictor variable \\(x\\) What if we had many predictors?"
  },
  {
    "objectID": "Lists.html",
    "href": "Lists.html",
    "title": "Lists",
    "section": "",
    "text": "A list is a generic Vector. Think of it as a vector that can hold elements of different types.\nLet me take you back abit, some objects are very small, eg 4 is an object. Thus if we define f &lt;- 4 object f will have only one element in it which is 4. On the other hand some objects are big or can contain very many elements in them eg atomic vectors, (which we will simply refer to as vectors) can contain 10000+ elements. But one thing to note is that all the elements that form this object are of the same class/type. They are all of the same length.\nWhat if I have elemets that are of different classes yet they all should be in one object? How is even that possible?\nIts weekend and you decide to go out shopping, You sit down and make a SHOPPING LIST. This shopping list contain things that are different yet they all form the SHOPPING LIST. so we have an object which is the shopping list which contains various elements of different classes, the prices being numeric, the names of things to buy being characters etc. How can we implement this in a computer?\nThus something called LIST was born. A list is exactly what its name suggests. it can contain many things which are different and of have different lengths. We define a list using the function list().\nmylist &lt;- list(c(1,2,4),\"Target/Wallmart\",c(\"sugar\", \"milk\",\"chocolate\"),c(\"Shirt\",\"pants\"),c(2,4,4,20,30))\nWell if someone was to look at this list he might not understand what is happening. Let me give it names:\nnames(mylist) &lt;- c(\"quantity\", \"store\", \"foodstuff\", \"clothing\",\"prices\")\nmylist\n\n$quantity\n[1] 1 2 4\n\n$store\n[1] \"Target/Wallmart\"\n\n$foodstuff\n[1] \"sugar\"     \"milk\"      \"chocolate\"\n\n$clothing\n[1] \"Shirt\" \"pants\"\n\n$prices\n[1]  2  4  4 20 30"
  },
  {
    "objectID": "Lists.html#element-extraction-from-list",
    "href": "Lists.html#element-extraction-from-list",
    "title": "Lists",
    "section": "Element Extraction from list",
    "text": "Element Extraction from list\nLook at this list again. What do you see? The quantity and price are numeric while foodstuffs and clothing are character. How can we tell? We can extract the elements and check the class. Note that to extract elements, we use [[ operator. If we use [ we are just calling part of the list rather than the elements themselves.\nUsing position to call the first element\n\nmylist[[1]]\n\n[1] 1 2 4\n\n\nUsing names to call the first element\n\nmylist[['quantity']]\n\n[1] 1 2 4\n\n\nCompare the above with:\n\nmylist[1]\n\n$quantity\n[1] 1 2 4\n\n\nThis is just part of the list. Which is a list by itself.\nAnother cool operator that we can use for lists is the $ operator. This can be used to access the elements by name. eg\n\nmylist$quantity\n\n[1] 1 2 4\n\nmylist$foodstuff\n\n[1] \"sugar\"     \"milk\"      \"chocolate\"\n\n\nA list can contain another list:\n\nb &lt;- list(1,2,list(3,4, c(5,6)),7)\nb\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n[[3]]\n[[3]][[1]]\n[1] 3\n\n[[3]][[2]]\n[1] 4\n\n[[3]][[3]]\n[1] 5 6\n\n\n[[4]]\n[1] 7"
  },
  {
    "objectID": "Lists.html#changingreplacing-values",
    "href": "Lists.html#changingreplacing-values",
    "title": "Lists",
    "section": "Changing/replacing values",
    "text": "Changing/replacing values\n\nb[1] &lt;- 5\nb\n\n[[1]]\n[1] 5\n\n[[2]]\n[1] 2\n\n[[3]]\n[[3]][[1]]\n[1] 3\n\n[[3]][[2]]\n[1] 4\n\n[[3]][[3]]\n[1] 5 6\n\n\n[[4]]\n[1] 7\n\nb[1] &lt;- 1:5\n\nWarning in b[1] &lt;- 1:5: number of items to replace is not a multiple of\nreplacement length\n\nb\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n[[3]]\n[[3]][[1]]\n[1] 3\n\n[[3]][[2]]\n[1] 4\n\n[[3]][[3]]\n[1] 5 6\n\n\n[[4]]\n[1] 7\n\nb[[1]] &lt;- 1:5\nb\n\n[[1]]\n[1] 1 2 3 4 5\n\n[[2]]\n[1] 2\n\n[[3]]\n[[3]][[1]]\n[1] 3\n\n[[3]][[2]]\n[1] 4\n\n[[3]][[3]]\n[1] 5 6\n\n\n[[4]]\n[1] 7"
  },
  {
    "objectID": "Lists.html#unlisting-a-list",
    "href": "Lists.html#unlisting-a-list",
    "title": "Lists",
    "section": "Unlisting a list",
    "text": "Unlisting a list\nOnce we have a list, we can unlist it to make it a vector. When unlisting, note that the class hierarchy will be followed. ie, everything will be promoted/coerced to the highest class. ie if we have a character in the list, everything that is not a character will become a character after unlisting.\n\nunlist(b)\n\n [1] 1 2 3 4 5 2 3 4 5 6 7\n\n\nOnce unlisted, it is difficult to revert back to the list we had before. There is a way to do it, by using a special class called relist."
  },
  {
    "objectID": "Lists.html#lapply",
    "href": "Lists.html#lapply",
    "title": "Lists",
    "section": "lapply",
    "text": "lapply\nWhen you want to apply a function to each element of a list in turn and get a list back\n\nlapply(data1, mean)\n\n$Height\n[1] 170.5\n\n$Weight\n[1] 189.75\n\n$Age\n[1] 20.75"
  },
  {
    "objectID": "Lists.html#sapply",
    "href": "Lists.html#sapply",
    "title": "Lists",
    "section": "sapply",
    "text": "sapply\nWhen you want to apply a function to each element of a list in turn, but you want a simplified vector back, rather than a list. Here, R will try to simplify your result into an array. If it cannot, it will return a list back\n\nsapply(data1, mean)\n\nHeight Weight    Age \n170.50 189.75  20.75 \n\n\nNote that in this case, the sapply is just a lapply with the function simplify2array called on the final result of lapply.\nAssume I want to add 10 to each element in the list data1 what can we do?\n\ndata1 + 10\n\nError in data1 + 10: non-numeric argument to binary operator\n\n\nWe would have to traverse the list using any of the learned methods/ or even iterative methods:\n\nlapply(data1, `+`, 10)\n\n$Height\n[1] 183 188 200 151\n\n$Weight\n[1] 214 199 223 163\n\n$Age\n[1] 31 36 28 28\n\n\nWell we could also make use of the anonymous functions:\n\nlapply(data1, function(x)x + 10)\n\n$Height\n[1] 183 188 200 151\n\n$Weight\n[1] 214 199 223 163\n\n$Age\n[1] 31 36 28 28\n\n\n\nlapply(data1, \\(x) x + 10)\n\n$Height\n[1] 183 188 200 151\n\n$Weight\n[1] 214 199 223 163\n\n$Age\n[1] 31 36 28 28"
  },
  {
    "objectID": "Lists.html#map",
    "href": "Lists.html#map",
    "title": "Lists",
    "section": "Map",
    "text": "Map\nThis is a multivariate version of lapply. Think of it as lapply but it traverses more than one vector at a time.\neg Suppose you want to create a sequence from 2:5 then another from 1:4 and another from 10:13. Note that we can divide this problem such that we have two vectors, one containing the start points ie c(2,1,10) and the other the end points c(5, 4, 13) then we can iterate across the two:\n\nstart &lt;- c(2, 1, 10)\nend &lt;- c(5, 4, 13)\nMap(seq, start, end)\n\n[[1]]\n[1] 2 3 4 5\n\n[[2]]\n[1] 1 2 3 4\n\n[[3]]\n[1] 10 11 12 13\n\n\nNote that with Map the first argument is the function, then the lists/vectors we want to iterate over.\nNote that if we were to use a for-loop we could do;\n\nresult &lt;- list()\nfor(i in seq_along(start)){\n  result[[i]] &lt;- seq(start[i], end[i])\n}\nresult\n\n[[1]]\n[1] 2 3 4 5\n\n[[2]]\n[1] 1 2 3 4\n\n[[3]]\n[1] 10 11 12 13"
  },
  {
    "objectID": "Lists.html#mapply",
    "href": "Lists.html#mapply",
    "title": "Lists",
    "section": "mapply",
    "text": "mapply\nThis is the multivariate version of sapply. It will try to simplify the result to array and if it cannot, then leave the result as a list. Note that it is exactly similar to Map with the notion of trying to simplify the results. Actually, Map is defined as mapply(…., SIMPLIFY = FALSE)\nAssume you had the vector c(\"cat\", \"fish\", \"hamster\") and you want to convert it into the following output:\n[[1]]\n[1] \"cat\" \"cat\" \"cat\"\n\n[[2]]\n[1] \"fish\" \"fish\"\n\n[[3]]\n[1] \"hamster\"\nHow would you go about it? Try using for loop. Then using Map. In both cases you will need to use the rep function. Check different solutions"
  },
  {
    "objectID": "Lists.html#exercises",
    "href": "Lists.html#exercises",
    "title": "Lists",
    "section": "Exercises",
    "text": "Exercises\n1 . Try this one out\n\nq2"
  },
  {
    "objectID": "Lists.html#split",
    "href": "Lists.html#split",
    "title": "Lists",
    "section": "split",
    "text": "split\nThis function splits a vector/list into various parts. It takes in the vector/list as the first argument that needs to be split and another vector/list which is the grouping vector. The data in the first argument is then grouped according to the second argument and a list containing the grouped data is returned. Below is an example\nSuppose you have the grades of two students as follows:\n\ngrades &lt;- c(90, 87, 78, 95, 89)\nstudents &lt;- c(1,2,1,1,2)\n\nYou can split the grades to a list whereby the first element is the grades of the first student, the second element is the grades of the second student etc.\n\nsplit(grades, students)\n\n$`1`\n[1] 90 78 95\n\n$`2`\n[1] 87 89\n\n\nWith this, we can be able to easily obtain the mean/max/min/sd etc of each student.\n\nsapply(split(grades, students), mean)\n\n       1        2 \n87.66667 88.00000"
  },
  {
    "objectID": "Lists.html#unsplit",
    "href": "Lists.html#unsplit",
    "title": "Lists",
    "section": "unsplit",
    "text": "unsplit\nThis function reverses what split does. (Rarely used) You can learn more by running help(\"unsplit\")"
  },
  {
    "objectID": "Lists.html#tapply",
    "href": "Lists.html#tapply",
    "title": "Lists",
    "section": "tapply",
    "text": "tapply\nThis the combination of sapply and split. Although not implemented as such, it works the same way as grouping the data and then for each group, perform an action.\n\ntapply(grades, students, mean)\n\n       1        2 \n87.66667 88.00000 \n\n\nSo far we are using simple example to grasp the concept of what the functions are doing."
  },
  {
    "objectID": "Lists.html#filter",
    "href": "Lists.html#filter",
    "title": "Lists",
    "section": "Filter",
    "text": "Filter\nThis is a function used to keep items that satisfy a condition while discarding items that do not satisfy the given condition. The condition need to be in a function format that returns either TRUE or FALSE. This type of function is called a predicate function. usage Filter(predicate, list/vector) Take note of the capitalized F in Filter, as you will meet other functions with similar name.\nSuppose in my data1 above, I need to keep variables with all the values greater than 150\n\ndata1\n\n$Height\n[1] 173 178 190 141\n\n$Weight\n[1] 204 189 213 153\n\n$Age\n[1] 21 26 18 18\n\n\nNote that we only have to keep Weight. We could do:\n\nFilter(\\(x)all(x&gt;150), data1)\n\n$Weight\n[1] 204 189 213 153\n\n\nWhat happened? We have a predicate which is an anonymous function. and used that to filter through our list. Below is the procedure\n\nmy_predicate &lt;- function(x)all(x&gt;150)\nmy_predicate(data1$Height)\n\n[1] FALSE\n\nmy_predicate(data1$Weight)\n\n[1] TRUE\n\nmy_predicate(data1$Age)\n\n[1] FALSE\n\n\nWe see that only Weight did return TRUE. The rest returned FALSE.\nNote that we can also use sapply to filter:\n\ndata1[sapply(data1, my_predicate)]# data1[sapply(data1, \\(z)all(z&gt;100))]\n\n$Weight\n[1] 204 189 213 153\n\n\nQuiz: Why did we use single brackets above instead of double brackets for extraction?"
  },
  {
    "objectID": "Lists.html#reduce",
    "href": "Lists.html#reduce",
    "title": "Lists",
    "section": "Reduce",
    "text": "Reduce\nReduce uses a binary function to successively combine the elements of a given vector and a possibly given initial value. Starting from an initial position, reduce iteratively combines the elements of a vector/list using the given function. eg assume we want to add the first 5 numbers, ie 1 + 2 + 3 + 4 + 5. We can do so by first adding 2 to 1,the adding 3 to the result of 2+1, then adding 4 to the result obtained previusly etc. ie (((1 + 2) + 3) + 4) + 5\nNote that the function/operation MUST be a binary operator/function. ie a function that only takes two elements a,b and returns an aggregated value/container.\n\nvec &lt;- 1:5\nReduce(`+`, vec) \n\n[1] 15\n\nReduce(\\(a, b)a + b, vec)\n\n[1] 15\n\n\nThis is just sum(vec)\nNote that reduce contains other parameters. eg accumulate = TRUE ensures that the result at each stage is returned also.\n\nReduce(`+`, vec, accumulate = TRUE)\n\n[1]  1  3  6 10 15\n\nReduce(function(x,y)x+y, vec, accumulate = TRUE)\n\n[1]  1  3  6 10 15\n\n\nThis is similar to cumsum(1:5)\nWe can also pass in an initial value from where we want the function to start at:\n\nReduce('+', vec, init = 10, accumulate = TRUE)\n\n[1] 10 11 13 16 20 25\n\n\nsimilar to cumsum(c(10, vec))\nWell assume we wanted to compute something like log(exp(acos(cos(0.5))))\nWe could simply do:\n\nlog(exp(acos(sin(cos(0.5)))))\n\n[1] 0.6932138\n\nReduce(\\(x, f)f(x), list(cos,sin, acos, exp, log), init = 0.5)\n\n[1] 0.6932138\n\nReduce(\\(x, f)f(x), list(0.5, cos,sin, acos, exp, log))\n\n[1] 0.6932138\n\n\nSimply? Is anything above simple? Could you explain what happened on the second and third lines?\nWhat if we wanted to have the list with functions listed as they appear? ie log, exp, acos, cos?\n\nReduce(\\(f, x)f(x), list(log, exp, acos, sin, cos, 0.5), right = TRUE)\n\n[1] 0.6932138\n\n\nWell not bad. But what exactly happened? Lets try something else. We know that while some functions are commutative, others are not. For example in division, \\(a/b\\neq b/a\\). If we wanted to do 1/2/3/4\n\n1/2/3/4\n\n[1] 0.04166667\n\n(((1/2)/3)/4)\n\n[1] 0.04166667\n\nReduce(\"/\",1:4)\n\n[1] 0.04166667\n\n\nBut what if we wanted to do 1/(2/(3/4)) ie we first do the rightmost division, then we move to the left? Thats when we pass a logical argument TRUE to the parameter right within the reduce function:\n\n1/(2/(3/4))\n\n[1] 0.375\n\nReduce(`/`, 1:4, right = TRUE)\n\n[1] 0.375\n\n\nWhat were the intermediate values?\n\nReduce(`/`, 1:4, right = TRUE, accumulate = TRUE)\n\n[1] 0.375000 2.666667 0.750000 4.000000\n\n\nThe rightmost value is 4. Then 3/4 = 0.75 then 2/0.75=2.6667. Lastly 1/2.6667 = 0.375\nNote that we are using this simple examples to depict what Reduce does. So far, Reduce is the only function we have seen whereby the result of the current function evaluation depends on the previous results. Thus Reduce is practically an iterative function.\nWith this in mind, we can use Reduce to run a given operation/function n-number of times, where n is the length of the passed in vector/list.\nWe therefore can use it to quickly run some iterations: eg\n\nlog(log(log(log(1e10))))\n\n[1] 0.1337832\n\nReduce(\\(x,y)log(x), 1:4, init = 1e10)\n\n[1] 0.1337832\n\nReduce(\\(x,y)y(x), rep(c(log), 4), init = 1e10)\n\n[1] 0.1337832\n\nReduce(\\(x,y)log(x), rep(1e10, 5))\n\n[1] 0.1337832\n\nReduce(\\(x,y)log(x), c(1e10, 1:4))\n\n[1] 0.1337832\n\nReduce(\\(x,y)log(y), 1:4, init = 1e10, right = TRUE)\n\n[1] 0.1337832\n\nReduce(\\(x, y)x(y), c(rep(list(log), 4), 1e10), right = TRUE)\n\n[1] 0.1337832\n\n\nExplain how the above give similar results.\nAlthough Reduce has the forward and backward directions ie forward is right = FALSE and backward is right = TRUE, we will mostly stick to forward direction.\nWe can also use Reduce to perform quick iterative methods. Recall the sqrt_heron function that you wrote back in exercise 3 question 8, we can easily implement it using Reduce:\n\nS  &lt;- 125348\nn &lt;- 15 # number of iterations\nReduce(function(x,i)(x+S/x)/2, 1:n, 1)\n\n[1] 354.0452\n\n\nSince i is not used within the function, 1:n is not compulsory. As long as we have a vector of length 15, the function will run 15 times: eg to calculate \\(\\sqrt{10}\\) using 5 iterations we can do:\n\nReduce(function(x, i) (x + 10/x)/2, rep(0, 5), 1)\n\n[1] 3.162278\n\nReduce(function(x, i) (x + 10/x)/2, c(\"a\", \"b\", \"c\", \"d\", \"e\"), 1)\n\n[1] 3.162278\n\n\nNote that I even used strings. That is because the lambda function is just looping over the length of the vector and not over the elements of the vector.\nWe can then write a function that takes in S and number of iterations:\n\nsqrt_heron2 &lt;- function(x, n = 20,init = 1){\n  Reduce(\\(y,i)(y+x/y)/2, seq_len(n), init)\n}\nsqrt_heron2(10)\n\n[1] 3.162278\n\n\nTo learn more about continued fractions, pi estimation etc you can run help(\"Reduce\") then copy the examples and paste them on your editor, play around checking what the results is."
  },
  {
    "objectID": "Lists.html#dataframe-extraction",
    "href": "Lists.html#dataframe-extraction",
    "title": "Lists",
    "section": "Dataframe Extraction",
    "text": "Dataframe Extraction\nYou can extract elements from a dataframe exactly the same way as you extract them from a list or even from a matrix.\nExtract the first element of the first variable\n\ndat2[1,1] \n\n[1] 173\n\n\n\ndat2[[1]][1]\n\n[1] 173\n\n\n\ndat2[1, \"Height\"]\n\n[1] 173\n\n\n\ndat2[[\"Height\"]][1]\n\n[1] 173\n\ndat2$Height[1]\n\n[1] 173\n\n\nWhy can’t you do dat2[1][1] or even dat2['Height'][1]?\nExtract a variable:\n\ndat2$Height\n\n[1] 173 178 190 141\n\ndat2[['Height']]\n\n[1] 173 178 190 141\n\n\nExtract the 2nd observation:\n\ndat2[2, ]\n\n  Height Weight Age  name  YOB\n2    178    189  26 Billy 2001\n\n\nIn our case, the data does not have unique row names that identify each row. If it did, we could have been able to use that to extract the specific row we are interested in.\nNote that while in matrices, the columns do not necessarily need to have column names, this is not the case for dataframes. Each column MUST be named. Usually The names need to be unique, although base R does allow duplicated names. But one iss advised to have unique names for each column to ensure each column is uniquely identifiable.\nQuiz: Why is it not necessary for the columns of a matrix to be named? Because the columns might be representing the same thing with the difference being in position. Eg an image which is made up of pixels, each pixel containing the values from 0-255 can be represented as a matrix, whereby the row and column depict the position that the pixel occupies in the image. Note that everything is a pixel, just the position is different. On the other hand for a dataframe, all the columns represent different items/objects/variables/measurements.\nWith regards to dataframes, we have various functions in Base R that we will probably learn while learning the equivalence from the tidyverse package. These are by, aggregate, sweep etc."
  },
  {
    "objectID": "martix.html",
    "href": "martix.html",
    "title": "Matrices and Arrays",
    "section": "",
    "text": "Matrices are 2 dimensional structures used to store data, while arrays are high dimensional structures. In R matrices are just atomic vectors with an added dimenison attribute which enables R to portray the vector in rows and columns. Note that the length of the vector must be equal to \\(n \\times p\\) where n is the number of rows and p is the number of columns.\n\nvec10 &lt;- 1:12\nvec10\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12\n\nn &lt;- 4\np &lt;- 3\nattr(vec10, 'dim') &lt;- c(n, p)\nvec10\n\n     [,1] [,2] [,3]\n[1,]    1    5    9\n[2,]    2    6   10\n[3,]    3    7   11\n[4,]    4    8   12\n\n\nSince the dim attribute is common, there is a function for it. ie dim\n\na &lt;- 1:4 # a is a vector with no dimensions\ndim(a) # should return NULL\n\nNULL\n\ndim(a) &lt;- c(2,2) # we set the dimension\na # a is no longer a vector but a matrix/array\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\ndim(a)\n\n[1] 2 2\n\n\nIs this the convenient way of creating a matrix?\n\nx &lt;- matrix(1:4, 2)\nx\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\ny &lt;- array(1:4, c(2,2))\ny\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n\nFrom the above we can note that a matrix in R is column-major. ie the values are read in in a column wise manner. We can change the way the data is read using the byrow parameter in the matrix function. Look at the example below.\n\n\n\nA &lt;- matrix(c(1,0,2,3,4,5),nrow = 3, byrow = TRUE)\nB &lt;- matrix(1:6, ncol=3)\n\nThe arithmetic operators work on these matrices the same way they work on a vector. ie element-wise.\n\nA + 1\n\n     [,1] [,2]\n[1,]    2    1\n[2,]    3    4\n[3,]    5    6\n\nA + A\n\n     [,1] [,2]\n[1,]    2    0\n[2,]    4    6\n[3,]    8   10\n\nA^-1\n\n     [,1]      [,2]\n[1,] 1.00       Inf\n[2,] 0.50 0.3333333\n[3,] 0.25 0.2000000\n\n\nWhat if I tried adding A to B above?\n\nB+A\n\nError in B + A: non-conformable arrays\n\n\nWhat about matrix multiplication? Recall that the number of columns for the first matrix need to be equal to the number of Rows in the second matrix otherwise it wont work.\n\nA%*%B\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    8   18   28\n[3,]   14   32   50\n\nB%*%A\n\n     [,1] [,2]\n[1,]   27   34\n[2,]   34   42\n\nA%*%A\n\nError in A %*% A: non-conformable arguments\n\nA%*%t(A) # t is the transpose function\n\n     [,1] [,2] [,3]\n[1,]    1    2    4\n[2,]    2   13   23\n[3,]    4   23   41\n\ncrossprod(A) # t(A) %*% A\n\n     [,1] [,2]\n[1,]   21   26\n[2,]   26   34\n\ntcrossprod(A)\n\n     [,1] [,2] [,3]\n[1,]    1    2    4\n[2,]    2   13   23\n[3,]    4   23   41\n\ncrossprod(A, B)\n\nError in crossprod(A, B): non-conformable arguments\n\n\nYou can find inverse of a square matrix:\n\nD &lt;- B %*% A\nsolve(D)\n\n          [,1]      [,2]\n[1,] -1.909091  1.545455\n[2,]  1.545455 -1.227273\n\nE &lt;- A %*% B\nE\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    8   18   28\n[3,]   14   32   50\n\nG &lt;- crossprod(A)\nsolve(G)\n\n           [,1]       [,2]\n[1,]  0.8947368 -0.6842105\n[2,] -0.6842105  0.5526316\n\n\n\n\n\n\nt(A)\n\n     [,1] [,2] [,3]\n[1,]    1    2    4\n[2,]    0    3    5\n\ndiag(D)\n\n[1] 27 42\n\ndiag(E)\n\n[1]  1 18 50\n\nupper.tri(E)\n\n      [,1]  [,2]  [,3]\n[1,] FALSE  TRUE  TRUE\n[2,] FALSE FALSE  TRUE\n[3,] FALSE FALSE FALSE\n\nlower.tri(E)\n\n      [,1]  [,2]  [,3]\n[1,] FALSE FALSE FALSE\n[2,]  TRUE FALSE FALSE\n[3,]  TRUE  TRUE FALSE\n\ncol(A)\n\n     [,1] [,2]\n[1,]    1    2\n[2,]    1    2\n[3,]    1    2\n\nrow(A)\n\n     [,1] [,2]\n[1,]    1    1\n[2,]    2    2\n[3,]    3    3\n\nncol(A)\n\n[1] 2\n\nnrow(A)\n\n[1] 3\n\ndiag(D) &lt;- 1\ndiag(1:4)\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    0    0    0\n[2,]    0    2    0    0\n[3,]    0    0    3    0\n[4,]    0    0    0    4\n\ncolMeans(A)\n\n[1] 2.333333 2.666667\n\nrowMeans(A)\n\n[1] 0.5 2.5 4.5\n\ncolSums(A)\n\n[1] 7 8\n\nrowSums(A)\n\n[1] 1 5 9\n\nrbind(A, A)\n\n     [,1] [,2]\n[1,]    1    0\n[2,]    2    3\n[3,]    4    5\n[4,]    1    0\n[5,]    2    3\n[6,]    4    5\n\ncbind(A,A,A)\n\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    1    0    1    0    1    0\n[2,]    2    3    2    3    2    3\n[3,]    4    5    4    5    4    5\n\nmax.col(A)\n\n[1] 1 2 2\n\n\n\n\n\ncolumn names, row names\n\nMat1 &lt;- matrix(1:4, 2)\nMat1\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\ncolnames(Mat1) &lt;- c(\"column1\", \"column2\") # Set column names\nMat1\n\n     column1 column2\n[1,]       1       3\n[2,]       2       4\n\nrownames(Mat1) &lt;- c(\"row1\", \"row2\")\nMat1\n\n     column1 column2\nrow1       1       3\nrow2       2       4\n\n\n\nmat2 &lt;- matrix(1:4, 2, dimnames = list(c(\"row1\", \"row2\"), c(\"column1\", \"column2\")))\nmat2\n\n     column1 column2\nrow1       1       3\nrow2       2       4\n\ndimnames(mat2)\n\n[[1]]\n[1] \"row1\" \"row2\"\n\n[[2]]\n[1] \"column1\" \"column2\"\n\ndimnames(mat2) &lt;- NULL\ndimnames(mat2) &lt;-  list(c(\"row1\", \"row2\"), c(\"column1\", \"column2\"))\nmat2\n\n     column1 column2\nrow1       1       3\nrow2       2       4\n\ndimnames(mat2) &lt;-  list(rows = c(\"row1\", \"row2\"),columns= c(\"column1\", \"column2\"))\nmat2\n\n      columns\nrows   column1 column2\n  row1       1       3\n  row2       2       4\n\n\n\n\n\n\nA[1,1] # row 1, column 1\n\n[1] 1\n\nA[2,] # row 1\n\n[1] 2 3\n\nA[,2] # column 1\n\n[1] 0 3 5\n\nA[,2,drop = FALSE] # maintain the structure of the original object ie matrix/array\n\n     [,1]\n[1,]    0\n[2,]    3\n[3,]    5\n\nA[1,2] &lt;- -3\n\n\n\n\nWe have seen that if we want to find the column sums we use the colSums function. What if we want the col sds?\nuse apply(your_matrix, dimension, your_function) where dimension is 1 for rows and 2 form columns\n\nA &lt;- array(1:12, c(2,6))\napply(A, 2, sd) # columnwise sd\n\n[1] 0.7071068 0.7071068 0.7071068 0.7071068 0.7071068 0.7071068\n\napply(A, 2, mean) # similar to colMeans\n\n[1]  1.5  3.5  5.5  7.5  9.5 11.5\n\napply(A, 1, max)\n\n[1] 11 12\n\ncbind(seq(nrow(A)), max.col(A)) # What does this do?\n\n     [,1] [,2]\n[1,]    1    6\n[2,]    2    6\n\nA[cbind(seq(nrow(A)), max.col(A))]\n\n[1] 11 12\n\n\n\n\n\n\nA &lt;- array(1:12, c(2,6))\nA\n\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    1    3    5    7    9   11\n[2,]    2    4    6    8   10   12\n\nB &lt;- array(1:12, c(1,6,2)) \nB\n\n, , 1\n\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    1    2    3    4    5    6\n\n, , 2\n\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    7    8    9   10   11   12\n\nC &lt;- array(1:24, c(3,4,2)) \nC\n\n, , 1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n\n, , 2\n\n     [,1] [,2] [,3] [,4]\n[1,]   13   16   19   22\n[2,]   14   17   20   23\n[3,]   15   18   21   24\n\n\nUse apply\n\napply(C, 1, sum)\n\n[1]  92 100 108\n\napply(C, 2, sum)\n\n[1]  48  66  84 102\n\napply(C, 3, sum)\n\n[1]  78 222\n\napply(C,c(1,2), sum)\n\n     [,1] [,2] [,3] [,4]\n[1,]   14   20   26   32\n[2,]   16   22   28   34\n[3,]   18   24   30   36\n\napply(C, c(1,3), sum)\n\n     [,1] [,2]\n[1,]   22   70\n[2,]   26   74\n[3,]   30   78\n\napply(C,c(2,3), sum)\n\n     [,1] [,2]\n[1,]    6   42\n[2,]   15   51\n[3,]   24   60\n[4,]   33   69\n\n\nTo transpose a matrix, we use t function, what about transposing an array? we use aperm:\n\naperm(C, c(1,2,3))\n\n, , 1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n\n, , 2\n\n     [,1] [,2] [,3] [,4]\n[1,]   13   16   19   22\n[2,]   14   17   20   23\n[3,]   15   18   21   24\n\naperm(C,c(1,3,2))\n\n, , 1\n\n     [,1] [,2]\n[1,]    1   13\n[2,]    2   14\n[3,]    3   15\n\n, , 2\n\n     [,1] [,2]\n[1,]    4   16\n[2,]    5   17\n[3,]    6   18\n\n, , 3\n\n     [,1] [,2]\n[1,]    7   19\n[2,]    8   20\n[3,]    9   21\n\n, , 4\n\n     [,1] [,2]\n[1,]   10   22\n[2,]   11   23\n[3,]   12   24\n\naperm(C, c(2,1,3)) # etc\n\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n[4,]   10   11   12\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]   13   14   15\n[2,]   16   17   18\n[3,]   19   20   21\n[4,]   22   23   24\n\n\n\n\n\n\n(Work by hand) Suppose we are interested in solving a problem with the unknowns(parameters) being the values of a symmetric matrix with dimension \\(p \\times p\\) . Since the lower triangle of the matrix is equal to the upper triangle, we only need to solve just the lower triangle and the main diagonal. In that case, if P = 2, we need to solve for 3 parameters. If p = 3 we need to solve for 6 parameters, ie 3 in the main diagonal and 3 in the lower triangle. What is the number of parameters to be solved for, in terms of p?\nParameter Optimization: (Continuation on the above) Given a vector x of length p, where p is the number of parameters, write R code to turn the vector into a symmetric matrix.\nHint:\n\nx &lt;- 1:3 # the given vector\np &lt;- length(x) # The number of parameters\n\n# Should output\nmatrix(c(1,2,2,3), 2) \n\n     [,1] [,2]\n[1,]    1    2\n[2,]    2    3\n\nx &lt;- 1:6 #The given vector\n#Should output\nmatrix(c(1,2,3,2,4,5,3,5,6),3)\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    2    4    5\n[3,]    3    5    6\n\n\nMake use of the functions: t, lower.tri,upper.tri\nGiven the matrix z below, Use R to:\n\nz &lt;- matrix(1:16,4)\nz\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    5    9   13\n[2,]    2    6   10   14\n[3,]    3    7   11   15\n[4,]    4    8   12   16\n\n\n\n\nObtain the diagonal elements of matrix shown below. ie 1,6,11,16\nObtain the anti-diagonal elements of matrix shown below. ie 4,7,10,13\nObtain the elements adjacent to the main diagonal but off by 1. ie 2,7,12,5,10,15\nObtain the elements adjacent to the anti-diagonal but off by 1. ie 3,6,9,8,11,14\n\n\nHint: Use the functions col, row and the relational operator ==\nLinear Regression: For simple prediction purposes, we desire to obtain parameters that would reduce the bias between the actual value and the predicted value. Given the model as \\(\\mathbf{Y = X\\beta +\\epsilon}\\) we desire to have a \\(\\beta\\) such that \\(\\mathbf{Y\\approx X\\beta}\\) . ie the error term tends to 0 often written as \\(\\mathbf{\\mathbb{E}(Y) = X\\beta}\\) . This is often referred to as linear regression.\nThe optimal $\\beta$ that reduced the mean squared errors is computed as\n\\[\n\\hat\\beta = \\mathbf{(X^\\top X)^{-1}X^\\top Y}\n\\]\nGiven the data below, solve for the parameters \\(\\beta =\\begin{bmatrix}\\beta_0\\\\\\beta_1\\end{bmatrix}\\)\n\nx1 &lt;- c(3,6,3,3,5,8,9,10,4)\nY &lt;- 2.3 + 3*x1 + rnorm(x1, 0, 0.001) # ie B= (2.3, 3)\n\nHint: X must contain a column of 1’s\n\\[\n\\begin{aligned}y_i = &\\beta_0 + \\beta_1x_i + \\epsilon_i\\\\ = &\\big[1~~x_i\\big] \\begin{bmatrix}\\beta_0\\\\\\beta_1\\end{bmatrix} +\\epsilon_i\\end{aligned}\n\\]\nOne Hot Encoding: Given a vector that represents a class unto which an object belongs to, write a program that would transform the data vector into dummy matrix.\nExample\n\nmy_vec &lt;- c(2,1,1,2,3,4,3,2) # there are 4 classes.\n\nThen the one hot encoded data will look like:\n     1    2    3    4  Classes\n1    0    1    0    0  The 1st element is in class2\n2    1    0    0    0  The 2nd element is in class1\n3    1    0    0    0  The 3nd element is in class1\n4    0    1    0    0   :\n5    0    0    1    0   :\n6    0    0    0    1\n7    0    0    1    0\n8    0    1    0    0\nHint: use diag\nClassification: Also write a program that would revert back the dummy matrix into the original vector of classes. The matrix is given below\n\nmat1 &lt;- matrix(c(0L, 1L, 1L, 0L, 0L, 0L, 0L, 0L, 1L, 0L, 0L, 1L, 0L, 0L, 0L, \n1L, 0L, 0L, 0L, 0L, 1L, 0L, 1L, 0L, 0L, 0L, 0L, 0L, 0L, 1L, 0L, \n0L), 8)"
  },
  {
    "objectID": "martix.html#matrix-arithmetic",
    "href": "martix.html#matrix-arithmetic",
    "title": "Matrices and Arrays",
    "section": "",
    "text": "A &lt;- matrix(c(1,0,2,3,4,5),nrow = 3, byrow = TRUE)\nB &lt;- matrix(1:6, ncol=3)\n\nThe arithmetic operators work on these matrices the same way they work on a vector. ie element-wise.\n\nA + 1\n\n     [,1] [,2]\n[1,]    2    1\n[2,]    3    4\n[3,]    5    6\n\nA + A\n\n     [,1] [,2]\n[1,]    2    0\n[2,]    4    6\n[3,]    8   10\n\nA^-1\n\n     [,1]      [,2]\n[1,] 1.00       Inf\n[2,] 0.50 0.3333333\n[3,] 0.25 0.2000000\n\n\nWhat if I tried adding A to B above?\n\nB+A\n\nError in B + A: non-conformable arrays\n\n\nWhat about matrix multiplication? Recall that the number of columns for the first matrix need to be equal to the number of Rows in the second matrix otherwise it wont work.\n\nA%*%B\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    8   18   28\n[3,]   14   32   50\n\nB%*%A\n\n     [,1] [,2]\n[1,]   27   34\n[2,]   34   42\n\nA%*%A\n\nError in A %*% A: non-conformable arguments\n\nA%*%t(A) # t is the transpose function\n\n     [,1] [,2] [,3]\n[1,]    1    2    4\n[2,]    2   13   23\n[3,]    4   23   41\n\ncrossprod(A) # t(A) %*% A\n\n     [,1] [,2]\n[1,]   21   26\n[2,]   26   34\n\ntcrossprod(A)\n\n     [,1] [,2] [,3]\n[1,]    1    2    4\n[2,]    2   13   23\n[3,]    4   23   41\n\ncrossprod(A, B)\n\nError in crossprod(A, B): non-conformable arguments\n\n\nYou can find inverse of a square matrix:\n\nD &lt;- B %*% A\nsolve(D)\n\n          [,1]      [,2]\n[1,] -1.909091  1.545455\n[2,]  1.545455 -1.227273\n\nE &lt;- A %*% B\nE\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    8   18   28\n[3,]   14   32   50\n\nG &lt;- crossprod(A)\nsolve(G)\n\n           [,1]       [,2]\n[1,]  0.8947368 -0.6842105\n[2,] -0.6842105  0.5526316"
  },
  {
    "objectID": "martix.html#other-matrix-functions",
    "href": "martix.html#other-matrix-functions",
    "title": "Matrices and Arrays",
    "section": "",
    "text": "t(A)\n\n     [,1] [,2] [,3]\n[1,]    1    2    4\n[2,]    0    3    5\n\ndiag(D)\n\n[1] 27 42\n\ndiag(E)\n\n[1]  1 18 50\n\nupper.tri(E)\n\n      [,1]  [,2]  [,3]\n[1,] FALSE  TRUE  TRUE\n[2,] FALSE FALSE  TRUE\n[3,] FALSE FALSE FALSE\n\nlower.tri(E)\n\n      [,1]  [,2]  [,3]\n[1,] FALSE FALSE FALSE\n[2,]  TRUE FALSE FALSE\n[3,]  TRUE  TRUE FALSE\n\ncol(A)\n\n     [,1] [,2]\n[1,]    1    2\n[2,]    1    2\n[3,]    1    2\n\nrow(A)\n\n     [,1] [,2]\n[1,]    1    1\n[2,]    2    2\n[3,]    3    3\n\nncol(A)\n\n[1] 2\n\nnrow(A)\n\n[1] 3\n\ndiag(D) &lt;- 1\ndiag(1:4)\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    0    0    0\n[2,]    0    2    0    0\n[3,]    0    0    3    0\n[4,]    0    0    0    4\n\ncolMeans(A)\n\n[1] 2.333333 2.666667\n\nrowMeans(A)\n\n[1] 0.5 2.5 4.5\n\ncolSums(A)\n\n[1] 7 8\n\nrowSums(A)\n\n[1] 1 5 9\n\nrbind(A, A)\n\n     [,1] [,2]\n[1,]    1    0\n[2,]    2    3\n[3,]    4    5\n[4,]    1    0\n[5,]    2    3\n[6,]    4    5\n\ncbind(A,A,A)\n\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    1    0    1    0    1    0\n[2,]    2    3    2    3    2    3\n[3,]    4    5    4    5    4    5\n\nmax.col(A)\n\n[1] 1 2 2"
  },
  {
    "objectID": "martix.html#matrix-attributes",
    "href": "martix.html#matrix-attributes",
    "title": "Matrices and Arrays",
    "section": "",
    "text": "column names, row names\n\nMat1 &lt;- matrix(1:4, 2)\nMat1\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\ncolnames(Mat1) &lt;- c(\"column1\", \"column2\") # Set column names\nMat1\n\n     column1 column2\n[1,]       1       3\n[2,]       2       4\n\nrownames(Mat1) &lt;- c(\"row1\", \"row2\")\nMat1\n\n     column1 column2\nrow1       1       3\nrow2       2       4\n\n\n\nmat2 &lt;- matrix(1:4, 2, dimnames = list(c(\"row1\", \"row2\"), c(\"column1\", \"column2\")))\nmat2\n\n     column1 column2\nrow1       1       3\nrow2       2       4\n\ndimnames(mat2)\n\n[[1]]\n[1] \"row1\" \"row2\"\n\n[[2]]\n[1] \"column1\" \"column2\"\n\ndimnames(mat2) &lt;- NULL\ndimnames(mat2) &lt;-  list(c(\"row1\", \"row2\"), c(\"column1\", \"column2\"))\nmat2\n\n     column1 column2\nrow1       1       3\nrow2       2       4\n\ndimnames(mat2) &lt;-  list(rows = c(\"row1\", \"row2\"),columns= c(\"column1\", \"column2\"))\nmat2\n\n      columns\nrows   column1 column2\n  row1       1       3\n  row2       2       4"
  },
  {
    "objectID": "martix.html#matrix-sub-setting",
    "href": "martix.html#matrix-sub-setting",
    "title": "Matrices and Arrays",
    "section": "",
    "text": "A[1,1] # row 1, column 1\n\n[1] 1\n\nA[2,] # row 1\n\n[1] 2 3\n\nA[,2] # column 1\n\n[1] 0 3 5\n\nA[,2,drop = FALSE] # maintain the structure of the original object ie matrix/array\n\n     [,1]\n[1,]    0\n[2,]    3\n[3,]    5\n\nA[1,2] &lt;- -3"
  },
  {
    "objectID": "martix.html#advanced-matrix-functions",
    "href": "martix.html#advanced-matrix-functions",
    "title": "Matrices and Arrays",
    "section": "",
    "text": "We have seen that if we want to find the column sums we use the colSums function. What if we want the col sds?\nuse apply(your_matrix, dimension, your_function) where dimension is 1 for rows and 2 form columns\n\nA &lt;- array(1:12, c(2,6))\napply(A, 2, sd) # columnwise sd\n\n[1] 0.7071068 0.7071068 0.7071068 0.7071068 0.7071068 0.7071068\n\napply(A, 2, mean) # similar to colMeans\n\n[1]  1.5  3.5  5.5  7.5  9.5 11.5\n\napply(A, 1, max)\n\n[1] 11 12\n\ncbind(seq(nrow(A)), max.col(A)) # What does this do?\n\n     [,1] [,2]\n[1,]    1    6\n[2,]    2    6\n\nA[cbind(seq(nrow(A)), max.col(A))]\n\n[1] 11 12"
  },
  {
    "objectID": "martix.html#arrays",
    "href": "martix.html#arrays",
    "title": "Matrices and Arrays",
    "section": "",
    "text": "A &lt;- array(1:12, c(2,6))\nA\n\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    1    3    5    7    9   11\n[2,]    2    4    6    8   10   12\n\nB &lt;- array(1:12, c(1,6,2)) \nB\n\n, , 1\n\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    1    2    3    4    5    6\n\n, , 2\n\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    7    8    9   10   11   12\n\nC &lt;- array(1:24, c(3,4,2)) \nC\n\n, , 1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n\n, , 2\n\n     [,1] [,2] [,3] [,4]\n[1,]   13   16   19   22\n[2,]   14   17   20   23\n[3,]   15   18   21   24\n\n\nUse apply\n\napply(C, 1, sum)\n\n[1]  92 100 108\n\napply(C, 2, sum)\n\n[1]  48  66  84 102\n\napply(C, 3, sum)\n\n[1]  78 222\n\napply(C,c(1,2), sum)\n\n     [,1] [,2] [,3] [,4]\n[1,]   14   20   26   32\n[2,]   16   22   28   34\n[3,]   18   24   30   36\n\napply(C, c(1,3), sum)\n\n     [,1] [,2]\n[1,]   22   70\n[2,]   26   74\n[3,]   30   78\n\napply(C,c(2,3), sum)\n\n     [,1] [,2]\n[1,]    6   42\n[2,]   15   51\n[3,]   24   60\n[4,]   33   69\n\n\nTo transpose a matrix, we use t function, what about transposing an array? we use aperm:\n\naperm(C, c(1,2,3))\n\n, , 1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n\n, , 2\n\n     [,1] [,2] [,3] [,4]\n[1,]   13   16   19   22\n[2,]   14   17   20   23\n[3,]   15   18   21   24\n\naperm(C,c(1,3,2))\n\n, , 1\n\n     [,1] [,2]\n[1,]    1   13\n[2,]    2   14\n[3,]    3   15\n\n, , 2\n\n     [,1] [,2]\n[1,]    4   16\n[2,]    5   17\n[3,]    6   18\n\n, , 3\n\n     [,1] [,2]\n[1,]    7   19\n[2,]    8   20\n[3,]    9   21\n\n, , 4\n\n     [,1] [,2]\n[1,]   10   22\n[2,]   11   23\n[3,]   12   24\n\naperm(C, c(2,1,3)) # etc\n\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n[4,]   10   11   12\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]   13   14   15\n[2,]   16   17   18\n[3,]   19   20   21\n[4,]   22   23   24"
  },
  {
    "objectID": "martix.html#exercise",
    "href": "martix.html#exercise",
    "title": "Matrices and Arrays",
    "section": "",
    "text": "(Work by hand) Suppose we are interested in solving a problem with the unknowns(parameters) being the values of a symmetric matrix with dimension \\(p \\times p\\) . Since the lower triangle of the matrix is equal to the upper triangle, we only need to solve just the lower triangle and the main diagonal. In that case, if P = 2, we need to solve for 3 parameters. If p = 3 we need to solve for 6 parameters, ie 3 in the main diagonal and 3 in the lower triangle. What is the number of parameters to be solved for, in terms of p?\nParameter Optimization: (Continuation on the above) Given a vector x of length p, where p is the number of parameters, write R code to turn the vector into a symmetric matrix.\nHint:\n\nx &lt;- 1:3 # the given vector\np &lt;- length(x) # The number of parameters\n\n# Should output\nmatrix(c(1,2,2,3), 2) \n\n     [,1] [,2]\n[1,]    1    2\n[2,]    2    3\n\nx &lt;- 1:6 #The given vector\n#Should output\nmatrix(c(1,2,3,2,4,5,3,5,6),3)\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    2    4    5\n[3,]    3    5    6\n\n\nMake use of the functions: t, lower.tri,upper.tri\nGiven the matrix z below, Use R to:\n\nz &lt;- matrix(1:16,4)\nz\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    5    9   13\n[2,]    2    6   10   14\n[3,]    3    7   11   15\n[4,]    4    8   12   16\n\n\n\n\nObtain the diagonal elements of matrix shown below. ie 1,6,11,16\nObtain the anti-diagonal elements of matrix shown below. ie 4,7,10,13\nObtain the elements adjacent to the main diagonal but off by 1. ie 2,7,12,5,10,15\nObtain the elements adjacent to the anti-diagonal but off by 1. ie 3,6,9,8,11,14\n\n\nHint: Use the functions col, row and the relational operator ==\nLinear Regression: For simple prediction purposes, we desire to obtain parameters that would reduce the bias between the actual value and the predicted value. Given the model as \\(\\mathbf{Y = X\\beta +\\epsilon}\\) we desire to have a \\(\\beta\\) such that \\(\\mathbf{Y\\approx X\\beta}\\) . ie the error term tends to 0 often written as \\(\\mathbf{\\mathbb{E}(Y) = X\\beta}\\) . This is often referred to as linear regression.\nThe optimal $\\beta$ that reduced the mean squared errors is computed as\n\\[\n\\hat\\beta = \\mathbf{(X^\\top X)^{-1}X^\\top Y}\n\\]\nGiven the data below, solve for the parameters \\(\\beta =\\begin{bmatrix}\\beta_0\\\\\\beta_1\\end{bmatrix}\\)\n\nx1 &lt;- c(3,6,3,3,5,8,9,10,4)\nY &lt;- 2.3 + 3*x1 + rnorm(x1, 0, 0.001) # ie B= (2.3, 3)\n\nHint: X must contain a column of 1’s\n\\[\n\\begin{aligned}y_i = &\\beta_0 + \\beta_1x_i + \\epsilon_i\\\\ = &\\big[1~~x_i\\big] \\begin{bmatrix}\\beta_0\\\\\\beta_1\\end{bmatrix} +\\epsilon_i\\end{aligned}\n\\]\nOne Hot Encoding: Given a vector that represents a class unto which an object belongs to, write a program that would transform the data vector into dummy matrix.\nExample\n\nmy_vec &lt;- c(2,1,1,2,3,4,3,2) # there are 4 classes.\n\nThen the one hot encoded data will look like:\n     1    2    3    4  Classes\n1    0    1    0    0  The 1st element is in class2\n2    1    0    0    0  The 2nd element is in class1\n3    1    0    0    0  The 3nd element is in class1\n4    0    1    0    0   :\n5    0    0    1    0   :\n6    0    0    0    1\n7    0    0    1    0\n8    0    1    0    0\nHint: use diag\nClassification: Also write a program that would revert back the dummy matrix into the original vector of classes. The matrix is given below\n\nmat1 &lt;- matrix(c(0L, 1L, 1L, 0L, 0L, 0L, 0L, 0L, 1L, 0L, 0L, 1L, 0L, 0L, 0L, \n1L, 0L, 0L, 0L, 0L, 1L, 0L, 1L, 0L, 0L, 0L, 0L, 0L, 0L, 1L, 0L, \n0L), 8)"
  },
  {
    "objectID": "matrix.html",
    "href": "matrix.html",
    "title": "Matrices and Arrays",
    "section": "",
    "text": "Matrices are 2 dimensional structures used to store data, while arrays are high dimensional structures. In R matrices are just atomic vectors with an added dimension attribute which enables R to portray the vector in rows and columns. Note that the length of the vector must be equal to \\(n \\times p\\) where n is the number of rows and p is the number of columns.\nvec10 &lt;- 1:12\nvec10\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12\n\nn &lt;- 4\np &lt;- 3\nattr(vec10, 'dim') &lt;- c(n, p)\nvec10\n\n     [,1] [,2] [,3]\n[1,]    1    5    9\n[2,]    2    6   10\n[3,]    3    7   11\n[4,]    4    8   12\nSince the dim attribute is common, there is a function for it. ie dim\na &lt;- 1:4 # a is a vector with no dimensions\ndim(a) # should return NULL\n\nNULL\n\ndim(a) &lt;- c(2,2) # we set the dimension\na # a is no longer a vector but a matrix/array\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\ndim(a)\n\n[1] 2 2\nIs this the convenient way of creating a matrix?\nx &lt;- matrix(1:4, 2)\nx\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\ny &lt;- array(1:4, c(2,2))\ny\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\nFrom the above we can note that a matrix in R is column-major. ie the values are read in in a column wise manner. We can change the way the data is read using the byrow parameter in the matrix function. Look at the example below."
  },
  {
    "objectID": "matrix.html#matrix-arithmetic",
    "href": "matrix.html#matrix-arithmetic",
    "title": "Matrices and Arrays",
    "section": "Matrix arithmetic",
    "text": "Matrix arithmetic\n\nA &lt;- matrix(c(1,0,2,3,4,5),nrow = 3, byrow = TRUE)\nB &lt;- matrix(1:6, ncol=3)\n\nThe arithmetic operators work on these matrices the same way they work on a vector. ie element-wise.\n\nA + 1\n\n     [,1] [,2]\n[1,]    2    1\n[2,]    3    4\n[3,]    5    6\n\nA + A\n\n     [,1] [,2]\n[1,]    2    0\n[2,]    4    6\n[3,]    8   10\n\nA^-1\n\n     [,1]      [,2]\n[1,] 1.00       Inf\n[2,] 0.50 0.3333333\n[3,] 0.25 0.2000000\n\n\nWhat if I tried adding A to B above?\n\nB+A\n\nError in B + A: non-conformable arrays\n\n\nWhat about matrix multiplication? Recall that the number of columns for the first matrix need to be equal to the number of Rows in the second matrix otherwise it wont work.\n\nA %*% B\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    8   18   28\n[3,]   14   32   50\n\nB%*%A\n\n     [,1] [,2]\n[1,]   27   34\n[2,]   34   42\n\nA%*%A\n\nError in A %*% A: non-conformable arguments\n\nA%*%t(A) # t is the transpose function\n\n     [,1] [,2] [,3]\n[1,]    1    2    4\n[2,]    2   13   23\n[3,]    4   23   41\n\ncrossprod(A) # t(A) %*% A\n\n     [,1] [,2]\n[1,]   21   26\n[2,]   26   34\n\ntcrossprod(A) # A %*% t(A)\n\n     [,1] [,2] [,3]\n[1,]    1    2    4\n[2,]    2   13   23\n[3,]    4   23   41\n\ncrossprod(A, B)\n\nError in crossprod(A, B): non-conformable arguments\n\n\nYou can find inverse of a square matrix:\n\nD &lt;- B %*% A\nsolve(D)\n\n          [,1]      [,2]\n[1,] -1.909091  1.545455\n[2,]  1.545455 -1.227273\n\nE &lt;- A %*% B\nE\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    8   18   28\n[3,]   14   32   50\n\nG &lt;- crossprod(A)\nsolve(G)\n\n           [,1]       [,2]\n[1,]  0.8947368 -0.6842105\n[2,] -0.6842105  0.5526316"
  },
  {
    "objectID": "matrix.html#other-matrix-functions",
    "href": "matrix.html#other-matrix-functions",
    "title": "Matrices and Arrays",
    "section": "Other matrix functions",
    "text": "Other matrix functions\n\nt(A)\n\n     [,1] [,2] [,3]\n[1,]    1    2    4\n[2,]    0    3    5\n\ndiag(D)\n\n[1] 27 42\n\ndiag(E)\n\n[1]  1 18 50\n\nupper.tri(E)\n\n      [,1]  [,2]  [,3]\n[1,] FALSE  TRUE  TRUE\n[2,] FALSE FALSE  TRUE\n[3,] FALSE FALSE FALSE\n\nlower.tri(E)\n\n      [,1]  [,2]  [,3]\n[1,] FALSE FALSE FALSE\n[2,]  TRUE FALSE FALSE\n[3,]  TRUE  TRUE FALSE\n\ncol(A)\n\n     [,1] [,2]\n[1,]    1    2\n[2,]    1    2\n[3,]    1    2\n\nrow(A)\n\n     [,1] [,2]\n[1,]    1    1\n[2,]    2    2\n[3,]    3    3\n\nncol(A)\n\n[1] 2\n\nnrow(A)\n\n[1] 3\n\ndiag(D) &lt;- 1\ndiag(1:4)\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    0    0    0\n[2,]    0    2    0    0\n[3,]    0    0    3    0\n[4,]    0    0    0    4\n\ncolMeans(A)\n\n[1] 2.333333 2.666667\n\nrowMeans(A)\n\n[1] 0.5 2.5 4.5\n\ncolSums(A)\n\n[1] 7 8\n\nrowSums(A)\n\n[1] 1 5 9\n\nrbind(A, A)\n\n     [,1] [,2]\n[1,]    1    0\n[2,]    2    3\n[3,]    4    5\n[4,]    1    0\n[5,]    2    3\n[6,]    4    5\n\ncbind(A,A,A)\n\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    1    0    1    0    1    0\n[2,]    2    3    2    3    2    3\n[3,]    4    5    4    5    4    5\n\nmax.col(A)\n\n[1] 1 2 2\n\n\nWhat if I want to subtract the column means from each column?\n\nA\n\n     [,1] [,2]\n[1,]    1    0\n[2,]    2    3\n[3,]    4    5\n\ncolMeans(A)\n\n[1] 2.333333 2.666667\n\nA- colMeans(A) #But is this correct?\n\n           [,1]       [,2]\n[1,] -1.3333333 -2.6666667\n[2,] -0.6666667  0.6666667\n[3,]  1.6666667  2.3333333\n\nt(t(A) - colMeans(A))\n\n           [,1]       [,2]\n[1,] -1.3333333 -2.6666667\n[2,] -0.3333333  0.3333333\n[3,]  1.6666667  2.3333333\n\nsweep(A, 2, colMeans(A))\n\n           [,1]       [,2]\n[1,] -1.3333333 -2.6666667\n[2,] -0.3333333  0.3333333\n[3,]  1.6666667  2.3333333\n\nscale(A, center = TRUE, scale = FALSE)\n\n           [,1]       [,2]\n[1,] -1.3333333 -2.6666667\n[2,] -0.3333333  0.3333333\n[3,]  1.6666667  2.3333333\nattr(,\"scaled:center\")\n[1] 2.333333 2.666667"
  },
  {
    "objectID": "matrix.html#matrix-attributes",
    "href": "matrix.html#matrix-attributes",
    "title": "Matrices and Arrays",
    "section": "Matrix Attributes:",
    "text": "Matrix Attributes:\ncolumn names, row names\n\nMat1 &lt;- matrix(1:4, 2)\nMat1\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\ncolnames(Mat1) &lt;- c(\"column1\", \"column2\") # Set column names\nMat1\n\n     column1 column2\n[1,]       1       3\n[2,]       2       4\n\nrownames(Mat1) &lt;- c(\"row1\", \"row2\")\nMat1\n\n     column1 column2\nrow1       1       3\nrow2       2       4\n\n\n\nmat2 &lt;- matrix(1:4, 2, dimnames = list(c(\"row1\", \"row2\"), c(\"column1\", \"column2\")))\nmat2\n\n     column1 column2\nrow1       1       3\nrow2       2       4\n\ndimnames(mat2)\n\n[[1]]\n[1] \"row1\" \"row2\"\n\n[[2]]\n[1] \"column1\" \"column2\"\n\ndimnames(mat2) &lt;- NULL\ndimnames(mat2) &lt;-  list(c(\"row1\", \"row2\"), c(\"column1\", \"column2\"))\nmat2\n\n     column1 column2\nrow1       1       3\nrow2       2       4\n\ndimnames(mat2) &lt;-  list(rows = c(\"row1\", \"row2\"),columns= c(\"column1\", \"column2\"))\nmat2\n\n      columns\nrows   column1 column2\n  row1       1       3\n  row2       2       4"
  },
  {
    "objectID": "matrix.html#matrix-sub-setting",
    "href": "matrix.html#matrix-sub-setting",
    "title": "Matrices and Arrays",
    "section": "Matrix Sub-setting",
    "text": "Matrix Sub-setting\n\nA[1,1] # row 1, column 1\n\n[1] 1\n\nA[2,] # row 1\n\n[1] 2 3\n\nA[,2] # column 1\n\n[1] 0 3 5\n\nA[,2,drop = FALSE] # maintain the structure of the original object ie matrix/array\n\n     [,1]\n[1,]    0\n[2,]    3\n[3,]    5\n\nA[1,2] &lt;- -3"
  },
  {
    "objectID": "matrix.html#advanced-matrix-functions",
    "href": "matrix.html#advanced-matrix-functions",
    "title": "Matrices and Arrays",
    "section": "Advanced Matrix functions:",
    "text": "Advanced Matrix functions:\nWe have seen that if we want to find the column sums we use the colSums function. What if we want the col sds?\nuse apply(your_matrix, dimension, your_function) where dimension is 1 for rows and 2 form columns\n\nA &lt;- array(1:12, c(2,6))\napply(A, 2, sd) # columnwise sd\n\n[1] 0.7071068 0.7071068 0.7071068 0.7071068 0.7071068 0.7071068\n\napply(A, 2, mean) # similar to colMeans\n\n[1]  1.5  3.5  5.5  7.5  9.5 11.5\n\napply(A, 1, max)\n\n[1] 11 12\n\ncbind(seq(nrow(A)), max.col(A)) # What does this do?\n\n     [,1] [,2]\n[1,]    1    6\n[2,]    2    6\n\nA[cbind(seq(nrow(A)), max.col(A))]\n\n[1] 11 12"
  },
  {
    "objectID": "matrix.html#arrays",
    "href": "matrix.html#arrays",
    "title": "Matrices and Arrays",
    "section": "Arrays",
    "text": "Arrays\n\nA &lt;- array(1:12, c(2,6))\nA\n\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    1    3    5    7    9   11\n[2,]    2    4    6    8   10   12\n\nB &lt;- array(1:12, c(1,6,2)) \nB\n\n, , 1\n\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    1    2    3    4    5    6\n\n, , 2\n\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    7    8    9   10   11   12\n\nC &lt;- array(1:24, c(3,4,2)) \nC\n\n, , 1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n\n, , 2\n\n     [,1] [,2] [,3] [,4]\n[1,]   13   16   19   22\n[2,]   14   17   20   23\n[3,]   15   18   21   24\n\n\nUse apply\n\napply(C, 1, sum)\n\n[1]  92 100 108\n\napply(C, 2, sum)\n\n[1]  48  66  84 102\n\napply(C, 3, sum)\n\n[1]  78 222\n\napply(C,c(1,2), sum)\n\n     [,1] [,2] [,3] [,4]\n[1,]   14   20   26   32\n[2,]   16   22   28   34\n[3,]   18   24   30   36\n\napply(C, c(1,3), sum)\n\n     [,1] [,2]\n[1,]   22   70\n[2,]   26   74\n[3,]   30   78\n\napply(C,c(2,3), sum)\n\n     [,1] [,2]\n[1,]    6   42\n[2,]   15   51\n[3,]   24   60\n[4,]   33   69\n\n\nTo transpose a matrix, we use t function, what about transposing an array? we use aperm:\n\naperm(C, c(1,2,3))\n\n, , 1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n\n, , 2\n\n     [,1] [,2] [,3] [,4]\n[1,]   13   16   19   22\n[2,]   14   17   20   23\n[3,]   15   18   21   24\n\naperm(C,c(1,3,2))\n\n, , 1\n\n     [,1] [,2]\n[1,]    1   13\n[2,]    2   14\n[3,]    3   15\n\n, , 2\n\n     [,1] [,2]\n[1,]    4   16\n[2,]    5   17\n[3,]    6   18\n\n, , 3\n\n     [,1] [,2]\n[1,]    7   19\n[2,]    8   20\n[3,]    9   21\n\n, , 4\n\n     [,1] [,2]\n[1,]   10   22\n[2,]   11   23\n[3,]   12   24\n\naperm(C, c(2,1,3)) # etc\n\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n[4,]   10   11   12\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]   13   14   15\n[2,]   16   17   18\n[3,]   19   20   21\n[4,]   22   23   24"
  },
  {
    "objectID": "matrix.html#exercise",
    "href": "matrix.html#exercise",
    "title": "Matrices and Arrays",
    "section": "Exercise",
    "text": "Exercise\n\nPower of a matrix: implement a function called mat_pow(A, n) that takes in two parameters, a square matrix, and an exponent, and returns the matrix multiplied by itself n number of times:\n\\[\n\\begin{aligned} A^2 &=  A\\times A\\\\ A^3 &= A\\times A\\times A\\\\ \\vdots\\\\ A^n &= \\underbrace{A\\times A\\times\\cdots\\times A}_{n \\text{ factors of }A}=\\prod_{i=1}^nA \\end{aligned}\n\\]\n(Work by hand) Suppose we are interested in solving a problem with the unknowns(parameters) being the values of a symmetric matrix with dimension \\(p \\times p\\) . Since the lower triangle of the matrix is equal to the upper triangle, we only need to solve just the lower triangle and the main diagonal. In that case, if P = 2, we need to solve for 3 parameters. If p = 3 we need to solve for 6 parameters, ie 3 in the main diagonal and 3 in the lower triangle. What is the number of parameters to be solved for, in terms of p?\nParameter Optimization: (Continuation on the above) Given a vector x of length p, where p is the number of pa xrameters, write R code to turn the vector into a symmetric matrix.\nHint:\n\nx &lt;- 1:3 # the given vector\np &lt;- length(x) # The number of parameters\n\n# Should output\nmatrix(c(1,2,2,3), 2) \n\n     [,1] [,2]\n[1,]    1    2\n[2,]    2    3\n\nx &lt;- 1:6 #The given vector\n#Should output\nmatrix(c(1,2,3,2,4,5,3,5,6),3)\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    2    4    5\n[3,]    3    5    6\n\n\nMake use of the functions: t, lower.tri,upper.tri\nGiven the matrix z below, Use R to:\n\nz &lt;- matrix(1:16,4)\nz\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    5    9   13\n[2,]    2    6   10   14\n[3,]    3    7   11   15\n[4,]    4    8   12   16\n\n\n\n\nObtain the diagonal elements of matrix shown below. ie 1,6,11,16\nObtain the anti-diagonal elements of matrix shown below. ie 4,7,10,13\nObtain the elements adjacent to the main diagonal but off by 1. ie 2,7,12,5,10,15\nObtain the elements adjacent to the anti-diagonal but off by 1. ie 3,6,9,8,11,14\n\n\nHint: Use the functions col, row and the relational operator ==\nLinear Regression: For simple prediction purposes, we desire to obtain parameters that would reduce the bias between the actual value and the predicted value. Given the model as \\(\\mathbf{Y = X\\beta +\\epsilon}\\) we desire to have a \\(\\beta\\) such that \\(\\mathbf{Y\\approx X\\beta}\\) . ie the error term tends to 0 often written as \\(\\mathbf{\\mathbb{E}(Y) = X\\beta}\\) . This is often referred to as linear regression.\nThe optimal $\\beta$ that reduced the mean squared errors is computed as\n\\[\n\\hat\\beta = \\mathbf{(X^\\top X)^{-1}X^\\top Y}\n\\]\nGiven the data below, solve for the parameters \\(\\beta =\\begin{bmatrix}\\beta_0\\\\\\beta_1\\end{bmatrix}\\)\n\nset.seed(1) # For reproducibility\nx1 &lt;- c(3,6,3,3,5,8,9,10,4)\nY &lt;- 2.3 + 3*x1 + rnorm(x1, 0, 0.001) # ie B= (2.3, 3)\n\nHint: X must contain a column of 1’s\n\\[\n\\begin{aligned}y_i = &\\beta_0 + \\beta_1x_i + \\epsilon_i\\\\ = &\\big[1~~x_i\\big] \\begin{bmatrix}\\beta_0\\\\\\beta_1\\end{bmatrix} +\\epsilon_i\\end{aligned}\n\\]\nOne Hot Encoding: Given a vector that represents a class unto which an object belongs to, write a program that would transform the data vector into dummy matrix.\nExample\n\nmy_vec &lt;- c(2,1,1,2,3,4,3,2) # there are 4 classes.\n\nThen the one hot encoded data will look like:\n     1    2    3    4  Classes\n1    0    1    0    0  The 1st element is in class2\n2    1    0    0    0  The 2nd element is in class1\n3    1    0    0    0  The 3nd element is in class1\n4    0    1    0    0   :\n5    0    0    1    0   :\n6    0    0    0    1\n7    0    0    1    0\n8    0    1    0    0\nHint: use diag\nClassification: Also write a program that would revert back the dummy matrix into the original vector of classes. The matrix is given below\n\nmat1 &lt;- matrix(c(0L, 1L, 1L, 0L, 0L, 0L, 0L, 0L, 1L, 0L, 0L, 1L, 0L, 0L, 0L, \n1L, 0L, 0L, 0L, 0L, 1L, 0L, 1L, 0L, 0L, 0L, 0L, 0L, 0L, 1L, 0L, \n0L), 8)\nmat1\n\n     [,1] [,2] [,3] [,4]\n[1,]    0    1    0    0\n[2,]    1    0    0    0\n[3,]    1    0    0    0\n[4,]    0    1    0    0\n[5,]    0    0    1    0\n[6,]    0    0    0    1\n[7,]    0    0    1    0\n[8,]    0    1    0    0\n\n\nData encoding Suppose you are given the matrix below:\n\n\n\nprimary_color\nsecondary_color\ntertiary_color\n\n\n\n\nred\nblue\ngreen\n\n\nyellow\nred\nNA\n\n\n\nand we want this to be encoded by checking if the color exists across any of the three columns (1) or none of the 3 columns (0). So, it should yield:\n\nWrite an R code to produce the above result:\n\n\nblue\ngreen\nred\nyellow\n\n\n\n\n1\n1\n1\n0\n\n\n0\n0\n1\n1\n\n\n\nMatrix Inversion: Write a function inverse(A, B)that uses Gauss-Jordan elimination method to obtain obtain the solution of \\(x\\) in \\(Ax = b\\) where A is a square matrix and b is a known vector. Consider not inverting the matrix \\(A\\)."
  },
  {
    "objectID": "minimization.html",
    "href": "minimization.html",
    "title": "Minimization",
    "section": "",
    "text": "Previously we looked at root finding methods. Suppose instead of obtaining the root, we want to obtain the optimal point of the function. ie either maximum or minimum. We know that at the optimum, the gradient is 0. Thus for optimization, we opt to obtain the root of the gradient ie \\(f'(x) = 0\\).\nTo do this, we use the methods described above but we use \\(f'(x)\\) as our function of interest.\nTherefore the updating methodology becomes:\n\\[\nx_{n+1} = x_n \\pm \\alpha f'(x)\n\\]\nThis is called the GRADIENT/STEEPEST DESCENT(ASCENT) ALGORITHM.\nie if we use addition the we talk of ascent and if we use subtraction we talk of descent.\nThe choice of \\(\\alpha\\) corresponds to the different methods available.\n\nNewton Raphson:\nFor this method \\(\\alpha = \\frac{1}{f''(x)}\\) . If \\(f\\) is multivariate, then we have \\(\\alpha = H^{-1}(x)\\) where \\(H(x) = \\nabla^2f(x) = \\frac{\\partial^2 f(x)}{\\partial x \\partial x^\\top}\\) ie 2nd order derivative of the function evaluated at \\(x\\)\nExamples:\n\nFind the minimum of \\(f(x) = 2x^2 - 3\\)\nFirst we can plot to see how the function looks like\n\nRPython\n\n\n\nplot(x &lt;- seq(-5,5,length = 50), 2 * x**2 - 3, ty='l')\n\n\n\n\n\n\n\nimport matplotlib.pyplot as plt, numpy as np\nplt.clf()\nplt.plot(x := np.linspace(-5,5), 2 * x**2 - 3)\nplt.show()\n\n\n\n\n\n\n\nWe can see that the optimum/minimum occurs at \\(x=0\\). Now we can solve this analytically:\n\n\\[\nf'(x) = 4x \\therefore f'(x) = 0 \\implies x=0\\\\\nf''(0) = 4 &gt; 0 \\implies x=0 \\text{ is a minimum}\n\\]\n\nRPython\n\n\n\noptimize(\\(x)2*x**2 -3, c(-100,100))\n\n$minimum\n[1] -3.552714e-15\n\n$objective\n[1] -3\n\n\n\n\n\nfrom scipy.optimize import minimize_scalar\nminimize_scalar(lambda x: 2*x**2 - 3, [-100,100])\n\n message: \n          Optimization terminated successfully;\n          The returned value satisfies the termination criteria\n          (using xtol = 1.48e-08 )\n success: True\n     fun: -3.0\n       x: -3.78263270776151e-11\n     nit: 43\n    nfev: 46\n\n\n\n\n\nNotice that since the 2nd derivative is constant, using the newton raphson, only one iteration is enough.\n\nRPython\n\n\n\nx &lt;- -100\nx &lt;- x - 4*x/4\nx\n\n[1] 0\n\n\n\n\n\nx = -100\nx -= 4*x/4\nx\n\n0.0\n\n\n\n\n\nFind the maximum of the following function.\n\\[\n\\begin{array}{rl}\nf(x,y) =2xy+2x-x^2 - 2y^2 &\\quad\\quad 0&lt;x&lt;4\\\\\n&\\quad\\quad0.5&lt;y&lt;2.5\n\\end{array}\n\\]\nSolution:\n\\[\nf'(x,y) = \\begin{pmatrix}2y + 2 - 2x\\\\2x - 4y\\end{pmatrix}\\\\\nH = \\begin{bmatrix}\\frac{\\partial^2 f}{\\partial x^2}&\\frac{\\partial^2 f}{\\partial x\\partial y}\\\\\\frac{\\partial^2 f}{\\partial y\\partial x}&\\frac{\\partial^2f}{\\partial y^2}\\end{bmatrix} = \\begin{bmatrix}-2&2\\\\2&-4\\end{bmatrix}\\\\\nH^{-1} = \\frac{1}{4}\\begin{bmatrix}-4&-2\\\\-2&-2\\end{bmatrix} = -\\frac{1}{2}\\begin{bmatrix}2&1\\\\1&1\\end{bmatrix}\n\\]\n\nRPython\n\n\n\nf &lt;- function(x){\n    2*x[1]*x[2] + 2*x[1] - x[1]^2 - 2*x[2]^2\n}\n\nfprime &lt;- function(x) c(2*x[2]+2-2*x[1], 2*x[1]-4*x[2])\n\nalpha &lt;- -0.5*matrix(c(2,1,1,1),2)\nx &lt;- c(-100,-100)\nx &lt;- x - alpha%*%fprime(x) #matrix multiplication\nx\n\n     [,1]\n[1,]    2\n[2,]    1\n\nf(x)\n\n[1] 2\n\nfprime(x)\n\n[1] 0 0\n\n\n\n\n\nimport numpy as np\n\ndef f(x):\n    return 2*x[0]*x[1] + 2*x[0] - x[0]**2 - 2*x[1]**2\n  \ndef fprime(x):\n  return np.r_[2*x[1] + 2 - 2*x[0], 2*x[0]-4*x[1]]\n  \nalpha = -0.5 * np.array([[2,1],[1,1]])\nx = np.r_[-100.0,-100]\n\nx -= alpha @ fprime(x) #matrix multiplication\nx\n\narray([2., 1.])\n\nf(x)\n\n2.0\n\nfprime(x)\n\narray([0., 0.])\n\n\n\n\n\nNotice how we only did one evaluation and we obtained the results. How is this possible? That is because the second derivative is free of the parameters, thus we directly converge to the solution. Of course in your implementation, you should make use of loops.\nIn the example above, the minimum occurs at the point \\((2,1)\\) with the minimum value of \\(2\\)\n\nRPython\n\n\nWe could easily use the optim function in R to do the same: Note that the function does minimization by default. To do maximization, we negate the function.\n\noptim(c(-100,-100), \\(x) -f(x))\n\n$par\n[1] 2.0028621 0.9999563\n\n$value\n[1] -1.999992\n\n$counts\nfunction gradient \n      69       NA \n\n$convergence\n[1] 0\n\n$message\nNULL\n\n\nNote that we could also use used fnscale = -1 to indicate that we are doing maximization rather than minimization\n\noptim(c(-100,-100), f, control = list(fnscale = -1))\n\n$par\n[1] 2.0028621 0.9999563\n\n$value\n[1] 1.999992\n\n$counts\nfunction gradient \n      69       NA \n\n$convergence\n[1] 0\n\n$message\nNULL\n\n\n\n\nWe could easily use the minimize function in python to do the same: Note that the function does minimization by default. To do maximization, we negate the function.\n\nfrom scipy.optimize import minimize\nminimize(lambda x: -f(x), (-100,-100))\n\n  message: Optimization terminated successfully.\n  success: True\n   status: 0\n      fun: -1.9999999999948197\n        x: [ 2.000e+00  1.000e+00]\n      nit: 4\n      jac: [ 4.411e-06 -5.543e-06]\n hess_inv: [[ 1.001e+00  4.998e-01]\n            [ 4.998e-01  5.001e-01]]\n     nfev: 21\n     njev: 7\n\n\n\n\n\n\n\nRoot finding as a minimization Problem\nSometimes the problem of root finding can be structured as an optimization problem and then optim or optimize functions could be used.\nFor example given that\n\\[\n\\mu = \\frac{\\alpha}{\\beta} \\text{ and } \\sigma^2 = \\frac{\\alpha}{\\beta^2}\n\\]\nand also that \\(\\mu=5, \\sigma^2=10\\) solve for \\(\\alpha, \\beta\\)\nHow do we go about this?\nWe can first combine two into one. ie \\(\\frac{\\alpha}{\\beta} - \\frac{\\alpha}{\\beta^2}=-5\\) This becomes a root finding problem ie solve for \\((\\alpha, \\beta)\\) such that \\(f(\\alpha,\\beta)=0\\) . Note that we can transform this into a minimization problem. ie we do not want to go below \\(0\\). we are interested in a values of \\((\\alpha,\\beta)\\) such that the minimum \\(f\\) is \\(0\\). Thus we can rewrite \\(f\\) as:\n\n\\(f(\\alpha, \\beta) = \\left|\\frac{\\alpha}{\\beta} - 5\\right|+\\left|\\frac{\\alpha}{\\beta^2} - 10\\right|\\)\n\\(f(\\alpha, \\beta) = \\left(\\frac{\\alpha}{\\beta} - 5\\right)^2 + \\left( \\frac{\\alpha}{\\beta^2} -10\\right)^2\\)\n\nThe two functions in this case would yield the same results since \\(f(\\alpha, \\beta)\\ge0\\)\n\nRPython\n\n\nUsing absolute\n\noptim(c(1,1), \\(par)abs(par[1]/par[2]^2-10) + abs(par[1]/par[2] - 5))\n\n$par\n[1] 2.5 0.5\n\n$value\n[1] 4.070251e-07\n\n$counts\nfunction gradient \n     135       NA \n\n$convergence\n[1] 0\n\n$message\nNULL\n\n\nUsing square\n\noptim(c(1,1), \\(par)(par[1]/par[2]^2-10)^2 + (par[1]/par[2] - 5)^2)\n\n$par\n[1] 2.4994315 0.4999561\n\n$value\n[1] 7.557839e-07\n\n$counts\nfunction gradient \n      73       NA \n\n$convergence\n[1] 0\n\n$message\nNULL\n\n\n\n\nUsing square\n\nminimize(lambda par:(par[0]/par[1]**2-10)**2 + (par[0]/par[1] - 5)**2,(1,1))\n\n  message: Optimization terminated successfully.\n  success: True\n   status: 0\n      fun: 2.562549482808408e-12\n        x: [ 2.500e+00  5.000e-01]\n      nit: 11\n      jac: [ 8.672e-07 -8.404e-06]\n hess_inv: [[ 5.309e-01  5.615e-02]\n            [ 5.615e-02  6.219e-03]]\n     nfev: 63\n     njev: 21\n\n\n\n\n\nFrom the above, we obtain \\(\\alpha = 2.5, \\beta=0.5\\). Notice that although the original problem did not involve minimization, we structured it in a way that allowed us to do minimization.\nRecall the function \\(f(x) = \\log(x) - e^{-x}\\), we could do the same to this in order to use the optim or optimize function:\nOur goal is to get \\(x\\) such that \\(f(x) = 0\\). We could restructure our function such that we square or take absolute \\(\\mathcal{L} = \\left(\\log(x) - e^{-x}\\right)^2\\)\n\nRPython\n\n\n\noptimize(\\(x)(log(x)-exp(-x))^2, lower = 0, upper = 100)\n\n$minimum\n[1] 1.309787\n\n$objective\n[1] 1.676184e-10\n\n\n\n\n\nminimize_scalar(lambda x:(np.log(x)-np.exp(-x))**2,[0,100])\n\n message: \n          Optimization terminated successfully;\n          The returned value satisfies the termination criteria\n          (using xtol = 1.48e-08 )\n success: True\n     fun: 2.6200587055821345e-18\n       x: 1.3097995873705703\n     nit: 20\n    nfev: 23\n\n&lt;string&gt;:1: RuntimeWarning: divide by zero encountered in log\n\n\n\n\n\nFor example if we wanted to solve for \\(x\\) in \\(x^2 e^{3x} +x\\log(x) = 10\\)\n\nRPython\n\n\n\noptimise(\\(x)(x^2*exp(3*x)+x*log(x) - 10)^2, c(0, 100))\n\n$minimum\n[1] 0.866875\n\n$objective\n[1] 1.182101e-08\n\n\n\n\nminimize_scalar(lambda x: (x**2*np.exp(3*x)+x*np.log(x) - 10)**2, (0, 100))\n\nminimize_scalar(lambda x: (x**2*np.exp(3*x)+x*np.log(x) - 10)**2, (0, 100))\n\n message: The algorithm terminated without finding a valid bracket. Consider trying different initial points.\n success: False\n     fun: nan\n       x: nan\n     nit: 0\n    nfev: 3\n\n&lt;string&gt;:1: RuntimeWarning: invalid value encountered in scalar multiply\n&lt;string&gt;:1: RuntimeWarning: overflow encountered in exp\n\n\nTo remove the warning, we redefine our function. We know that log only works in positive values, therefore we bound the function domain by using method = 'bounded'\n\nminimize_scalar(lambda x:(x*2*np.exp(3*x)+x*np.log(x) - 10)**2, bounds = (0, 100), method = 'bounded')\n\n message: Solution found.\n success: True\n  status: 0\n     fun: 1.683454565099316e-11\n       x: 0.6758074059806379\n     nit: 60\n    nfev: 60\n\n\n\n\n\nNote that in the above, we have to specify the interval in which we perceive the solution to lie in. What if we did not know this? we could use optim function in R or mimimize function in Python.\n\nRPython\n\n\n\noptim(1, \\(x)(x^2*exp(3*x)+x*log(x) - 10)^2)\n\nWarning in optim(1, function(x) (x^2 * exp(3 * x) + x * log(x) - 10)^2): one-dimensional optimization by Nelder-Mead is unreliable:\nuse \"Brent\" or optimize() directly\n\n\n$par\n[1] 0.8668945\n\n$value\n[1] 1.381145e-06\n\n$counts\nfunction gradient \n      26       NA \n\n$convergence\n[1] 0\n\n$message\nNULL\n\n\n\n\n\nminimize(lambda x: (x**2*np.exp(3*x)+x*np.log(x) - 10)**2, 1,\nmethod = 'Nelder-Mead')\n\n       message: Optimization terminated successfully.\n       success: True\n        status: 0\n           fun: 1.3811445170301137e-06\n             x: [ 8.669e-01]\n           nit: 12\n          nfev: 24\n final_simplex: (array([[ 8.669e-01],\n                       [ 8.668e-01]]), array([ 1.381e-06,  1.726e-05]))\n\n\n\n\n\nNote that function throws a warning regarding the method used. You can learn about the different methods provided in R/python.\nSimilarly we could have directly solved the problem using uniroot in R or root in Python since this is a root finding problem.\n\nRPython\n\n\n\nuniroot(\\(x)x^2*exp(3*x) + x*log(x)-10, interval = c(1e-4, 100))\n\n$root\n[1] 0.8668723\n\n$f.root\n[1] -3.96713e-05\n\n$iter\n[1] 20\n\n$init.it\n[1] NA\n\n$estim.prec\n[1] 6.747708e-05\n\n\n\n\n\nfrom scipy.optimize import root_scalar\nroot_scalar(lambda x: x**2*np.exp(3*x) + x*np.log(x)-10, bracket = (1e-4, 100))\n\n      converged: True\n           flag: converged\n function_calls: 23\n     iterations: 22\n           root: 0.8668730025669631\n\n\n\n\n\nWhy are we learning about transforming root finding problem as a optimization problem? That is because the methods provided in most languages are for optimization rather than root finding. Note that the uniroot function for example can only find roots for a univariate function. No methods have been provided for multivariate functions. We thus have to be skillful on converting the root finding problems to optimization problems. Mostly just rewrite the equation and square it. On the other hand Python provides the root function which can be used for multivariate problems\nie to find the root of \\(f(x) = c\\) is similar to minimizing \\(g(x) = \\left(f(x) - c\\right)^2\\) . We aim at minimizing the square of the difference between the value \\(c\\) and the value of the function evaluated at \\(x\\). This difference is called the error. ie \\(\\epsilon = c - f(x)\\) . If the error is 0, then the value of \\(x\\) that gives us this 0 error is the same value of \\(x\\) that gives us \\(c\\) when the function is evaluated at it.\nIn case we have a multivariate function, we sum all the squared error terms. ie\n\\[\n\\sum_{i}\\epsilon^2 = \\sum_{i}\\left(c_i - f(x_i)\\right)^2\n\\]\nThis is the formula we used when solving for \\(\\alpha\\) and \\(\\beta\\) above. We note that we had two terms and each term had to be equal to something. ie the first term had to be equal to 5 and the second term had to be equal to 10. So we summed the square of the errors of each and minimized that.\nNote that we could take the absolute value of each error term. But the absolute value is not differentiable everywhere, and neither is is smooth. We therefore will stick to using the squared errors.\nQuiz: What happens when we do not take absolute values/square the difference? Why is that the case?\nLets look at another example:\nSuppose we had 2 points ie \\((1,2),\\quad(2,3)\\) we can write the equation of a line:\n\\[\nm = \\frac{3-2}{2-1} = 1\\implies y = x + 1\n\\]\nCould we find this equation using optimization? The equation of a line is given as \\(y = mx +b\\)\nWe would write the problem as:\n\\[\n\\begin{pmatrix}2\\\\3\\end{pmatrix}= \\begin{pmatrix}1\\\\2\\end{pmatrix}m + \\begin{pmatrix}1\\\\1\\end{pmatrix}b\n\\]\nNow This is a simultaneous equation that you had solved before:\n\nRPython\n\n\n\nfn &lt;- function(p){\n  m &lt;- p[1]\n  b &lt;- p[2]\n  (1*m + 1*b - 2)^2 + (2*m + 1*b - 3)^2\n}\nstart &lt;- c(m = 0, b = 0)\noptim(start, fn, method = 'BFGS')\n\n$par\nm b \n1 1 \n\n$value\n[1] 1.93566e-19\n\n$counts\nfunction gradient \n      14        8 \n\n$convergence\n[1] 0\n\n$message\nNULL\n\n\n\n\n\ndef fn(p):\n  m = p[0]\n  b = p[1]\n  return (1*m + 1*b - 2)**2 + (2*m + 1*b - 3)**2\n\nstart =np.r_[0,0]\nminimize(fn, start,  method = 'BFGS')\n\n  message: Optimization terminated successfully.\n  success: True\n   status: 0\n      fun: 8.100203955737182e-13\n        x: [ 1.000e+00  1.000e+00]\n      nit: 5\n      jac: [ 4.056e-06  2.537e-06]\n hess_inv: [[ 9.996e-01 -1.500e+00]\n            [-1.500e+00  2.500e+00]]\n     nfev: 18\n     njev: 6\n\n\nUsing root function\n\nfrom scipy.optimize import root\nroot(lambda p: [p[0] + p[1] - 2, 2*p[0] + p[1] - 3], [0,0])\n\n message: The solution converged.\n success: True\n  status: 1\n     fun: [-2.220e-16  0.000e+00]\n       x: [ 1.000e+00  1.000e+00]\n    nfev: 5\n    fjac: [[-4.472e-01 -8.944e-01]\n           [ 8.944e-01 -4.472e-01]]\n       r: [-2.236e+00 -1.342e+00  4.472e-01]\n     qtf: [-7.804e-12  9.765e-13]\n\n\n\n\n\nFrom the above, we see that \\(m = 1\\) and \\(b = 1\\) hence our equation is \\(y = 1x + 1\\) which yields the results previously obtained.\nWhat if we have 3 data points, 100 datapoints etc? instead of + we use sum\n\nRPython\n\n\n\nfn2 &lt;- function(p, X, Y){\n  m &lt;- p[1]\n  b &lt;- p[2]\n  sum((X*m + b - Y)^2)\n}\noptim(c(0,0), fn2, X = c(1,2),Y = c(2,3), method = 'BFGS')\n\n$par\n[1] 1 1\n\n$value\n[1] 1.93566e-19\n\n$counts\nfunction gradient \n      14        8 \n\n$convergence\n[1] 0\n\n$message\nNULL\n\n\n\n\n\ndef fn2(p, X, Y):\n  m = p[0]\n  b = p[1]\n  return sum((X*m + b - Y)**2)\n\nminimize(fn2, [0,0], (np.r_[1,2],np.r_[2,3]), method = 'BFGS')\n\n  message: Optimization terminated successfully.\n  success: True\n   status: 0\n      fun: 8.100203955737182e-13\n        x: [ 1.000e+00  1.000e+00]\n      nit: 5\n      jac: [ 4.056e-06  2.537e-06]\n hess_inv: [[ 9.996e-01 -1.500e+00]\n            [-1.500e+00  2.500e+00]]\n     nfev: 18\n     njev: 6\n\n\n\n\n\nNote that we end up with the same results for this dataset. This was a simple dataset and a simple task. Try exercises in this section:\n\n\nExercise:\n\nRPython\n\n\nAnswer Using R\n\nNote that the function pnorm is the inverse of qnorm ie pnorm(qnorm(x))=x. Now use the optimise function to obtain the inverse of dnorm(x)\nUsing the gradient descent algorithm, find the best quadratic equation that best fits the dataset below.\n\nx &lt;- 1:10\ny &lt;- c(-0.2499211,-4.6645685,-2.6280750,-2.0146818,1.5632500,0.2043376,2.9151158,  4.0967775,6.8184074,12.5449975)\n\nUsing optim find a quadratic equation that best describes the dataset given in question 2 above. [2]\nTry out the problem at stackoverflow\nTry out the problem at stackoverflow\nbeta function\n\n\n\nAnswer Using Python\n\nNote that the function scipy.stats.norm().cdf is the inverse of scipy.stats.norm.ppf ie cdf(ppf(x)) = x. Now use the scipy.optimize.minimize_scalar function to obtain the inverse of scipy.stats.norm().pdf(x)\nUsing a gradient descent algorithm, find the best quadratic equation that best fits the dataset below\n\nimport numpy as np\nx = np.arange(10) + 1\ny = np.array([-0.2499211,-4.6645685,-2.6280750,-2.0146818,1.5632500,0.2043376,2.9151158,  4.0967775,6.8184074,12.5449975])\n\nUsing scipy.optimize.minimize find a quadratic equation that best describes the dataset given in question 2 above. [2]\nTry out the problem at stackoverflow\nTry out the problem at stackoverflow\nbeta function\n\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "naive bayes.html",
    "href": "naive bayes.html",
    "title": "Naive Bayes",
    "section": "",
    "text": "Assumes that all features are independent of one another. And each impact the response y differently.\nThe cummulative impact is just a multiplication of each of the individual impacts.\nWe all know the bayes theorem. I will not bore you with the math. Lets look at a simple example:\nConsider a data set with 1500 observations and the following output classes:\n\nCat\nParrot\nTurtle\n\nThe Predictor variables are categorical in nature i.e., they store two values, either True or False:\n\nSwim\nWings\nGreen Color\nSharp Teeth\n\n\\[\n\\begin{array}{|c|c|c|c|c|}\n\\hline \\text { Type } & \\text { Swim } & \\text { Wings } & \\text { Green } & \\text { Sharp teeth } \\\\\n\\hline \\text { Cat } & 450 / 500 & 0 & 0 & 500 / 500 \\\\\n\\hline \\text { Parrot } & 50 / 500 & 500 / 500 & 400 / 500 & 0 \\\\\n\\hline \\text { Turtle } & 500 / 500 & 0 & 100 / 500 & 50 / 500 \\\\\n\\hline\n\\end{array}\n\\]\nFrom the above table, we can summarise that:\n\nThe class of type cats shows that: - Out of \\(500,450(90 \\%)\\) cats can swim - 0 number of cats have wings - 0 number of cats are of Green color - All 500 cats have sharp teeth\nThe class of type Parrot shows that: - \\(50(10 \\%)\\) parrots have a true value for swim - All 500 parrots have wings - Out of \\(500,400(80 \\%)\\) parrots are green in color - No parrots have sharp teeth\nThe class of type Turtle shows: - All 500 turtles can swim - 0 number of turtles have wings - Out of \\(500,100(20 \\%)\\) turtles are green in color - 50 out of \\(500(10 \\%)\\) turtles have sharp teeth\n\nNow, with the available data, let’s classify the following observation into one of the output classes (Cats, Parrot or Turtle) by using the Naive Bayes Classifier. \\[\n\\begin{array}{|c|c|c|c|c|}\n& \\hline\\text { Swim } & \\text { Wings } & \\text { Green } & \\text { Sharp Teeth } \\\\\n\\hline \\text { Observation } & \\text { True } & \\text { False } & \\text { True } & \\text { False }\\\\\\hline\n\\end{array}\n\\]\nThe goal here is to predict whether the animal is a Cat, Parrot or a Turtle based on the defined predictor variables (swim, wings, green, sharp teeth).\nTo solve this, we will use the Naive Bayes approach, Assume we have\n\\[\nP(\\text{variable}_j \\mid X\\in \\text{Class}_k) = P(V_j\\mid k)\\text{ and }P(X\\in \\text{Class}_k) = P(C = k)\n\\]\nWe can compute the probability of belonging to class \\(k\\) given the variables as:\nThen the probability that a new observation \\(X\\) belongs to class \\(k\\) can be computed as:\n\\[\n\\begin{aligned}P(X\\in \\text{Class}_k \\mid \\text{variable}_1\\cdots\\text{ variable}_p )=&\\frac{P(V_1 \\mid C = k)P(V_2\\mid C = k)  \\cdots  P(V_p \\mid C = k)P(C= k)}{P( Multiple Evidences)}\\\\\n\\propto&P(X\\in\\text{Class}_k)\\prod_j^p P(\\text{Variable}_i\\mid X\\in \\text{Class}_k)\n\\end{aligned}\n\\]\nNote that I ignored the denominator as it is a normalizing constant.\nIn the observation, the variables Swim and Green are true and the outcome can be any one of the animals (Cat, Parrot, Turtle). To check if the animal is a cat: \\[\n\\begin{aligned}\nP( Cat \\mid Swim, Green )=&\\frac{P( Swim \\mid Cat ) \\times P (Green \\mid Cat ) \\times P(Cat)}{P( Swim, Green )}\\\\\n=&\\frac{0.9 * 0 * 0.333}{P( Swim, Green)}=0\n\\end{aligned}\n\\]\nTo check if the animal is a Parrot: \\[\n\\begin{aligned}\nP(Parrot| Swim, Green) =& \\frac{P(Swim|Parrot) P(Green|Parrot) P(Parrot)}{P(Swim, Green)}\\\\\n=&\\frac{ 0.1 * 0.80 * 0.333}{P(Swim, Green)}\\\\\n=& \\frac{0.0264}{ P(Swim, Green)}\n\\end{aligned}\n\\]\nTo check if the animal is a Turtle: \\[\n\\begin{aligned}\nP(Turtle| Swim, Green) =&\\frac{ P(Swim|Turtle)  P(Green|Turtle)  P(Turtle)}{ P(Swim, Green)}\\\\\n=&\\frac{ 1 * 0.2 * 0.333}{ P(Swim, Green)}\\\\\n= &\\frac{0.0666}{ P(Swim, Green)}\\\\\n\\end{aligned}\n\\]\nFor all the above calculations the denominator is the same i.e, \\(P(Swim, Green)\\), thus wont impact the solution. The value of P(Turtle| Swim, Green) is greater than P(Parrot| Swim, Green), therefore we can correctly predict the class of the animal as Turtle.\nWhat if the variable is continuous? How do we proceed? We compute the likelihood for being in class \\(k\\)using the normal density and then include the prior. ie:\nTaking\n\\[\n\\begin{array}{}\n\\mathcal{L}(\\text{Variable}_i | X\\in \\text{Class}_k) = \\mathcal{N}(\\nu_i;~\\mu_k, ~\\sigma_k)\n\\end{array}\n\\]\nWe can compute the likelihood of belonging in class \\(k\\) as:\n\\[p(X\\in \\text{Class}_k \\mid \\text{V}_1\\cdots\\text{V}_p )\\propto P(C = k)\\prod_{j=1}^p\\mathcal{N}(\\nu_j ,~\\mu_k, ~\\sigma_k)\\]\nNote that to perform the computation, use the log-likelihood for stability as the likelihood produces numbers which are essentially 0. Then afterwards exponentiate the results before normalizing.\nie\n\\[\n\\ell = \\log P(C=k) + \\sum_{j=1}^p\\log \\mathcal{N}(\\nu_j ,~\\mu_k, ~\\sigma_k)\n\\]\nFor example:\nassume we had the data below\n\n\n\n\\(X_1\\)\n\\(X_2\\)\n\\(y\\)\n\n\n\n\n5.1\n3.5\n1\n\n\n4.9\n3\n1\n\n\n7\n3.2\n2\n\n\n6.4\n3.2\n2\n\n\n6.3\n3.3\n3\n\n\n5.8\n2.7\n3\n\n\n\nWe want to predict the class of some new observations below:\n\n\\(X_1 = 5.9, X_2= 3.2\\)\n\\(X_1 = 5.1, X_2 = 3.5\\)\n\\(X_1 = 5.7, X_2 = 2.8\\)\n\nSolution:\n\nRPython\n\n\n\n# data\nx1 = c(5.1, 4.9, 7, 6.4, 6.3, 5.8)\nx2 = c(3.5, 3, 3.2, 3.2, 3.3, 2.7)\ny &lt;- c(1, 1, 2, 2, 3, 3)\n\n# Prior probabilities\nprior &lt;- c(table(y))\n\n# means per group ie mu_k\nmean_x1 &lt;- tapply(x1, y, mean)\nmean_x2 &lt;- tapply(x2, y, mean)\n\n# sd per group\nsd_x1 &lt;- tapply(x1, y, sd)\nsd_x2 &lt;- tapply(x2, y, sd)\n\n# If any of the sd's are zero, replace with a threshhold:\nsd_x2[sd_x2 &lt; 0.001] &lt;- 0.001\n\n\n# Now lets assume our new data is \nx_new &lt;- c(5.9,3.2)\n# compute the likelihood to belong in class 1 :\n\nclass1 &lt;- exp(log(prior[1]) +\n  sum(log(dnorm(x_new[1], mean_x1[1], sd_x1[1])),\n          log(dnorm(x_new[2], mean_x2[1], sd_x2[1]))))\n\n# compute the likelihood to belong in class 2:\n\nclass2 &lt;- exp(log(prior[2]) +\n  sum(log(dnorm(x_new[1], mean_x1[2], sd_x1[2])),\n          log(dnorm(x_new[2], mean_x2[2], sd_x2[2]))))\n\n# compute the likelihood to belong in class 3:\n\nclass3 &lt;- exp(log(prior[3]) +\n  sum(log(dnorm(x_new[1], mean_x1[3], sd_x1[3])),\n          log(dnorm(x_new[2], mean_x2[3], sd_x2[3]))))\n\n\n#probabilities\np &lt;- c(class1, class2, class3)\np/sum(p) #normalize\n\n           1            2            3 \n7.871103e-11 9.864986e-01 1.350141e-02 \n\n\nFrom the probabilities above, we can tell that the first new observation belongs to class 3 as this has the highest probability. Note that the code is repetitive and redundant. R does vectorization, and it will be good to make use of this feature. Thus the new code will be\n\n# Prepare data:\n\ntrainX &lt;- matrix(c(5.1, 4.9, 7, 6.4, 6.3, 5.8, \n                   3.5, 3, 3.2, 3.2, 3.3,2.7), ncol = 2)\ntrainY &lt;- c(1, 1, 2, 2, 3, 3)\n\ntestX &lt;- matrix(c(5.9,5.1,5.7,3.2,3.5,2.8), ncol = 2)\n  \n# A grouping list to compute the means and sds of the whole dataset\ngroup &lt;-  list(col(trainX), array(trainY, dim(trainX)))\n\n# Compute log of priors as a vector\nprior &lt;- c(log(table(trainY)))\n\n#compute the means and sds\nmeans &lt;- data.frame(tapply(trainX, group, mean))\n\nsds &lt;- data.frame(tapply(trainX, group, sd))\n\n# replace if any sds &lt;0.001 with 0.001\nsds[sds&lt;0.001] &lt;- 0.001\n\n# Compute probabilities for the test cases\np &lt;- mapply(\\(x,y)colSums(dnorm(t(testX), x, y, log = TRUE)), means, sds)\nprop.table(exp(t(t(p) + prior)), 1)\n\n               X1        X2          X3\n[1,] 7.871103e-11 0.9864986 0.013501409\n[2,] 9.926309e-01 0.0000000 0.007369148\n[3,] 1.164902e-05 0.0000000 0.999988351\n\n\n\n\n\n\n\n\nFrom the probabilities above, we could determine the class to which each observation belongs to. Note that we We could turn this into a function. A task I will let you do.\n\nExercise:\nImplement a Naive Bayes function that will predict the class of new observations from a training set that contains both numeric and categorical predictors.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "naive_bayes.html",
    "href": "naive_bayes.html",
    "title": "Naive Bayes",
    "section": "",
    "text": "Assumes that all features are independent of one another. And each impact the response y differently.\nThe cummulative impact is just a multiplication of each of the individual impacts.\nLets look at a simple example:\n\nCategorical Variables\nConsider a data set with 1500 observations and the following output classes:\n\nCat\nParrot\nTurtle\n\nThe Predictor variables are categorical in nature i.e., they store two values, either True or False:\n\nSwim\nWings\nGreen Color\nSharp Teeth\n\n\\[\n\\begin{array}{|c|c|c|c|c|}\n\\hline \\text { Type } & \\text { Swim } & \\text { Wings } & \\text { Green } & \\text { Sharp teeth } \\\\\n\\hline \\text { Cat } & 450 / 500 & 0 & 0 & 500 / 500 \\\\\n\\hline \\text { Parrot } & 50 / 500 & 500 / 500 & 400 / 500 & 0 \\\\\n\\hline \\text { Turtle } & 500 / 500 & 0 & 100 / 500 & 50 / 500 \\\\\n\\hline\n\\end{array}\n\\]\nFrom the above table, we can summarise that:\n\nThere are 1500 animals.\nThere are 4 predictors ie X. ie can swim, has wings, is green, has sharp teeth.\nThe response variable, Y, ie Type has three classes.\nThe class of type cats shows that: - Out of \\(500,450(90 \\%)\\) cats can swim - 0 number of cats have wings - 0 number of cats are of Green color - All 500 cats have sharp teeth.\nThe class of type Parrot shows that: - \\(50(10 \\%)\\) parrots have a true value for swim - All 500 parrots have wings - Out of \\(500,400(80 \\%)\\) parrots are green in color - No parrots have sharp teeth\nThe class of type Turtle shows: - All 500 turtles can swim - 0 number of turtles have wings - Out of \\(500,100(20 \\%)\\) turtles are green in color - 50 out of \\(500(10 \\%)\\) turtles have sharp teeth\n\nNow, with the available data, let’s classify the following observation into one of the output classes (Cats, Parrot or Turtle) by using the Naive Bayes Classifier.\n\\[\n\\begin{array}{|c|c|c|c|c|}\n& \\hline\\text { Swim } & \\text { Wings } & \\text { Green } & \\text { Sharp Teeth } \\\\\n\\hline \\text { Observation } & \\text { True } & \\text { False } & \\text { True } & \\text { False }\\\\\\hline\n\\end{array}\n\\]\nThe goal here is to predict whether the new observed type is a Cat, Parrot or a Turtle based on the defined predictor variables (swim, wings, green, sharp teeth).\nWhat type of animal is this? ie it can swim and its green but and it does not have wings and sharp teeth. Looking at our initial table of conditional probabilities we see that only the Turtle fits this description. Can we depict this in mathematical notation?\nTo solve this, we will use some notations. Let\n\\[\n\\begin{aligned}\nX_{ij} =& \\text{Variable } j \\text{ for observation } i\\\\\nx_{ij} =& \\text{Value observation }i \\text{ takes for variable } j \\text{ in this case 1 or 0}\\\\\nC = &\\text{the response variable}\\\\\nk =&\\text{Value of the response variable, ie Cat, Parrot, Turtle}\n\\end{aligned}\n\\]\n\\[\nP(\\text{X}_{ij} = x_{ij} \\mid \\text{Class} = k) = P(X_{ij}\\mid C=k)\\text{ and }P( \\text{Class}=k) = P(C = k)\n\\]\nThen we can compute the probability of the true class being \\(k\\) given the new observation as:\n\\[\n\\begin{aligned}P(C = k\\mid X_{i1}= x_{i1},&X_{i2}=x_{i2},\\cdots,X_{ip}= x_{ip} )\\\\\n&=\\frac{P(X_{i1}=x_{i1} \\mid C = k)P(X_{i2}=x_{i1}\\mid C = k) \\cdots  P(X_{ip} =x_{ip}\\mid C = k)P(C= k)}{\\text{Normalizing Constant}}\\\\\n\\\\\n&=\\frac{P(C = k)\\prod_j^p P(X_{ij} = x_{ij}\\mid C = k)}{\\sum_{k\\in K}P(C = k)\\prod_j^p P(X_{ij} = x_{ij}\\mid C = k)}\n\\end{aligned}\n\\] To understand this formula, lets continue with the example:\nUsing \\(S = Swim\\), \\(W = Wings\\), \\(G = Green\\) and \\(T = Sharp ~Teeth\\), we can determine the probabilities of the classes given the new observation as follows:\nPrior Probabilities: \\[\nP(C = Cat) = 500/1500 = 1/3\\quad P(C=Parrot) = 1/3\\quad P(C=Turtle) = 1/3\n\\]\nPosterior Probabilities:\ncat:\n\\[\n\\begin{aligned}\nP( C = Cat \\mid \\text{S=1,W=0,G=1,T=0})=&\\frac{P( \\text{S=1} \\mid Cat ) P(\\text{W=0}\\mid Cat)P(\\text{G=1} \\mid Cat ) P(\\text{T=0}\\mid Cat)P(Cat)}{P( \\text{S=1,W=0,G=1,T=0} )}\\\\\n=&\\frac{(0.9)(1)(0) (0)(1/3)}{\\text{Normalizing Constant}}\\\\\n=&0\n\\end{aligned}\n\\]\nParrot:\n\\[\n\\begin{aligned}\nP( C = Parrot \\mid \\text{S=1,W=0,G=1,T=0})=&\\frac{P( \\text{S=1} \\mid Parrot ) P(\\text{W=0}\\mid Parrot)P(\\text{G=1} \\mid Parrot ) P(\\text{T=0}\\mid Parrot)P(Parrot)}{P( \\text{S=1,W=0,G=1,T=0} )}\\\\\n=&\\frac{(0.1)(0) (0.80)(1)(1/3)}{\\text{Normalizing Constant}}\\\\\n=&0\n\\end{aligned}\n\\]\nTurtle:\n\\[\n\\begin{aligned}\nP( C= Turtle \\mid \\text{S=1,W=0,G=1,T=0})=&\\frac{P( \\text{S=1} \\mid Turtle ) P(\\text{W=0}\\mid Turtle)P(\\text{G=1} \\mid Turtle ) P(\\text{T=0}\\mid Turtle)P(Turtle)}{P( \\text{S=1,W=0,G=1,T=0} )}\\\\\n=&\\frac{(1)(1)(0.2)(0.9)(1/3)}{\\text{Normalizing Constant}}\\\\\n=& \\frac{0.06}{\\text{Normalizing Constant}}\\\\\n\\end{aligned}\n\\]\nWhere \\(\\text{Normalizing Constant} = 0 + 0 + 0.06 = 0.06\\). Thus we get the posterior probabilities of the new observation belonging to cat, parrot and turtle as 0, 0, 1 respectively. This shows that we are quite sure its a turtle. What is we had different values? We pick the class with the largest posterior probability.\nNote that with computer computation, we use logarithms. This is because multiplication of really small numbers diminish quickly to zero and therefore difficulty in exact binary representation. But another issue arises when using logarithms. There is no log of 0. To get around this, we introduce a threshold where by anything below this threshold is replaced by the threshold. eg in the example above, using a threshold of \\(0.0001\\) = \\(10^{-4}\\) = \\(1e-4\\) , we can compute the posteriors as:\n\\[\n\\begin{aligned}\nCat:&\\quad\\exp^{\\log(0.9) + \\log(1e-4) + \\log(1e-4) +\\log(1)+\\log(1/3)}=3e-9\\\\\nParrot:&\\quad\\exp^{\\log(0.1)+\\log(1e-4)+\\log (0.80)+\\log(1)+\\log(1/3)} =  2.666667e-06\\\\\nTurtle:&\\quad\\exp^{\\log(1)+\\log(1)+\\log (0.2)+\\log(0.9)+\\log(1/3)} =  0.06\\\\\n\\text{Normalizing Constant }:&\\quad3e-9 + 2.666667e-06+0.06 = 0.06000267\\\\\n\\text{the resulting posterior}&\\text{ probabilities are }:\n[4.999778e-08, 4.444247e-05, 0.9999555]\n\\end{aligned}\n\\]\nWe can still predict that the class for the new observation is turtle.\n\nTASK.\nCompute the above using R/Python. Note that if probability is zero, you could use a threshold in order to be able to do logarithm.\nNote that, the data is sometimes not neatly presented as given above, but rather as individual observations. We then have to aggregate it to get the conditional probabilities.\n\nRPython\n\n\n\n\n\n\n\n\n\n\n\n\nContinuous Variables\nWhat if the variable is continuous? How do we proceed? We compute the likelihood for being in class \\(k\\)using the normal density and then include the prior. ie:\nTaking\n\\[\n\\begin{array}{}\n\\mathcal{L}(\\text{Variable}_i | X\\in \\text{Class}_k) = \\mathcal{N}(\\nu_i;~\\mu_k, ~\\sigma_k)\n\\end{array}\n\\]\nWe can compute the likelihood of belonging in class \\(k\\) as:\n\\[p(X\\in \\text{Class}_k \\mid \\text{V}_1\\cdots\\text{V}_p )\\propto P(C = k)\\prod_{j=1}^p\\mathcal{N}(\\nu_j ,~\\mu_k, ~\\sigma_k)\\]\nNote that to perform the computation, use the log-likelihood for stability as the likelihood produces numbers which are essentially 0. Then afterwards exponentiate the results before normalizing.\nie\n\\[\n\\ell = \\log P(C=k) + \\sum_{j=1}^p\\log \\mathcal{N}(\\nu_j ,~\\mu_k, ~\\sigma_k)\n\\]\nFor example:\nassume we had the data\n\\[\n\\begin{matrix}\\begin{array}{}\nX_1 &X_2 & y\\\\\n\\hline\n5.1   & 3.5   & 1\\\\\n4.9   & 3     & 1\\\\\n7     & 3.2   & 2\\\\\n6.4   & 3.2   & 2\\\\\n6.3   & 3.3   & 3\\\\\n5.8   & 2.7   & 3\n\\end{array}&\n\\begin{array}{}\\text{And we want to predict the} \\\\\n\\text{class of some new observations:}\\end{array}\n\\begin{array}{}\nX_1&X_2\\\\\n\\hline\n5.9& 3.2\\\\\n5.1& 3.5\\\\\n5.7& 2.8\\\\\n\\end{array}\n\\end{matrix}\n\\]\nHow can we go about this?\nSolution:\n\nRPython\n\n\n\n\n\n\n\n\n\nFrom the probabilities above, we can tell that the first new observation belongs to class 2 as this has the highest probability. Note that the code is repetitive and redundant. R/numpy does vectorization, and it will be good to make use of this feature. Thus the new code will be\n\nRPython\n\n\n\nThe predicted classes can easily be obtained as\n\n# Try running this code in the chunk above\nmax.col(probs)\n\n\n\n\n\n# Try running this code in the chunk above\nprobs.argmax(1)\n\n\n\n\nThe implementation above involves numeric variables. Naive Bayes does assume that the continuous variables are independent of one another and are normally distributed. For categorical variables, the implementation is as shown in the first example.\nThere are packages written that do the naive bayes classification.\n\nRPython\n\n\nin R we can use the e1071 library to perform Naive Bayes. For this, we can pass both numeric and categorical predictors. Therefore its preferred to pass in a dataframe. The column names of the test must match the column names of train. or both of them should not have column names.\n\nmodel &lt;- e1071::naiveBayes(trainX, trainY)\npredict(model, testX)\n\n# predict probabilities\npredict(model, testX, type = 'raw')\n\n\n\n\nIn python we can use GaussianNB class from naive_bayes package in sklearn module. There is also CategoricalNB BinomialNB MultinomialNB classes. Note that there is no module to work with mixed data. You could easily implement this.\n\nfrom sklearn.naive_bayes import GaussianNB\nmodel = GaussianNB().fit(trainX, trainY)\nmodel.predict(testX)\n\n# Predict probabilities\nmodel.predict_proba(testX)\n\n\n\n\n\nThese probability results do not exactly match the ones in R. this is because of the usage of a variance smoothing parameter that adds an epsilon to every element of the variance matrix. Also numpy uses 0 ddof (delta degrees of freedom) by default, thus dividing by N when computing the variance instead of dividing by N-1. The subtle differences leads to the differences in the results :::\n\n\nExercise:\nImplement a Naive Bayes function that will predict the class of new observations from a training set that contains both numeric and categorical predictors. The training set must be a dataframe. Use the Horseshoe crab Data provided below to test your function taking y as the response variables. Note that color spine and y are categorical variables.\n\nRPython\n\n\n\n\n\n\n\n\n\nYour function should match the following results for the head\n\n## Probabilities\npredict(e1071::naiveBayes(y~.,train), test, type = 'raw')|&gt;head()\n\n                0            1\n[1,] 0.0282940500 0.9717059500\n[2,] 0.9999067092 0.0000932908\n[3,] 0.0001659840 0.9998340160\n[4,] 0.1459058444 0.8540941556\n[5,] 0.0003250912 0.9996749088\n[6,] 0.9998464750 0.0001535250\n\n# Accuracy\nMetrics::accuracy(test$y, predict(e1071::naiveBayes(y~.,train), test))\n\n[1] 1\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "optimization.html",
    "href": "optimization.html",
    "title": "Optimization",
    "section": "",
    "text": "Previously we looked at root finding methods. Suppose instead of obtaining the root, we want to obtain the optimal point of the function. ie either maximum or minimum. We know that at the optimum, the gradient is 0. Thus for optimization, we opt to obtain the root of the gradient ie \\(f'(x) = 0\\).\nTo do this, we use the methods described above but we use \\(f'(x)\\) as our function of interest.\nTherefore the updating methodology becomes:\n\\[\nx_{n+1} = x_n \\pm \\alpha f'(x)\n\\]\nThis is called the GRADIENT/STEEPEST DESCENT(ASCENT) ALGORITHM.\nie if we use addition the we talk of ascent and if we use subtraction we talk of descent.\nThe choice of \\(\\alpha\\) corresponds to the different methods available.\n\nNewton Raphson:\nFor this method \\(\\alpha = \\frac{1}{f''(x)}\\) . If \\(f\\) is multivariate, then we have \\(\\alpha = H^{-1}(x)\\) where \\(H(x) = \\nabla^2f(x) = \\frac{\\partial^2 f(x)}{\\partial x \\partial x^\\top}\\) ie 2nd order derivative of the function evaluated at \\(x\\)\nExamples:\n\nFind the minimum of \\(f(x) = 2x^2 - 3\\)\nFirst we can plot to see how the function looks like\n\nRPython\n\n\n\nplot(x &lt;- seq(-5,5,length = 50), 2 * x**2 - 3, ty='l')\n\n\n\n\n\n\n\nimport matplotlib.pyplot as plt, numpy as np\nplt.clf()\nplt.plot(x := np.linspace(-5,5), 2 * x**2 - 3)\nplt.show()\n\n\n\n\n\n\n\nWe can see that the optimum/minimum occurs at \\(x=0\\). Now we can solve this analytically:\n\n\\[\nf'(x) = 4x \\therefore f'(x) = 0 \\implies x=0\\\\\nf''(0) = 4 &gt; 0 \\implies x=0 \\text{ is a minimum}\n\\]\n\nRPython\n\n\n\noptimize(\\(x)2*x**2 -3, c(-100,100))\n\n$minimum\n[1] -3.552714e-15\n\n$objective\n[1] -3\n\n\n\n\n\nfrom scipy.optimize import minimize_scalar\nminimize_scalar(lambda x: 2*x**2 - 3, [-100,100])\n\n message: \n          Optimization terminated successfully;\n          The returned value satisfies the termination criteria\n          (using xtol = 1.48e-08 )\n success: True\n     fun: -3.0\n       x: -3.78263270776151e-11\n     nit: 43\n    nfev: 46\n\n\n\n\n\nNotice that since the 2nd derivative is constant, using the newton raphson, only one iteration is enough.\n\nRPython\n\n\n\nx &lt;- -100\nx &lt;- x - 4*x/4\nx\n\n[1] 0\n\n\n\n\n\nx = -100\nx -= 4*x/4\nx\n\n0.0\n\n\n\n\n\nFind the maximum of the following function.\n\\[\n\\begin{array}{rl}\nf(x,y) =2xy+2x-x^2 - 2y^2 &\\quad\\quad 0&lt;x&lt;4\\\\\n&\\quad\\quad0.5&lt;y&lt;2.5\n\\end{array}\n\\]\nSolution:\n\\[\nf'(x,y) = \\begin{pmatrix}2y + 2 - 2x\\\\2x - 4y\\end{pmatrix}\\\\\nH = \\begin{bmatrix}\\frac{\\partial^2 f}{\\partial x^2}&\\frac{\\partial^2 f}{\\partial x\\partial y}\\\\\\frac{\\partial^2 f}{\\partial y\\partial x}&\\frac{\\partial^2f}{\\partial y^2}\\end{bmatrix} = \\begin{bmatrix}-2&2\\\\2&-4\\end{bmatrix}\\\\\nH^{-1} = \\frac{1}{4}\\begin{bmatrix}-4&-2\\\\-2&-2\\end{bmatrix} = -\\frac{1}{2}\\begin{bmatrix}2&1\\\\1&1\\end{bmatrix}\n\\]\n\nRPython\n\n\n\nf &lt;- function(x){\n    2*x[1]*x[2] + 2*x[1] - x[1]^2 - 2*x[2]^2\n}\n\nfprime &lt;- function(x) c(2*x[2]+2-2*x[1], 2*x[1]-4*x[2])\n\nalpha &lt;- -0.5*matrix(c(2,1,1,1),2)\nx &lt;- c(-100,-100)\nx &lt;- x - alpha%*%fprime(x) #matrix multiplication\nx\n\n     [,1]\n[1,]    2\n[2,]    1\n\nf(x)\n\n[1] 2\n\nfprime(x)\n\n[1] 0 0\n\n\n\n\n\nimport numpy as np\n\ndef f(x):\n    return 2*x[0]*x[1] + 2*x[0] - x[0]**2 - 2*x[1]**2\n  \ndef fprime(x):\n  return np.r_[2*x[1] + 2 - 2*x[0], 2*x[0]-4*x[1]]\n  \nalpha = -0.5 * np.array([[2,1],[1,1]])\nx = np.r_[-100.0,-100]\n\nx -= alpha @ fprime(x) #matrix multiplication\nx\n\narray([2., 1.])\n\nf(x)\n\n2.0\n\nfprime(x)\n\narray([0., 0.])\n\n\n\n\n\nNotice how we only did one evaluation and we obtained the results. How is this possible? That is because the second derivative is free of the parameters, thus we directly converge to the solution. Of course in your implementation, you should make use of loops.\nIn the example above, the minimum occurs at the point \\((2,1)\\) with the minimum value of \\(2\\)\n\nRPython\n\n\nWe could easily use the optim function in R to do the same: Note that the function does minimization by default. To do maximization, we negate the function.\n\noptim(c(-100,-100), \\(x) -f(x))\n\n$par\n[1] 2.0028621 0.9999563\n\n$value\n[1] -1.999992\n\n$counts\nfunction gradient \n      69       NA \n\n$convergence\n[1] 0\n\n$message\nNULL\n\n\nNote that we could also use used fnscale = -1 to indicate that we are doing maximization rather than minimization\n\noptim(c(-100,-100), f, control = list(fnscale = -1))\n\n$par\n[1] 2.0028621 0.9999563\n\n$value\n[1] 1.999992\n\n$counts\nfunction gradient \n      69       NA \n\n$convergence\n[1] 0\n\n$message\nNULL\n\n\n\n\nWe could easily use the minimize function in python to do the same: Note that the function does minimization by default. To do maximization, we negate the function.\n\nfrom scipy.optimize import minimize\nminimize(lambda x: -f(x), (-100,-100))\n\n  message: Optimization terminated successfully.\n  success: True\n   status: 0\n      fun: -1.9999999999948197\n        x: [ 2.000e+00  1.000e+00]\n      nit: 4\n      jac: [ 4.411e-06 -5.543e-06]\n hess_inv: [[ 1.001e+00  4.998e-01]\n            [ 4.998e-01  5.001e-01]]\n     nfev: 21\n     njev: 7\n\n\n\n\n\nSometimes the problem of root finding can be structured as an optimization problem and then optim or optimize functions could be used.\nFor example given that\n\\[\n\\mu = \\frac{\\alpha}{\\beta} \\text{ and } \\sigma^2 = \\frac{\\alpha}{\\beta^2}\n\\]\nand also that \\(\\mu=5, \\sigma^2=10\\) solve for \\(\\alpha, \\beta\\)\nHow do we go about this?\nWe can first combine two into one. ie \\(\\frac{\\alpha}{\\beta} - \\frac{\\alpha}{\\beta^2}=-5\\) This becomes a root finding problem ie solve for \\((\\alpha, \\beta)\\) such that \\(f(\\alpha,\\beta)=0\\) . Note that we can transform this into a minimization problem. ie we do not want to go below \\(0\\). we are interested in a values of \\((\\alpha,\\beta)\\) such that the minimum \\(f\\) is \\(0\\). Thus we can rewrite \\(f\\) as:\n\n\\(f(\\alpha, \\beta) = \\left|\\frac{\\alpha}{\\beta} - 5\\right|+\\left|\\frac{\\alpha}{\\beta^2} - 10\\right|\\)\n\\(f(\\alpha, \\beta) = \\left(\\frac{\\alpha}{\\beta} - 5\\right)^2 + \\left( \\frac{\\alpha}{\\beta^2} -10\\right)^2\\)\n\nThe two functions in this case would yield the same results since \\(f(\\alpha, \\beta)\\ge0\\)\n\nRPython\n\n\nUsing absolute\n\noptim(c(1,1), \\(par)abs(par[1]/par[2]^2-10) + abs(par[1]/par[2] - 5))\n\n$par\n[1] 2.5 0.5\n\n$value\n[1] 4.070251e-07\n\n$counts\nfunction gradient \n     135       NA \n\n$convergence\n[1] 0\n\n$message\nNULL\n\n\nUsing square\n\noptim(c(1,1), \\(par)(par[1]/par[2]^2-10)^2 + (par[1]/par[2] - 5)^2)\n\n$par\n[1] 2.4994315 0.4999561\n\n$value\n[1] 7.557839e-07\n\n$counts\nfunction gradient \n      73       NA \n\n$convergence\n[1] 0\n\n$message\nNULL\n\n\n\n\nUsing square\n\nfrom scipy.optimize import minimize\nminimize(lambda par:(par[0]/par[1]**2-10)**2 + (par[0]/par[1] - 5)**2,(1,1))\n\n  message: Optimization terminated successfully.\n  success: True\n   status: 0\n      fun: 2.562549482808408e-12\n        x: [ 2.500e+00  5.000e-01]\n      nit: 11\n      jac: [ 8.672e-07 -8.404e-06]\n hess_inv: [[ 5.309e-01  5.615e-02]\n            [ 5.615e-02  6.219e-03]]\n     nfev: 63\n     njev: 21\n\n\n\n\n\nFrom the above, we obtain \\(\\alpha = 2.5, \\beta=0.5\\). Notice that although the original problem did not involve minimization, we structured it in a way that allowed us to do minimization.\nRecall the function \\(f(x) = \\log(x) - e^{-x}\\), we could do the same to this in order to use the optim or optimize function:\nOur goal is to get \\(x\\) such that \\(f(x) = 0\\). We could restructure our function such that we square or take absolute \\(\\mathcal{L} = \\left(\\log(x) - e^{-x}\\right)^2\\)\n\nRPython\n\n\n\noptimize(\\(x)(log(x)-exp(-x))^2, lower = 0, upper = 100)\n\n$minimum\n[1] 1.309787\n\n$objective\n[1] 1.676184e-10\n\n\n\n\n\nfrom scipy.optimize import minimize_scalar\nimport numpy as np\n\nminimize_scalar(lambda x:(np.log(x)-np.exp(-x))**2,[0,100])\n\n message: \n          Optimization terminated successfully;\n          The returned value satisfies the termination criteria\n          (using xtol = 1.48e-08 )\n success: True\n     fun: 2.6200587055821345e-18\n       x: 1.3097995873705703\n     nit: 20\n    nfev: 23\n\n&lt;string&gt;:2: RuntimeWarning: divide by zero encountered in log\n\n\n\n\n\nFor example if we wanted to solve for \\(x\\) in \\(x^2 e^{3x} +x\\log(x) = 10\\)\n\nRPython\n\n\n\noptimise(\\(x)(x^2*exp(3*x)+x*log(x) - 10)^2, c(0, 100))\n\n$minimum\n[1] 0.866875\n\n$objective\n[1] 1.182101e-08\n\n\n\n\nminimize_scalar(lambda x: (x**2*np.exp(3*x)+x*np.log(x) - 10)**2, (0, 100))\n\nfrom scipy.optimize import minimize_scalar\nimport numpy as np\n\nminimize_scalar(lambda x: (x**2*np.exp(3*x)+x*np.log(x) - 10)**2, (0, 100))\n\n message: The algorithm terminated without finding a valid bracket. Consider trying different initial points.\n success: False\n     fun: nan\n       x: nan\n     nit: 0\n    nfev: 3\n\n&lt;string&gt;:2: RuntimeWarning: invalid value encountered in scalar multiply\n&lt;string&gt;:2: RuntimeWarning: overflow encountered in exp\n\n\nTo remove the warning, we redefine our function. We know that log only works in positive values, therefore:\n\ndef f(x):\n  if x&lt;=0:\n    return 1e10 # A very big number\n  else:\n    return (x**2*np.exp(3*x)+x*np.log(x) - 10)**2\n  \nminimize_scalar(f , (1e-20, 100))\n\n message: \n          Optimization terminated successfully;\n          The returned value satisfies the termination criteria\n          (using xtol = 1.48e-08 )\n success: True\n     fun: 9.45467744810933e-15\n       x: 0.866873000785157\n     nit: 23\n    nfev: 26\n\n\n\n\n\nNote that in the above, we have to specify the interval in which we perceive the solution to lie in. What if we did not know this? we could use optim function in R or mimimize function in Python.\n\noptim(1, \\(x)(x^2*exp(3*x)+x*log(x) - 10)^2)\n\nWarning in optim(1, function(x) (x^2 * exp(3 * x) + x * log(x) - 10)^2): one-dimensional optimization by Nelder-Mead is unreliable:\nuse \"Brent\" or optimize() directly\n\n\n$par\n[1] 0.8668945\n\n$value\n[1] 1.381145e-06\n\n$counts\nfunction gradient \n      26       NA \n\n$convergence\n[1] 0\n\n$message\nNULL\n\n\nNote that function throws a warning regarding the method used. You can learn about the different methods provided in R/python.\nSimilarly we could have directly solved the problem using uniroot in R or root in Python since this is a root finding problem.\n\nRPython\n\n\n\nuniroot(\\(x)x^2*exp(3*x) + x*log(x)-10, interval = c(1e-4, 100))\n\n$root\n[1] 0.8668723\n\n$f.root\n[1] -3.96713e-05\n\n$iter\n[1] 20\n\n$init.it\n[1] NA\n\n$estim.prec\n[1] 6.747708e-05\n\n\n\n\n\nfrom scipy.optimize import root_scalar\nroot_scalar(lambda x: x**2*np.exp(3*x) + x*np.log(x)-10, bracket = (1e-4, 100))\n\n      converged: True\n           flag: converged\n function_calls: 23\n     iterations: 22\n           root: 0.8668730025669631\n\n\n\n\n\nWhy are we learning about transforming root finding problem as a optimization problem? That is because the methods provided in most languages are for optimization rather than root finding. Note that the uniroot function for example can only find roots for a univariate function. No methods have been provided for multivariate functions. We thus have to be skillful on converting the root finding problems to optimization problems. Mostly just rewrite the equation and square it. On the other hand Python provides the root function which can be used for multivariate problems\nie to find the root of \\(f(x) = c\\) is similar to minimizing \\(g(x) = \\left(f(x) - c\\right)^2\\) . We aim at minimizing the square of the difference between the value \\(c\\) and the value of the function evaluated at \\(x\\). This difference is called the error. ie \\(\\epsilon = c - f(x)\\) . If the error is 0, then the value of \\(x\\) that gives us this 0 error is the same value of \\(x\\) that gives us \\(c\\) when the function is evaluated at it.\nIn case we have a multivariate function, we sum all the squared error terms. ie\n\\[\n\\sum_{i}\\epsilon^2 = \\sum_{i}\\left(c_i - f(x_i)\\right)^2\n\\]\nThis is the formula we used when solving for \\(\\alpha\\) and \\(\\beta\\) above. We note that we had two terms and each term had to be equal to something. ie the first term had to be equal to 5 and the second term had to be equal to 10. So we summed the square of the errors of each and minimized that.\nNote that we could take the absolute value of each error term. But the absolute value is not differentiable everywhere, and neither is is smooth. We therefore will stick to using the squared errors.\nQuiz: What happens when we do not take absolute values/square the difference? Why is that the case?\nLets look at another example:\nSuppose we had 2 points ie \\((1,2),\\quad(2,3)\\) we can write the equation of a line:\n\\[\nm = \\frac{3-2}{2-1} = 1\\implies y = x + 1\n\\]\nCould we find this equation using optimization? The equation of a line is given as \\(y = mx +b\\)\nWe would write the problem as:\n\\[\n\\begin{pmatrix}2\\\\3\\end{pmatrix}= \\begin{pmatrix}1\\\\2\\end{pmatrix}m + \\begin{pmatrix}1\\\\1\\end{pmatrix}b\n\\]\nNow This is a simultaneous equation that you had solved before:\n\nRPython\n\n\n\nfn &lt;- function(p){\n  m &lt;- p[1]\n  b &lt;- p[2]\n  (1*m + 1*b - 2)^2 + (2*m + 1*b - 3)^2\n}\nstart &lt;- c(m = 0, b = 0)\noptim(start, fn, method = 'BFGS')\n\n$par\nm b \n1 1 \n\n$value\n[1] 1.93566e-19\n\n$counts\nfunction gradient \n      14        8 \n\n$convergence\n[1] 0\n\n$message\nNULL\n\n\n\n\n\nfrom scipy.optimize import minimize\ndef fn(p):\n  m = p[0]\n  b = p[1]\n  return (1*m + 1*b - 2)**2 + (2*m + 1*b - 3)**2\n\nstart =np.r_[0,0]\nminimize(fn, start,  method = 'BFGS')\n\n  message: Optimization terminated successfully.\n  success: True\n   status: 0\n      fun: 8.100203955737182e-13\n        x: [ 1.000e+00  1.000e+00]\n      nit: 5\n      jac: [ 4.056e-06  2.537e-06]\n hess_inv: [[ 9.996e-01 -1.500e+00]\n            [-1.500e+00  2.500e+00]]\n     nfev: 18\n     njev: 6\n\n\nUsing root function\n\nfrom scipy.optimize import root\nroot(lambda p: [p[0] + p[1] - 2, 2*p[0] + p[1] - 3], [0,0])\n\n message: The solution converged.\n success: True\n  status: 1\n     fun: [-2.220e-16  0.000e+00]\n       x: [ 1.000e+00  1.000e+00]\n    nfev: 5\n    fjac: [[-4.472e-01 -8.944e-01]\n           [ 8.944e-01 -4.472e-01]]\n       r: [-2.236e+00 -1.342e+00  4.472e-01]\n     qtf: [-7.804e-12  9.765e-13]\n\n\n\n\n\nFrom the above, we see that \\(m = 1\\) and \\(b = 1\\) hence our equation is \\(y = 1x + 1\\) which yields the results previously obtained.\nWhat if we have 3 data points, 100 datapoints etc? instead of + we use sum\n\nRPython\n\n\n\nfn2 &lt;- function(p, X, Y){\n  m &lt;- p[1]\n  b &lt;- p[2]\n  sum((X*m + b - Y)^2)\n}\noptim(c(0,0), fn2, X = c(1,2),Y = c(2,3), method = 'BFGS')\n\n$par\n[1] 1 1\n\n$value\n[1] 1.93566e-19\n\n$counts\nfunction gradient \n      14        8 \n\n$convergence\n[1] 0\n\n$message\nNULL\n\n\n\n\n\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef fn2(p, X, Y):\n  m = p[0]\n  b = p[1]\n  return sum((X*m + b - Y)**2)\n\nminimize(fn2, [0,0], (np.r_[1,2],np.r_[2,3]), method = 'BFGS')\n\n  message: Optimization terminated successfully.\n  success: True\n   status: 0\n      fun: 8.100203955737182e-13\n        x: [ 1.000e+00  1.000e+00]\n      nit: 5\n      jac: [ 4.056e-06  2.537e-06]\n hess_inv: [[ 9.996e-01 -1.500e+00]\n            [-1.500e+00  2.500e+00]]\n     nfev: 18\n     njev: 6\n\n\n\n\n\nNote that we end up with the same results for this dataset. This was a simple dataset and a simple task. Try exercises in this section:\n\n\nExercise:\n\nRPython\n\n\nAnswer Using R\n\nNote that the function pnorm is the inverse of qnorm ie pnorm(qnorm(x))=x. Now use the optimise function to obtain the inverse of dnorm(x)\nUsing the gradient descent algorithm, find the best quadratic equation that best fits the dataset below.\n\nx &lt;- 1:10\ny &lt;- c(-0.2499211,-4.6645685,-2.6280750,-2.0146818,1.5632500,0.2043376,2.9151158,  4.0967775,6.8184074,12.5449975)\n\nUsing optim find a quadratic equation that best describes the dataset given in question 2 above. [2]\nTry out the problem at stackoverflow\nTry out the problem at stackoverflow\nbeta function\n\n\n\nAnswer Using Python\n\nNote that the function scipy.stats.norm().cdf is the inverse of scipy.stats.norm.ppf ie cdf(ppf(x)) = x. Now use the scipy.optimize.minimize_scalar function to obtain the inverse of scipy.stats.norm().pdf(x)\nUsing a gradient descent algorithm, find the best quadratic equation that best fits the dataset below\n\nimport numpy as np\nx = np.arange(10) + 1\ny = np.array([-0.2499211,-4.6645685,-2.6280750,-2.0146818,1.5632500,0.2043376,2.9151158,  4.0967775,6.8184074,12.5449975])\n\nUsing scipy.optimize.minimize find a quadratic equation that best describes the dataset given in question 2 above. [2]\nTry out the problem at stackoverflow\nTry out the problem at stackoverflow\nbeta function\n\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "pivot_questions.html",
    "href": "pivot_questions.html",
    "title": "Questions",
    "section": "",
    "text": "Given the data Below, create 3 columns ie Sum_15, Sum_16, Sum_17 whereby sum_* is the sum of the values for the corresponding year and agegroup. The result should look like shown below:\n\n\n\nAgeGroup\nSum_15\nSum_16\nSum_17\n\n\n\n\nA\n321\n342\n372\n\n\nB\n391\n339\n345\n\n\nC\n353\n361\n363\n\n\nD\n356\n388\n359\n\n\nE\n351\n390\n386\n\n\n\n\nset.seed(100) # make results reproducible by setting seed\nvars &lt;- c(\"AgeGroup\", paste0(month.abb, \"_\", rep(15:17, each = 12)))\n\n\n(df &lt;- cbind(LETTERS[1:5], matrix(rpois(n = (length(vars) - 1) * 5, 30), nrow = 5)) %&gt;% \n    data.frame() %&gt;%\n    setNames(vars) %&gt;% \n    tibble() %&gt;% \n    mutate(across(-1, as.integer))\n)\n\n# A tibble: 5 × 37\n  AgeGroup Jan_15 Feb_15 Mar_15 Apr_15 May_15 Jun_15 Jul_15 Aug_15 Sep_15 Oct_15\n  &lt;chr&gt;     &lt;int&gt;  &lt;int&gt;  &lt;int&gt;  &lt;int&gt;  &lt;int&gt;  &lt;int&gt;  &lt;int&gt;  &lt;int&gt;  &lt;int&gt;  &lt;int&gt;\n1 A            27     26     33     36     34     25     27     37     37     32\n2 B            21     32     24     31     25     39     32     20     30     32\n3 C            34     28     30     23     25     29     35     26     19     30\n4 D            30     32     29     34     31     29     35     37     28     34\n5 E            31     33     27     31     23     26     29     28     28     26\n# ℹ 26 more variables: Nov_15 &lt;int&gt;, Dec_15 &lt;int&gt;, Jan_16 &lt;int&gt;, Feb_16 &lt;int&gt;,\n#   Mar_16 &lt;int&gt;, Apr_16 &lt;int&gt;, May_16 &lt;int&gt;, Jun_16 &lt;int&gt;, Jul_16 &lt;int&gt;,\n#   Aug_16 &lt;int&gt;, Sep_16 &lt;int&gt;, Oct_16 &lt;int&gt;, Nov_16 &lt;int&gt;, Dec_16 &lt;int&gt;,\n#   Jan_17 &lt;int&gt;, Feb_17 &lt;int&gt;, Mar_17 &lt;int&gt;, Apr_17 &lt;int&gt;, May_17 &lt;int&gt;,\n#   Jun_17 &lt;int&gt;, Jul_17 &lt;int&gt;, Aug_17 &lt;int&gt;, Sep_17 &lt;int&gt;, Oct_17 &lt;int&gt;,\n#   Nov_17 &lt;int&gt;, Dec_17 &lt;int&gt;"
  },
  {
    "objectID": "pivot_questions.html#question-1",
    "href": "pivot_questions.html#question-1",
    "title": "Questions",
    "section": "",
    "text": "Given the data Below, create 3 columns ie Sum_15, Sum_16, Sum_17 whereby sum_* is the sum of the values for the corresponding year and agegroup. The result should look like shown below:\n\n\n\nAgeGroup\nSum_15\nSum_16\nSum_17\n\n\n\n\nA\n321\n342\n372\n\n\nB\n391\n339\n345\n\n\nC\n353\n361\n363\n\n\nD\n356\n388\n359\n\n\nE\n351\n390\n386\n\n\n\n\nset.seed(100) # make results reproducible by setting seed\nvars &lt;- c(\"AgeGroup\", paste0(month.abb, \"_\", rep(15:17, each = 12)))\n\n\n(df &lt;- cbind(LETTERS[1:5], matrix(rpois(n = (length(vars) - 1) * 5, 30), nrow = 5)) %&gt;% \n    data.frame() %&gt;%\n    setNames(vars) %&gt;% \n    tibble() %&gt;% \n    mutate(across(-1, as.integer))\n)\n\n# A tibble: 5 × 37\n  AgeGroup Jan_15 Feb_15 Mar_15 Apr_15 May_15 Jun_15 Jul_15 Aug_15 Sep_15 Oct_15\n  &lt;chr&gt;     &lt;int&gt;  &lt;int&gt;  &lt;int&gt;  &lt;int&gt;  &lt;int&gt;  &lt;int&gt;  &lt;int&gt;  &lt;int&gt;  &lt;int&gt;  &lt;int&gt;\n1 A            27     26     33     36     34     25     27     37     37     32\n2 B            21     32     24     31     25     39     32     20     30     32\n3 C            34     28     30     23     25     29     35     26     19     30\n4 D            30     32     29     34     31     29     35     37     28     34\n5 E            31     33     27     31     23     26     29     28     28     26\n# ℹ 26 more variables: Nov_15 &lt;int&gt;, Dec_15 &lt;int&gt;, Jan_16 &lt;int&gt;, Feb_16 &lt;int&gt;,\n#   Mar_16 &lt;int&gt;, Apr_16 &lt;int&gt;, May_16 &lt;int&gt;, Jun_16 &lt;int&gt;, Jul_16 &lt;int&gt;,\n#   Aug_16 &lt;int&gt;, Sep_16 &lt;int&gt;, Oct_16 &lt;int&gt;, Nov_16 &lt;int&gt;, Dec_16 &lt;int&gt;,\n#   Jan_17 &lt;int&gt;, Feb_17 &lt;int&gt;, Mar_17 &lt;int&gt;, Apr_17 &lt;int&gt;, May_17 &lt;int&gt;,\n#   Jun_17 &lt;int&gt;, Jul_17 &lt;int&gt;, Aug_17 &lt;int&gt;, Sep_17 &lt;int&gt;, Oct_17 &lt;int&gt;,\n#   Nov_17 &lt;int&gt;, Dec_17 &lt;int&gt;"
  },
  {
    "objectID": "pivot_questions.html#question-2",
    "href": "pivot_questions.html#question-2",
    "title": "Questions",
    "section": "Question 2",
    "text": "Question 2\n\ndf1 &lt;- structure(list(\n  num_pp = c(1, 2, 3, 4, 5, 6), \n  nombre_dp1 = c(24,14, 2, 6, 6, 21), \n  nombre_dp05 = c(20, 28, 2, 9, 8, 21), \n  nombre_dp0 = c(24,20, 4, 11, 8, 20), \n  jugement_causal_dp1 = c(\"Oui\", \"Oui\", \"Oui\",\"Oui\", \"Oui\", \"Oui\"), \n  jugement_causal_dp05 = c(\"Non\", \"Oui\",\"Non\", \"Non\", \"Oui\", \"Non\"),\n  jugement_causal_dp0 = c(\"Non\", \"Non\",\"Oui\", \"Non\", \"Non\", \"Non\"),\n  confiance_dp1 = c(90, 80, 63, 80,90, 80),\n  confiance_dp05 = c(60, 50, 86, 65, 50, 90),\n  confiance_dp0 = c(65,60, 55, 43, 50, 80),\n  age = c(33, 22, 20, 20, 18, 18),\n  genre = c(\"Masculin\",\"Feminin\", \"Feminin\", \"Feminin\", \"Feminin\", \"Feminin\"),\n  etude = c(\"L1\",\"L1\", \"L1\", \"L1\", \"L1\", \"L1\"),\n  ordre = c(\"dp_05|dp_1|dp_0\", \"dp_0|dp_1|dp_05\",\"dp_0|dp_1|dp_05\", \"dp_0|dp_05|dp_1\", \"dp_1|dp_05|dp_0\", \"dp_1|dp_05|dp_0\"),\n  wdif_dp1dp05 = c(-4, 14, 0, 3, 2, 0)),\n  row.names = c(NA, -6L), class = c(\"tbl_df\", \"tbl\", \"data.frame\"))\n\nThe dataset above represents a repeated measure design. ie It has multiple measures with each measure under 3 conditions.\nFor example, the measure nombre is repeated under conditions dp1, dp05 and dp0. In this dataset we have 3 measures ie:\n\nmatrix(str_subset(names(df1), \"_dp\\\\d+$\"), 3, byrow = TRUE)\n\n     [,1]                  [,2]                   [,3]                 \n[1,] \"nombre_dp1\"          \"nombre_dp05\"          \"nombre_dp0\"         \n[2,] \"jugement_causal_dp1\" \"jugement_causal_dp05\" \"jugement_causal_dp0\"\n[3,] \"confiance_dp1\"       \"confiance_dp05\"       \"confiance_dp0\"      \n\n\nTransform the data to have only the measures as the columns and include the conditions in their own column ie:\n\n\n\nparticipant id\ncondition\nmeasure1\nmeasure2\nmeasure3\n\n\n\n\n1\n1\n\n\n\n\n\n1\n5\n\n\n\n\n\n1\n0"
  },
  {
    "objectID": "pivot_questions.html#question-3",
    "href": "pivot_questions.html#question-3",
    "title": "Questions",
    "section": "Question 3",
    "text": "Question 3\nwrite regular expression patterns which will match all of the values in x and none of the values in y.\n\nRanges\n\n\n\nx\ny\n\n\n\n\nabac\nbeam\n\n\naccede\nbuoy\n\n\nadead\ncanjac\n\n\nbabe\nchymia\n\n\nbead\ncorah\n\n\nbebed\ncupula\n\n\nbedad\ngriece\n\n\nbedded\nhafter\n\n\nbedead\nidic\n\n\nbedeaf\nlucy\n\n\ncaba\nmartyr\n\n\ncaffa\nmatron\n\n\ndace\nmessrs\n\n\ndade\nmucose\n\n\ndaff\nrelose\n\n\ndead\nsonly\n\n\ndeed\ntegua\n\n\ndeface\nthreap\n\n\nfaded\ntowned\n\n\nfaff\nwidish\n\n\nfeed\nyite\n\n\n\n\n\nBack References\n\n\n\nx\ny\n\n\n\n\nallochirally\nanticker\n\n\nanticovenanting\ncorundum\n\n\nbarbary\ncrabcatcher\n\n\ncalelectrical\ndamnably\n\n\nentablement\nfoxtailed\n\n\nethanethiol\ngalvanotactic\n\n\nfroufrou\ngummage\n\n\nfurfuryl\ngurniad\n\n\ngalagala\nhypergoddess\n\n\nheavyheaded\nkashga\n\n\nlinguatuline\nnonimitative\n\n\nmathematic\nparsonage\n\n\nmonoammonium\npouchlike\n\n\nperpera\npresumptuously\n\n\nphotophonic\npylar\n\n\npurpuraceous\nrachioparalysis\n\n\nsalpingonasal\nscherzando\n\n\ntestes\nswayed\n\n\ntrisectrix\nunbridledness\n\n\nundergrounder\nunupbraidingly\n\n\nuntaunted\nwellside\n\n\n\n\n\nPrimes\n\n\n\n\n\n\n\nx\ny\n\n\n\n\nxx\nxxxx\n\n\nxxx\nxxxxxx\n\n\nxxxxx\nxxxxxxxx\n\n\nxxxxxxx\nxxxxxxxxx\n\n\nxxxxxxxxxxx\nxxxxxxxxxx\n\n\nxxxxxxxxxxxxx\nxxxxxxxxxxxx\n\n\nxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxx\n\n\nxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxx\n\n\nxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxx\n\n\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxx\n\n\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxx\n\n\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxx\n\n\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxx\n\n\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxx\n\n\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxx\n\n\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxx\n\n\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxx\n\n\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n\n\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n\n\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
  },
  {
    "objectID": "pivot_questions.html#question-4",
    "href": "pivot_questions.html#question-4",
    "title": "Questions",
    "section": "Question 4",
    "text": "Question 4\nGiven the dataset below, transform it to have two columns, ie the Name column and the Year column:\n\n\n\nName\n\n\n\n\nPercy Vere (2020)\n\n\nGinger Plant (2017)\n\n\nPerry (2019)\n\n\nPat Thettick (2020)\n\n\nSamuel (2022)\n\n\nFay Daway (2008)\n\n\nGreg (2022)\n\n\nSimon Sais (2011)"
  },
  {
    "objectID": "root_finding.html",
    "href": "root_finding.html",
    "title": "Root finding Algorithms",
    "section": "",
    "text": "Every aspect of our lives is bombarded with problems that require solutions. From a simple tasks as travelling, weekend planning, playing etc we desire to utilize the information available and carry out the task efficiently with minimum cost incurred. All these are problems which need optimal solutions.\nIn this section we would use define simple math problems and ways to solve them. Then later on tackle real world problems and ways to go around them.\nThe first class of numerical methods we will discuss are root finding methods, which approximate the roots (or zeroes) of a function. Suppose that a function \\(f\\) is a continuous function, a root of \\(f\\) is a solution to the equation \\(f (x) = 0\\). Graphically, a root is where the graph \\(y = f (x)\\) crosses the x-axis.\nOften simple problems have analytic solutions. For example, to solve the roots of\\(f(x) = x^2-5x + 6\\) we can use any of the known methods, ie factorization, completing square or even the quadratic formula. and we would end up having \\(x=2\\) and \\(x = 3\\) as the roots. We could simply code the quadratic formula in R and each time we have a quadratic equation, we could easily find its roots:\n\\[x = \\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}\\]\nIn R we could do:\nroot &lt;- function(a, b, c){\n  (-b +c(-1,1)*sqrt(b^2 - 4*a*c))/(2*a)\n}\nroot(1,-5,6)\n\n[1] 2 3\nThe funtion root above computes the solution to most of the quadratic functions. Of course the function will not work for a quadratic with with a negative discriminant.\nroot(5,-9,5)\n\nWarning in sqrt(b^2 - 4 * a * c): NaNs produced\n\n\n[1] NaN NaN\nThus we can simply convert the discriminant to complex by adding a complex 0 to it and hence making the function work in all instances.\nroot &lt;- function(a, b, c){\n  (-b +c(-1,1)*sqrt(b^2 - 4*a*c + 0i))/(2*a)\n}\nroot(1,-5,6)\n\n[1] 2+0i 3+0i\n\nroot(5,-9,5)\n\n[1] 0.9-0.4358899i 0.9+0.4358899i\nInstead of writing our own function, we could use polyroot function to find the roots of any polynomial function, ie linear, quadratic,cubic, quartic, quintic, biquadratic etc. We do not have to write our own function:\npolyroot(c(6,-5,1)) #x^2 - 5x + 6 = 0\n\n[1] 2+0i 3-0i\n\npolyroot(c(-18,33,-18,3)) # 3x^3 -18x^2 + 33x -18 = 0\n\n[1] 1-0i 2+0i 3-0i"
  },
  {
    "objectID": "root_finding.html#procedure",
    "href": "root_finding.html#procedure",
    "title": "Root finding Algorithms",
    "section": "Procedure",
    "text": "Procedure\nStart with \\(x_{\\ell}&lt;x_r\\) such that \\(f\\left(x_{\\ell}\\right) f\\left(x_r\\right)&lt;0\\).\n\nIf \\(x_r-x_{\\ell} \\leq \\varepsilon\\), then stop.\nCompute \\(x_m=\\frac{x_{\\ell}+x_r}{2}\\). If \\(f\\left(x_m\\right)=0\\), then stop.\nIf \\(f\\left(x_{\\ell}\\right) f\\left(x_m\\right)&lt;0\\), then assign \\(x_r=x_m\\). Otherwise, assign \\(x_{\\ell}=x_m\\).\nGo back to step 1.\n\nNotice that, at every iteration, the interval \\(\\left(x_{\\ell}, x_r\\right)\\) always contains a root. Assuming we start with \\(f\\left(x_{\\ell}\\right) f\\left(x_r\\right)&lt;0\\), the algorithm is guaranteed to converge, with the approximation error reducing by a constant factor \\(1 / 2\\) at each iteration. If we stop when \\(x_r-x_{\\ell} \\leq \\varepsilon\\), then we know that both \\(x_{\\ell}\\) and \\(x_r\\) are within \\(\\varepsilon\\) distance of a root.\n\nf &lt;- function(x)x^2-5*x+6\n\nmy_roots &lt;- function(f, x_l, x_r, tolerr = 1e-8){\n  repeat{\n      mid &lt;- (x_l + x_r)/2\n      f_mid &lt;- f(mid)\n      if(f_mid == 0 | x_r - x_l &lt; tolerr) break\n      if(f(x_l)*f_mid &lt; 0) x_r &lt;- mid\n      else x_l &lt;- mid\n    }\n  mid\n}\n\nmy_roots(f,2.5, 10)\n\n[1] 3\n\nmy_roots(f,-10,2.5)\n\n[1] 2\n\nmy_roots(\\(x)log(x)-exp(-x), 0, 10)\n\n[1] 1.3098\n\n\nThere is a function in R that does exactly what we have implemented above. Its called uniroot: It has various parameters. do a quick help('uniroot') to know how to use the function\n\nuniroot(f, c(2.5, 10), tol = 1e-10)\n\n$root\n[1] 3\n\n$f.root\n[1] 5.329071e-15\n\n$iter\n[1] 14\n\n$init.it\n[1] NA\n\n$estim.prec\n[1] 5.000134e-11\n\nuniroot(f, lower = -10, upper = 2.5)\n\n$root\n[1] 2.000006\n\n$f.root\n[1] -6.423345e-06\n\n$iter\n[1] 14\n\n$init.it\n[1] NA\n\n$estim.prec\n[1] 6.103516e-05\n\nuniroot(f, lower = -10, upper = -9, extendInt = 'yes', tol=1e-15)\n\n$root\n[1] 2\n\n$f.root\n[1] 0\n\n$iter\n[1] 24\n\n$init.it\n[1] 7\n\n$estim.prec\n[1] 0.0003936229\n\nuniroot(\\(x)log(x)-exp(-x), c(0, 10))\n\n$root\n[1] 1.309799\n\n$f.root\n[1] -1.897809e-07\n\n$iter\n[1] 8\n\n$init.it\n[1] NA\n\n$estim.prec\n[1] 6.103516e-05\n\n\nUse the function to solve problems in Exercise 4"
  },
  {
    "objectID": "root_finding.html#procedure-1",
    "href": "root_finding.html#procedure-1",
    "title": "Root finding Algorithms",
    "section": "Procedure",
    "text": "Procedure\nThe Newton-Raphson algorithm is described as follows:\n\nStart from an initial value \\(x_0\\) chosen arbitrarily.\nRepeat:\n\\[\n    x_{n+1} = x_n - \\frac{f(x_n)}{f'(x_n)}\n    \\]\nStop when \\(\\left|f\\left(x_n\\right)\\right| \\leq \\varepsilon\\), where \\(\\varepsilon&gt;0\\) is the pre-specified tolerance level.\n\nNotice how this iteration is similar to \\(x_{n+1} = x_{n} - \\alpha f(x_n)\\) introduced in the section above, with \\(\\alpha = \\frac{1}{f'(x_n)}\\). The newton raphson method is one way of determining the value of \\(\\alpha\\). Using this method, we always subtract, regardless of the starting point.\n\nf &lt;- function(x)x^2 - 5*x + 6\nfprime &lt;- function(x)2*x - 5\nx &lt;- 10\nfor(i in 1:8){\n  x &lt;- x -  f(x)/fprime(x) # we used subtraction \n}\nx\n\n[1] 3\n\n\n\nx &lt;- -10\nfor(i in 1:8){\n  x &lt;- x -  f(x)/fprime(x) # we used subtraction \n}\nx\n\n[1] 2\n\n\nNotice how this time round, we did not bother to do a trial and error on what to include. We just wrote the code, and the different starting points led to the different needed solutions. Notice how i only used 7 iterations to converge to the solution.\n\nx &lt;- 10\nfor(i in 1:150){\n  alpha &lt;- 1/fprime(x)\n  # To write in alpha notation:\n  x &lt;- x -  alpha * f(x) # we used subtraction \n}\nx\n\n[1] 3\n\n\n\ng &lt;- function(x) log(x)-exp(-x)\ngprime &lt;- function(x)1/x + exp(-x)\nx &lt;- 1\ntolerr &lt;- 1e-10\n\nwhile(abs(g(x))&gt;tolerr){\n  x &lt;- x - g(x)/gprime(x)\n}\nx\n\n[1] 1.3098"
  },
  {
    "objectID": "root_finding.html#procedure-2",
    "href": "root_finding.html#procedure-2",
    "title": "Root finding Algorithms",
    "section": "Procedure",
    "text": "Procedure\n\nStart from arbitrary initial values \\(x_0\\) and \\(x_1\\).\nRepeat:\n\\[x_{n+1} = x_n-\\frac{x_n-x_{n-1}}{f(x_n) - f(x_{n-1})}f(x_n)\\]\nStop when \\(\\left|f\\left(x_n\\right)\\right| \\leq \\varepsilon\\), where \\(\\varepsilon&gt;0\\) is the pre-specified tolerance level.\n\n\nf &lt;- function(x) log(x)-exp(-x)\nx0 &lt;- 1\nx1 &lt;- 2\ntolerr &lt;- 1e-10\nwhile(abs(f(x1))&gt;tolerr){\n  alpha &lt;- (x1 - x0)/(f(x1) - f(x0))\n  x2 &lt;- x1 -  alpha * f(x1)\n  x0 &lt;- x1\n  x1 &lt;- x2\n}\nx2\n\n[1] 1.3098\n\n\nThe above code can be shortened to\n\nf &lt;- function(x) log(x)-exp(-x)\nx0 &lt;- 1\nx1 &lt;- 2\ntolerr &lt;- 1e-10\nwhile(abs(f(x1))&gt;tolerr){\n  alpha &lt;- (x1 - x0)/(f(x1) - f(x0))\n  x1 &lt;- (x0 &lt;- x1) -  alpha * f(x1)\n}\nx1\n\n[1] 1.3098\n\n\nAnother method is by using the numerical gradient approximation. ie gradient is defined as\n\\[\nf'(x) = \\lim_{h\\to0}\\frac{f(x+h) -f(x)}{h}\n\\]\nSince in the world of computing, \\(h\\) cannot be zero, we set is to be a small number and do the approximation:\n\\[\nf'(x) \\approx \\frac{f(x+h) -f(x)}{h}\n\\]\n\nf &lt;- function(x) log(x)-exp(-x)\nx &lt;- 1\ntolerr &lt;- 1e-10\nh &lt;- 1e-5\nwhile(abs(f(x))&gt;tolerr){\n  alpha &lt;- h / (f(x + h) - f(x))\n  x &lt;- x -  alpha * f(x)\n}\nx\n\n[1] 1.3098"
  },
  {
    "objectID": "root_finding.html#procedure-3",
    "href": "root_finding.html#procedure-3",
    "title": "Root finding Algorithms",
    "section": "Procedure",
    "text": "Procedure\n\nStart from an initial value \\(x_0\\).\nCompute \\(g\\left(x_0\\right)\\) as the next value \\(x_1\\).\nRepeat:\n\\[\nx_{n+1} = g\\left(x_n\\right)\n\\]\nstop when \\(\\left|x_n-x_{n-1}\\right| \\leq \\varepsilon\\), for some user-specified tolerance level \\(\\varepsilon&gt;0\\).\n\nUsing the example above: \\(f(x) = \\log(x) - \\exp(-x)\\) , we first have to express the problem as a fixed point\n\\[\n\\log(x) - e^{-x} = 0 \\implies x = e^{e^{-x}}\n\\]\nNow our \\(g(x) = e{e{-x}}\\), then the fixed point of \\(g(x)\\) corresponds to the root of \\(f(x)\\)\nA quick implementation:\n\ng &lt;- function(x) exp(exp(-x))\nx_old &lt;- 10\nx_new &lt;- g(x_old)\nits &lt;- 0\ntol &lt;- 1e-8\nwhile(abs(x_new - x_old) &gt; tol){\n  x_old &lt;- x_new\n  x_new &lt;- g(x_old)\n  its &lt;- its + 1\n}\nx_new\n\n[1] 1.3098\n\n\nA shorter version\n\ng &lt;- function(x)exp(exp(-x))\nx &lt;- 10\ntolerr &lt;- 1e-8\nwhile(abs(x - (x &lt;- g(x)))&gt;tolerr){}\nx\n\n[1] 1.3098\n\n\nUsing recursion:\n\ns &lt;- function(x = 10, tol = 1e-8) {\n  if(abs((y&lt;-exp(exp(-x)))- x)&lt;tol)x else s(y)\n}\ns()\n\n[1] 1.3098\n\n\nNotice that using the fixed point for this particular problem, we can begin from any number, ie including negative numbers, while for the methods previously discussed, we could only start from positive numbers since we cannot evaluate a logarithm of a negative number. Chose the method to implement wisely.\nThe methods mentioned above can be extended to solve multivariate functions.\nSuppose we have a system of linear equation. How can we solve this?\n\\[\n\\begin{pmatrix}1\\\\1\\end{pmatrix}x + \\begin{pmatrix}-4\\\\2\\end{pmatrix}y = \\begin{pmatrix}-7\\\\5\\end{pmatrix}\n\\]\nNotice that the system has been written in vector notations. We can then implement the solution as \\(x_{n+1} = x_{n} - \\alpha f(x_n)\\).\n\nh &lt;- function(x, z = c(-7,5)) x[1] + c(-4,2)*x[2] - z\nx &lt;- c(0,0) #initial starting point\nfor (i in 1:100){\n  x &lt;- x - 0.2*h(x)\n}\nx # final root of the function\n\n[1] 1 2"
  },
  {
    "objectID": "Solutions.html",
    "href": "Solutions.html",
    "title": "Solutions",
    "section": "",
    "text": "Exercise 3\n\nFactorial:\nUsing While loop\n\nfact1 &lt;- function(n){\n  if(n&lt;0) return(NA)\n  result &lt;- 1\n  while(n &gt; 0){\n    result &lt;- result * n\n    n &lt;- n - 1\n  }\n      result\n}\nfact1(5)\n\n[1] 120\n\n\nUsing repeat\n\nfact2 &lt;- function(n){\n  if(n&lt;0) return(NA)\n  result &lt;- 1\n  repeat{\n    if(n &lt; 2) break\n    result &lt;- result * n\n    n &lt;- n - 1\n  }\n  result\n}\nfact2(6)\n\n[1] 720\n\n\nUsing For-loop\n\nfact3 &lt;- function(n){\n  if(n&lt;0) return(NA)\n  result &lt;- 1\n  for(i in seq_len(n)){\n    result &lt;- result * i \n  }\n  result\n}\nfact3(4)\n\n[1] 24\n\n\nDisplaying the Multiplication Table\n\n{\n  for(i in seq(9)) cat(\"\\t\", i)\n  cat(\"\\n\")\n  for(i in seq_len(9)){\n    cat(i)\n    for(j in seq_len(9)){\n      cat(\"\\t\", i*j)\n    }\n    cat(\"\\n\")\n  }\n}\n\n     1   2   3   4   5   6   7   8   9\n1    1   2   3   4   5   6   7   8   9\n2    2   4   6   8   10  12  14  16  18\n3    3   6   9   12  15  18  21  24  27\n4    4   8   12  16  20  24  28  32  36\n5    5   10  15  20  25  30  35  40  45\n6    6   12  18  24  30  36  42  48  54\n7    7   14  21  28  35  42  49  56  63\n8    8   16  24  32  40  48  56  64  72\n9    9   18  27  36  45  54  63  72  81\n\n\ngrade(x)\n\ngrade &lt;- function(x){\n  if(x &gt;= 90) 'A'\n  else if(x &gt;= 80) 'B'\n  else if(x &gt;= 70) 'C'\n  else if(x &gt;= 60) 'D'\n  else if(x &gt;= 50) 'E'\n  else 'F'\n}\ngrade(93)\n\n[1] \"A\"\n\n\ngrades(x)\n\ngrades &lt;- function(x){\n  for(i in x) cat(grade(i), \" \")\n}\ngrades(c(73, 92, 80, 49))\n\nC  A  B  F  \n\n\n\\(\\pi\\) estimation:\n\nresult &lt;- 0\nfor(i in 0:200000){\n  result &lt;- result + 4*(-1)^i/(i*2+1)\n}\nsprintf(\"%.30f\", result)\n\n[1] \"3.141597653564761838396179882693\"\n\nsprintf(\"%.30f\", pi)\n\n[1] \"3.141592653589793115997963468544\"\n\n\n\\(\\pi\\) estimation:\n\nconst &lt;- 2*sqrt(2)/9801\nres &lt;- 0\nfor(k in 0:2){\n  res &lt;- res + factorial(4*k)*(1103 + 26390*k)/factorial(k)^4/396^(4*k)\n}\n1/const/res\n\n[1] 3.141593\n\nsprintf(\"%.30f\", pi)\n\n[1] \"3.141592653589793115997963468544\"\n\nsprintf(\"%.30f\", 1/const/res)\n\n[1] \"3.141592653589792671908753618482\"\n\n\nsqrt_avg\n\nsqrt_avg &lt;- function(x){\n  begin = 0\n  end = x\n  repeat{\n    mid &lt;- (begin + end)/2\n    err &lt;- x - mid * mid\n    if(abs(err) &lt; 1e-8) break\n    if(err &gt; 0) begin &lt;- mid\n    else end &lt;- mid\n  }\n  mid\n}\nsqrt_avg(2)\n\n[1] 1.414214\n\n\nsqrt_heron\n\nsqrt_heron &lt;- function(x){\n  x0 &lt;- 1\n  repeat{\n    x_new &lt;- (x0 + x/x0)/2\n    if(abs(x_new - x0) &lt; 1e-8) break\n    x0 &lt;- x_new\n  }\n  x0\n}\nsqrt_heron(2)\n\n[1] 1.414214\n\n\n\n\n\nExercise 4\n\nFibonacci:\n\nfib1 &lt;- function(x){\n  a = 0\n  b = 1\n  while(x&gt;1){\n    temp &lt;- a\n    a &lt;- b \n    b &lt;- b + temp\n    x &lt;- x - 1\n  }\n  b\n}\nfib1(10)\n\n[1] 55\n\n\nGCD\n\ngcd &lt;- function(a, b){\n  if(b == 0) a\n  else gcd(b, a%%b)\n}\n\n\n\n\nLCM\n\nlcm &lt;- function(a, b){\n  a * b /gcd(a, b)\n}\n\nTaylor Series:\nexp(x) : Will correctly approximate values from\\(-11&lt; x &lt; 55\\). Notice that for numbers outside this interval, we need more iterations.\n\nmy_exp &lt;- function(x){\n  result &lt;- fact &lt;- i &lt;- 1 #taken the first term as result\n  while(i &lt;= 100){\n    result &lt;- result + x^i/fact\n    i &lt;- i + 1\n    fact &lt;- fact * i\n  }\n  result\n}\n\nlog(x) : Used the first 50 terms. Only approximates \\(0.2\\leq x\\leq2\\) . The error is huge for numbers outside this interval\n\nmy_log_restricted &lt;- function(x){\n  if(x&gt;2 | x&lt;0.2) return(NA)\n  i &lt;- 1\n  result &lt;- 0\n  while(i &lt;= 100){\n    result &lt;- result + (-1)^(i-1) * (x-1)^i/i\n    i &lt;- i + 1\n  }\n  result\n}\n\nsin(x) : \\(-\\infty &lt;x&lt;\\infty\\)\n\nmy_sin &lt;- function(x){\n  x &lt;- x %% (2*pi)\n  fact &lt;- i &lt;- j &lt;- 1\n  result &lt;- 0\n  while(i &lt;= 50){\n    result &lt;- result + (-1)^(i-1)*x^(2*i-1)/fact\n    i &lt;- i + 1\n    fact &lt;- fact * (2*i - 1 - 1) * (2*i - 1)\n  }\n  result\n}\n\nSignificant Digits:\n\nsignif_digits &lt;- function(x, base){\n  x &lt;- abs(x)\n  if(round(x,6) &gt;= 1 & x &lt; base) 0\n  else {\n    pow &lt;- (-1)^(x &lt; 1)\n    pow + signif_digits(x/base^pow, base)\n  }\n}\n\n\nsignif_digits_1 &lt;- function(x, base){\n  x &lt;- abs(x)\n  result &lt;- 0\n  pow &lt;- if(x &lt; 1) -1 else 1\n  while(round(x, 6) &lt; 1 | x &gt;= base){\n    result &lt;- result + pow\n    x &lt;- x / base^pow\n  }\n  result  \n}\n\nDigit Sum\n\ndigit_sum &lt;- function(n){\n  n &lt;- abs(n)\n  if(n &lt; 10) return(n)\n  n %% 10 + Recall(n%/%10)\n}\n\n\n\n\nDigital Root\n\ndigit_root &lt;- function(n){\n  if(abs(n)&gt;10) digit_root(digit_sum(n))\n  else n\n}\n\nLogarithms:\n\nmy_log_using10 &lt;- function(x){\n   const &lt;- 2.302585092994045901094\n   b &lt;- signif_digits(x, 10)\n   a &lt;- x/10^b\n   if(a&gt;2) {\n     a &lt;- a/10\n     b &lt;- b + 1\n   }\n   my_log_restricted(a) + b*const\n}\n\n\nmy_log_using2 &lt;- function(x){\n   const &lt;- 0.6931471805599452862268\n   b &lt;- signif_digits(x, 2)\n   a &lt;- x/2^b\n   my_log_restricted(a) + b*const\n}\n\n\nmy_log2 &lt;-function(x){\n  if(x==1) return(0)\n  w &lt;- 1\n  if(x&lt;1) {\n    x &lt;- 1/x\n    w &lt;- -1\n  }\n  res &lt;- 0\n  n &lt;- 0\n  for(i in 1:20){\n    m &lt;- 0\n    while(x&lt;2){\n      m &lt;- m+1\n      x &lt;- x**2\n    }\n    x &lt;- x/2\n    n &lt;- m + n\n    res &lt;- res + 2^-n\n  }\n  w * res\n}\n\nOptimization\n\nx &lt;- 1\nrepeat{\n  f &lt;- x^2*exp(3*x) - 10\n  f_prime &lt;- 2*x*exp(3*x) + 3*x^2*exp(6*x)\n  x_new &lt;- x - f/f_prime\n  if(abs(x_new - x)&lt;1e-8) break\n  x &lt;- x_new\n}\nx\n\n[1] 0.8645552\n\nx^2*exp(3*x)\n\n[1] 10\n\n\n\nx &lt;- 1\nrepeat{\n  f &lt;- x^3 + 8 \n  f_prime &lt;- 3*x^2\n  x_new &lt;- x - f/f_prime\n  if(abs(x_new - x)&lt;1e-8) break\n  x &lt;- x_new\n}\nx\n\n[1] -2\n\nx^3\n\n[1] -8\n\n\n\nmy_sqrt &lt;- function(x){\n  y &lt;- 1\n  repeat{\n    f &lt;- y^2 - x \n    f_prime &lt;- 2*y\n    y_new &lt;- y - f/f_prime\n    if(abs(y_new - y)&lt;1e-8) break\n    y &lt;- y_new\n  }\n  y\n}\nmy_sqrt(49)\n\n[1] 7\n\nmy_sqrt(2)\n\n[1] 1.414214\n\n\n\n\n\n\nmy_log_newton &lt;- function(x){\n  if(x==1)return(0)\n  y &lt;- 1\n  repeat{\n    f &lt;- my_exp(y) - x \n    f_prime &lt;- my_exp(y)\n    y_new &lt;- y - f/f_prime\n    if(abs(y_new - y)&lt;1e-16) break\n    y &lt;- y_new\n  }\n  y\n}\n\n\nmy_optim &lt;- function(x0, f, fprime){\n  repeat{\n    x &lt;- x0 - f(x0)/fprime(x0)\n    if(abs(x - x0)&lt;1e-8) break\n    x0 &lt;- x\n  }\n  x0\n}\n\nmy_optim(1, function(z) z^3 + 8, function(x)3*x^2)\n\n[1] -2\n\n\nNumerical Differentiation/Derivatives\n\nmy_derive &lt;- function(x, f){\n   h &lt;- 1e-8\n  (f(x+h) - f(x))/h\n}\n\n\nmy_optim2 &lt;- function(f){\n  x &lt;- 1\n   repeat{\n    x_new &lt;- x - f(x)/my_derive(x, f)\n    if(abs(x_new - x)&lt;1e-8) break\n    x &lt;- x_new\n   }\n  x\n}\n\nmy_optim2(function(x)x^2*exp(3*x)-10)\n\n[1] 0.8645552\n\n\n\n\n\nBetter Fibonacci Recursion\n\nmy_fib &lt;- function(x, start = 0, end = 1){\n  if(x == 1)end\n  else Recall(x - 1, end, start + end)\n}\nmy_fib(30) # Compare the times with the previous fib function\n\n[1] 832040\n\nmy_fib(200)# Do not run fib(200)\n\n[1] 2.805712e+41\n\n\nTower of Hanoi\n\ntower_of_hanoi &lt;- function(height, from, to, via){\n  if(height == 1) \n    cat(\"Move disk\",height,\"from\", from, \"to\", to, \"\\n\")\n  else {\n    tower_of_hanoi(height-1, from, via, to)\n    cat(\"Move disk\",height,\"from\", from, \"to\", to, \"\\n\")\n    tower_of_hanoi(height-1, via, to, from)\n  }\n}\ntower_of_hanoi(4, \"A\", \"B\", \"C\")\n\nMove disk 1 from A to C \nMove disk 2 from A to B \nMove disk 1 from C to B \nMove disk 3 from A to C \nMove disk 1 from B to A \nMove disk 2 from B to C \nMove disk 1 from A to C \nMove disk 4 from A to B \nMove disk 1 from C to B \nMove disk 2 from C to A \nMove disk 1 from B to A \nMove disk 3 from C to B \nMove disk 1 from A to C \nMove disk 2 from A to B \nMove disk 1 from C to B \n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "string.html",
    "href": "string.html",
    "title": "strings",
    "section": "",
    "text": "Apart from numbers, we also have the character class. This is anything other than literal numbers. A string can be made up of one character or several characters.\nlibrary(stringr)\n\"hello world\"\n\n[1] \"hello world\"\nThe above, though having several characters, it is one string.\na &lt;- \"hello world\"\nlength(a)\n\n[1] 1\nTo count the number of characters within a string, we use nchar function:\nstr_count(a)\n\n[1] 11\n\nstr_length(a) #length of string\n\n[1] 11\n\nnchar(a)#number of characters\n\n[1] 11\nTo create a vector of strings, we use the c function:\nb &lt;- c(\"HELLO WORLD\", \"HeLlo WoRlD\", \"hello WORLD\", \"HELLO world\")\nthe vector b has 4 elements in it. Since R is case sensitive, all the elements are considered to be different.\nunique(b)\n\n[1] \"HELLO WORLD\" \"HeLlo WoRlD\" \"hello WORLD\" \"HELLO world\"\nIn day to day, we come across a lot of strings/characters that need to be manipulated in such a way to obtain meaningful information from them. We will tackle some of the methods used to manipulate characters/strings. Note that though the above vector b has 4 unique elements, we know that the elements are just a variation of the string hello world. We can be able to manipulate the vector to ensure we have only 1 unique string."
  },
  {
    "objectID": "string.html#applications-of-regular-expressions",
    "href": "string.html#applications-of-regular-expressions",
    "title": "strings",
    "section": "Applications of Regular Expressions",
    "text": "Applications of Regular Expressions\nSome common applications of regular expressions:\n\nTest if a phone number has the correct number of digits\nTest if a date follows a specifc format (e.g. mm/dd/yy)\nTest if an email address is in a valid format\nTest if a password has numbers and special characters\nSearch a document for gray spelled either as “gray” or “grey”\nSearch a document and replace all occurrences of “Will”, “Bill”, or “W.” with “William”\nCount the number of times in a document that the word “analysis” is immediately preceded by the words “data”, “computer”, or “statistical”\nConvert a comma-delimited file into a tab-delimited file\nFind duplicate words in a text\n\nand so many more …"
  },
  {
    "objectID": "tidyverse.html",
    "href": "tidyverse.html",
    "title": "tidyverse",
    "section": "",
    "text": "This project was developed to make it simple to manipulate the data. Although one can use Base R to do data manipulation, there are inconsistencies regarding the function names and parameters. Tidyverse package takes the notion of MapReduce to a whole new level."
  },
  {
    "objectID": "tidyverse.html#argument-placeholder",
    "href": "tidyverse.html#argument-placeholder",
    "title": "tidyverse",
    "section": "Argument Placeholder",
    "text": "Argument Placeholder\nWhen using the pipe operator the . can be used as an argument placeholder on the righthand side to represent the object on the lefthand side.\n\nf(x,y) can be written as y %&gt;% f(x, .)\nlm(Volume~Height, data = trees) can be written as trees %&gt;% lm(Volume ~ Height, data = .)\n\nThe native pipe |&gt; on the other hand uses _ as the argument placeholder, but does not accept argument matching by position. Thus one must pass the argument by name:\n\nf(x,y) can be written as y |&gt; f(x,y = _).\ntrees |&gt; lm(Volume ~ Height, data = _)\n\nNote:\n\ntrees %&gt;% lm(Volume ~ Height, .) works\ntrees |&gt; lm(Volume ~ Height, _) does not work.\n\nRun the above to determine as to whether they run or not."
  },
  {
    "objectID": "tidyverse.html#when-to-use-pipe",
    "href": "tidyverse.html#when-to-use-pipe",
    "title": "tidyverse",
    "section": "When to use pipe",
    "text": "When to use pipe\nIt is not compulsory to use pipes, though they can simplify your task. In case you have more than one input at a time, then you can decide not to use pipe. Also, if it simple to directly call the function on the data, there is no need to use a pipe. On the other hand, if the input has to be manipulated in a complex manner before obtaining the output, consider using the pipe. Note also that whenever you are working with tidyverse, you should consider using the magritrr pipe %&gt;% rather than the native pipeas it is already loaded to your searchpath."
  },
  {
    "objectID": "tidyverse.html#unite",
    "href": "tidyverse.html#unite",
    "title": "tidyverse",
    "section": "Unite",
    "text": "Unite\nAs stated before, this is used to bring together data spread across multiple variables/cells into one variable/cell. For example assume we have a dataset whereby we have a column containing year, another column containing month and another column containing day. These three columns need to be just one column denoted as date.\n\ndf &lt;- data.frame(Year = c(2021, 2022, 2023, 2021),\n                 month = c(8,7,8,1), \n                 day = c(23,14, 30, 8))\ndf\n\n  Year month day\n1 2021     8  23\n2 2022     7  14\n3 2023     8  30\n4 2021     1   8\n\n\nNote that we can unite all the above to just have one column:\n\nunite(df, Date, Year, month, day, sep = '-', remove = FALSE)\n\n       Date Year month day\n1 2021-8-23 2021     8  23\n2 2022-7-14 2022     7  14\n3 2023-8-30 2023     8  30\n4  2021-1-8 2021     1   8\n\n\n\ndf %&gt;%\n  unite(Date, everything(), sep = '-', remove = FALSE)\n\n       Date Year month day\n1 2021-8-23 2021     8  23\n2 2022-7-14 2022     7  14\n3 2023-8-30 2023     8  30\n4  2021-1-8 2021     1   8\n\n\nType help(\"unite\") skim through the help page. Run the examples. Then try the following.\nQuiz: Load the tidyverse package. Type table5 in the console. You should see a dataframe containing 6 observations and 4 variables. Note that the Year variable has been broken down into two variables. ie Century and year unite these two and create a correct Year variable. You should get what looks like table3"
  },
  {
    "objectID": "tidyverse.html#separate",
    "href": "tidyverse.html#separate",
    "title": "tidyverse",
    "section": "Separate",
    "text": "Separate\nThe separate() function pulls apart one column into multiple columns, by splitting wherever a separator character appears. It is the opposite of unite\nQuiz: Use separate function to convert table5 to look exactly like table2. Hint ?separate\nNote that separate() has been superseded in favour of separate_wider_position() and separate_wider_delim() .\nBoth separate and unite can be accomplished using the mutate function."
  },
  {
    "objectID": "tidyverse.html#pivot_wider",
    "href": "tidyverse.html#pivot_wider",
    "title": "tidyverse",
    "section": "pivot_wider",
    "text": "pivot_wider\nWhen an observation is scattered across multiple rows, we want to widen the observation from stacked rows into one wider row.\nConsider table2:\n\ntable2\n\n# A tibble: 12 × 4\n   country      year type            count\n   &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;           &lt;dbl&gt;\n 1 Afghanistan  1999 cases             745\n 2 Afghanistan  1999 population   19987071\n 3 Afghanistan  2000 cases            2666\n 4 Afghanistan  2000 population   20595360\n 5 Brazil       1999 cases           37737\n 6 Brazil       1999 population  172006362\n 7 Brazil       2000 cases           80488\n...\n\n\nConsider the case and population for each country per year to be one observation. Then the two should be on one row and not two rows. Look at the image below:\n\nThe image depicts the process of reshaping/casting/pivoting the data into a wider format. This wider format will be considered as the tidy data. The longer format provided above is untidy/messy.\npivot_wider() “widens” data, increasing the number of columns and decreasing the number of rows. The inverse transformation is pivot_longer() To transform the data as shown in the image above, the code will be:\n\ntable2 %&gt;%\n  pivot_wider(id_cols = c(country, year), names_from = type, values_from = count)\n\n# A tibble: 6 × 4\n  country      year  cases population\n  &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;\n1 Afghanistan  1999    745   19987071\n2 Afghanistan  2000   2666   20595360\n3 Brazil       1999  37737  172006362\n4 Brazil       2000  80488  174504898\n5 China        1999 212258 1272915272\n6 China        2000 213766 1280428583\n\n\n\nThe id_cols are the columns that need to be maintained, ie not widened/spread\nThe names_from is the column(s) that contains variable names.\nThe values_from is the column(s) that contains the values from multiple variables.\n\nLook at the help page to learn more about the various parameters of this function. Run all the examples of that page looking at the different code used to generate the required output.\n\nExercise\n[1], [8], [9]\n[2]\n[3]\n[4]\n[5]\n[6] try"
  },
  {
    "objectID": "tidyverse.html#pivot_longer",
    "href": "tidyverse.html#pivot_longer",
    "title": "tidyverse",
    "section": "pivot_longer",
    "text": "pivot_longer\npivot_longer() “lengthens” data, increasing the number of rows and decreasing the number of columns. The inverse transformation is pivot_wider()\nconsider table4a:\n\ntable4a\n\n# A tibble: 3 × 3\n  country     `1999` `2000`\n  &lt;chr&gt;        &lt;dbl&gt;  &lt;dbl&gt;\n1 Afghanistan    745   2666\n2 Brazil       37737  80488\n3 China       212258 213766\n\n\n\nFrom the above, we can tell that the data in table 4a is messy. This is because we have more than one observation per row. For example in row 1 we have the cases in 1999 and the cases in 2000. Note that the cases per year which should belong in one variable are spread over multiple variables/columns.\n\ntable4a %&gt;%\n  pivot_longer(-country)\n\n# A tibble: 6 × 3\n  country     name   value\n  &lt;chr&gt;       &lt;chr&gt;  &lt;dbl&gt;\n1 Afghanistan 1999     745\n2 Afghanistan 2000    2666\n3 Brazil      1999   37737\n4 Brazil      2000   80488\n5 China       1999  212258\n6 China       2000  213766\n\n\n\ntable4a %&gt;%\n  pivot_longer(-country, names_to = 'year', values_to = 'cases')\n\n# A tibble: 6 × 3\n  country     year   cases\n  &lt;chr&gt;       &lt;chr&gt;  &lt;dbl&gt;\n1 Afghanistan 1999     745\n2 Afghanistan 2000    2666\n3 Brazil      1999   37737\n4 Brazil      2000   80488\n5 China       1999  212258\n6 China       2000  213766\n\ntable4a %&gt;%\npivot_longer(c(`1999`, `2000`), names_to = \"year\", values_to = \"cases\")\n\n# A tibble: 6 × 3\n  country     year   cases\n  &lt;chr&gt;       &lt;chr&gt;  &lt;dbl&gt;\n1 Afghanistan 1999     745\n2 Afghanistan 2000    2666\n3 Brazil      1999   37737\n4 Brazil      2000   80488\n5 China       1999  212258\n6 China       2000  213766\n\n\nNote that in we had to use back tick quotes since the names are non-standard/non-syntactic.\nRead through the help page to better understand the function. Run the examples, especially the last one.\nNote: Most of the times, the names have to be captured using some particular pattern. One need to learn about regular expressions in order to easily used the name_pattern parameter.\n\nThe .value argument passed to names_to\nUsed when multiple variables are spread across multiple columns.\nLets take a look at only one varibale x spread across multiple columns: Check the different codes below:\n\ndf1 &lt;- data.frame(x_1 = 1:2, x_2 = 2:3, x_3 = 4:5)\n\npivot_longer(df1, everything())\n\n# A tibble: 6 × 2\n  name  value\n  &lt;chr&gt; &lt;int&gt;\n1 x_1       1\n2 x_2       2\n3 x_3       4\n4 x_1       2\n5 x_2       3\n6 x_3       5\n\npivot_longer(df1, everything(), names_to = 'group', values_to = 'x')\n\n# A tibble: 6 × 2\n  group     x\n  &lt;chr&gt; &lt;int&gt;\n1 x_1       1\n2 x_2       2\n3 x_3       4\n4 x_1       2\n5 x_2       3\n6 x_3       5\n\n\n\npivot_longer(df1, everything(), \n             names_to = c('var', 'group'), names_sep = '_')\n\n# A tibble: 6 × 3\n  var   group value\n  &lt;chr&gt; &lt;chr&gt; &lt;int&gt;\n1 x     1         1\n2 x     2         2\n3 x     3         4\n4 x     1         2\n5 x     2         3\n6 x     3         5\n\npivot_longer(df1, everything(), \n             names_to = c('.value', 'group'), names_sep = '_')\n\n# A tibble: 6 × 2\n  group     x\n  &lt;chr&gt; &lt;int&gt;\n1 1         1\n2 2         2\n3 3         4\n4 1         2\n5 2         3\n6 3         5\n\n\nNotice how when we used the .value within the names_to parameter, the value column was named according to the word that occupied the position prior to the separator in the names of the selected variables.\nWhat if instead of having just one variable, we had 2, ie x and y? The only way to obtain the needed results is by using .value as an the argument of names_to parameter.\n\ndf2 &lt;- cbind(df1, y_1 = 11:12, y_2 = 12:13, y_3 = 14:15)\n\n\npivot_longer(df2, everything(), \n             names_to = c(\".value\", \"group\"), names_sep = \"_\")\n\n# A tibble: 6 × 3\n  group     x     y\n  &lt;chr&gt; &lt;int&gt; &lt;int&gt;\n1 1         1    11\n2 2         2    12\n3 3         4    14\n4 1         2    12\n5 2         3    13\n6 3         5    15\n\n\nQuiz: clean the names of anscombe dataset by running anscombe %&gt;%janitor::clean_names(numerals = 'right'). Using the dataset with cleaned names, pivot the data to obtain only two columns ie columns x and y.\n\n\nExercise\n[1], [4]\n[2]\n[3]\n[4]\n[5]\n[6] Use the data frame shown below\n\ndf &lt;- structure(list(wind = c(0.84, 1.77, 3.5, 6.44, 7.55), ROS = c(0.01, \n0.03, 0.05, 0.07, 0.1), T0_1 = c(1110, 350, 250, 300, 311), T0_2 = c(560, \n200, 364, 258, 159), T0_3 = c(258, 147, 369, 123, 624), T180_1 = c(554, \n226, 547, 842, 366), T180_2 = c(258, 147, 369, 123, 624), T180_3 = c(110, \n350, 250, 300, 311)), class = \"data.frame\", row.names = c(NA, \n-5L))\n\nOther useful tidyr functions include fill unnest, unpack, and unchop . Learn more about fill"
  },
  {
    "objectID": "tidyverse.html#selecting-variables-using-select",
    "href": "tidyverse.html#selecting-variables-using-select",
    "title": "tidyverse",
    "section": "Selecting variables using select",
    "text": "Selecting variables using select\nIn data manipulation, we often desire to work on a subset of the variables in the whole dataset. The select function is used to only pick the variables of interest to work on.\nTidyverse selections implement a dialect of R where operators make it easy to select variables:\n\n: for selecting a range of consecutive variables.\n! for taking the complement of a set of variables.\n& and | for selecting the intersection or the union of two sets of variables.\nc() for combining selections.\n\n\nlibrary(tidyverse)\nstarwars\n\n# A tibble: 87 × 14\n   name     height  mass hair_color skin_color eye_color birth_year sex   gender\n   &lt;chr&gt;     &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; \n 1 Luke Sk…    172    77 blond      fair       blue            19   male  mascu…\n 2 C-3PO       167    75 &lt;NA&gt;       gold       yellow         112   none  mascu…\n 3 R2-D2        96    32 &lt;NA&gt;       white, bl… red             33   none  mascu…\n 4 Darth V…    202   136 none       white      yellow          41.9 male  mascu…\n 5 Leia Or…    150    49 brown      light      brown           19   fema… femin…\n 6 Owen La…    178   120 brown, gr… light      blue            52   male  mascu…\n 7 Beru Wh…    165    75 brown      light      blue            47   fema… femin…\n...\n\n\nselect name, height and mass from the starwars dataset.\n\nstarwars %&gt;% \n  select(name, height, mass) \n\n# A tibble: 87 × 3\n   name               height  mass\n   &lt;chr&gt;               &lt;int&gt; &lt;dbl&gt;\n 1 Luke Skywalker        172    77\n 2 C-3PO                 167    75\n 3 R2-D2                  96    32\n 4 Darth Vader           202   136\n 5 Leia Organa           150    49\n 6 Owen Lars             178   120\n 7 Beru Whitesun lars    165    75\n...\n\n\n\nstarwars %&gt;% \n  select(c(name, height, mass))\n\n# A tibble: 87 × 3\n   name               height  mass\n   &lt;chr&gt;               &lt;int&gt; &lt;dbl&gt;\n 1 Luke Skywalker        172    77\n 2 C-3PO                 167    75\n 3 R2-D2                  96    32\n 4 Darth Vader           202   136\n 5 Leia Organa           150    49\n 6 Owen Lars             178   120\n 7 Beru Whitesun lars    165    75\n...\n\n\nNote: There is no need to use the quotes eg \"name\" since we are working on tidyverse. If the names are not syntactically correct, eg contain punctuation marks, starts with numbers etc, you will have to use backticks or quotes to select those names.\nselect the first 3 variables\n\nstarwars %&gt;% \n  select(1:3)\n\n# A tibble: 87 × 3\n   name               height  mass\n   &lt;chr&gt;               &lt;int&gt; &lt;dbl&gt;\n 1 Luke Skywalker        172    77\n 2 C-3PO                 167    75\n 3 R2-D2                  96    32\n 4 Darth Vader           202   136\n 5 Leia Organa           150    49\n 6 Owen Lars             178   120\n 7 Beru Whitesun lars    165    75\n...\n\n\nselect everything apart from the sex and gender\n\nstarwars %&gt;% \n  select(-sex, -gender) # you can also do !sex, !gender\n\n# A tibble: 87 × 12\n   name        height  mass hair_color skin_color eye_color birth_year homeworld\n   &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;    \n 1 Luke Skywa…    172    77 blond      fair       blue            19   Tatooine \n 2 C-3PO          167    75 &lt;NA&gt;       gold       yellow         112   Tatooine \n 3 R2-D2           96    32 &lt;NA&gt;       white, bl… red             33   Naboo    \n 4 Darth Vader    202   136 none       white      yellow          41.9 Tatooine \n 5 Leia Organa    150    49 brown      light      brown           19   Alderaan \n 6 Owen Lars      178   120 brown, gr… light      blue            52   Tatooine \n 7 Beru White…    165    75 brown      light      blue            47   Tatooine \n...\n\n\nselect from hair_color to sex\n\nstarwars %&gt;%\n  select(hair_color:sex)\n\n# A tibble: 87 × 5\n   hair_color    skin_color  eye_color birth_year sex   \n   &lt;chr&gt;         &lt;chr&gt;       &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; \n 1 blond         fair        blue            19   male  \n 2 &lt;NA&gt;          gold        yellow         112   none  \n 3 &lt;NA&gt;          white, blue red             33   none  \n 4 none          white       yellow          41.9 male  \n 5 brown         light       brown           19   female\n 6 brown, grey   light       blue            52   male  \n 7 brown         light       blue            47   female\n...\n\n\nselect everything else apart from hair_color to sex\n\nstarwars %&gt;% \n  select(!(hair_color:sex)) # you could also use -(hair_color:sex)\n\n# A tibble: 87 × 9\n   name           height  mass gender homeworld species films vehicles starships\n   &lt;chr&gt;           &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;     &lt;chr&gt;   &lt;lis&gt; &lt;list&gt;   &lt;list&gt;   \n 1 Luke Skywalker    172    77 mascu… Tatooine  Human   &lt;chr&gt; &lt;chr&gt;    &lt;chr [2]&gt;\n 2 C-3PO             167    75 mascu… Tatooine  Droid   &lt;chr&gt; &lt;chr&gt;    &lt;chr [0]&gt;\n 3 R2-D2              96    32 mascu… Naboo     Droid   &lt;chr&gt; &lt;chr&gt;    &lt;chr [0]&gt;\n 4 Darth Vader       202   136 mascu… Tatooine  Human   &lt;chr&gt; &lt;chr&gt;    &lt;chr [1]&gt;\n 5 Leia Organa       150    49 femin… Alderaan  Human   &lt;chr&gt; &lt;chr&gt;    &lt;chr [0]&gt;\n 6 Owen Lars         178   120 mascu… Tatooine  Human   &lt;chr&gt; &lt;chr&gt;    &lt;chr [0]&gt;\n 7 Beru Whitesun…    165    75 femin… Tatooine  Human   &lt;chr&gt; &lt;chr&gt;    &lt;chr [0]&gt;\n...\n\n\nIn addition, you can use selection helpers. Some helpers select specific columns:\n\neverything(): Matches all variables.\nlast_col(): Select last variable, possibly with an offset.\n\nselect the last column\n\nstarwars %&gt;% \n  select(last_col())\n\n# A tibble: 87 × 1\n   starships\n   &lt;list&gt;   \n 1 &lt;chr [2]&gt;\n 2 &lt;chr [0]&gt;\n 3 &lt;chr [0]&gt;\n 4 &lt;chr [1]&gt;\n 5 &lt;chr [0]&gt;\n 6 &lt;chr [0]&gt;\n 7 &lt;chr [0]&gt;\n...\n\n\nselect from species to the last column\n\nstarwars %&gt;% \n  select(species:last_col())\n\n# A tibble: 87 × 4\n   species films     vehicles  starships\n   &lt;chr&gt;   &lt;list&gt;    &lt;list&gt;    &lt;list&gt;   \n 1 Human   &lt;chr [5]&gt; &lt;chr [2]&gt; &lt;chr [2]&gt;\n 2 Droid   &lt;chr [6]&gt; &lt;chr [0]&gt; &lt;chr [0]&gt;\n 3 Droid   &lt;chr [7]&gt; &lt;chr [0]&gt; &lt;chr [0]&gt;\n 4 Human   &lt;chr [4]&gt; &lt;chr [0]&gt; &lt;chr [1]&gt;\n 5 Human   &lt;chr [5]&gt; &lt;chr [1]&gt; &lt;chr [0]&gt;\n 6 Human   &lt;chr [3]&gt; &lt;chr [0]&gt; &lt;chr [0]&gt;\n 7 Human   &lt;chr [3]&gt; &lt;chr [0]&gt; &lt;chr [0]&gt;\n...\n\n\nOther helpers select variables by matching patterns in their names:\n\nstarts_with(): Starts with a prefix.\nends_with(): Ends with a suffix.\ncontains(): Contains a literal string.\nmatches(): Matches a regular expression.\n\nselect columns that start with an s\n\nstarwars %&gt;% \n  select(starts_with('s'))\n\n# A tibble: 87 × 4\n   skin_color  sex    species starships\n   &lt;chr&gt;       &lt;chr&gt;  &lt;chr&gt;   &lt;list&gt;   \n 1 fair        male   Human   &lt;chr [2]&gt;\n 2 gold        none   Droid   &lt;chr [0]&gt;\n 3 white, blue none   Droid   &lt;chr [0]&gt;\n 4 white       male   Human   &lt;chr [1]&gt;\n 5 light       female Human   &lt;chr [0]&gt;\n 6 light       male   Human   &lt;chr [0]&gt;\n 7 light       female Human   &lt;chr [0]&gt;\n...\n\n\nselect columns that end with color\n\nselect(starwars , ends_with('color'))\n\n# A tibble: 87 × 3\n   hair_color    skin_color  eye_color\n   &lt;chr&gt;         &lt;chr&gt;       &lt;chr&gt;    \n 1 blond         fair        blue     \n 2 &lt;NA&gt;          gold        yellow   \n 3 &lt;NA&gt;          white, blue red      \n 4 none          white       yellow   \n 5 brown         light       brown    \n 6 brown, grey   light       blue     \n 7 brown         light       blue     \n...\n\n\nselect columns that contain y\n\nselect(starwars, contains('y'))\n\n# A tibble: 87 × 2\n   eye_color birth_year\n   &lt;chr&gt;          &lt;dbl&gt;\n 1 blue            19  \n 2 yellow         112  \n 3 red             33  \n 4 yellow          41.9\n 5 brown           19  \n 6 blue            52  \n 7 blue            47  \n...\n\n\nWe can also select using a predicate function. ie select columns that satisfy a given condition.\n\nwhere(): Applies a function to all variables and selects those for which the function returns TRUE.\n\nselect numeric columns\n\nstarwars %&gt;% \n  select(where(is.numeric)) # select only numeric variables\n\n# A tibble: 87 × 3\n   height  mass birth_year\n    &lt;int&gt; &lt;dbl&gt;      &lt;dbl&gt;\n 1    172    77       19  \n 2    167    75      112  \n 3     96    32       33  \n 4    202   136       41.9\n 5    150    49       19  \n 6    178   120       52  \n 7    165    75       47  \n...\n\n\nselect columns that are lists\n\nselect(starwars, where(is.list))\n\n# A tibble: 87 × 3\n   films     vehicles  starships\n   &lt;list&gt;    &lt;list&gt;    &lt;list&gt;   \n 1 &lt;chr [5]&gt; &lt;chr [2]&gt; &lt;chr [2]&gt;\n 2 &lt;chr [6]&gt; &lt;chr [0]&gt; &lt;chr [0]&gt;\n 3 &lt;chr [7]&gt; &lt;chr [0]&gt; &lt;chr [0]&gt;\n 4 &lt;chr [4]&gt; &lt;chr [0]&gt; &lt;chr [1]&gt;\n 5 &lt;chr [5]&gt; &lt;chr [1]&gt; &lt;chr [0]&gt;\n 6 &lt;chr [3]&gt; &lt;chr [0]&gt; &lt;chr [0]&gt;\n 7 &lt;chr [3]&gt; &lt;chr [0]&gt; &lt;chr [0]&gt;\n...\n\n\nselect columns that contain atleast one NA\n\nselect(starwars , where(~any(is.na(.x))))\n\n# A tibble: 87 × 8\n   height  mass hair_color    birth_year sex    gender    homeworld species\n    &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;              &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;  \n 1    172    77 blond               19   male   masculine Tatooine  Human  \n 2    167    75 &lt;NA&gt;               112   none   masculine Tatooine  Droid  \n 3     96    32 &lt;NA&gt;                33   none   masculine Naboo     Droid  \n 4    202   136 none                41.9 male   masculine Tatooine  Human  \n 5    150    49 brown               19   female feminine  Alderaan  Human  \n 6    178   120 brown, grey         52   male   masculine Tatooine  Human  \n 7    165    75 brown               47   female feminine  Tatooine  Human  \n...\n\n\nNote that a predicate function must be a function that returns either TRUE or FALSE regardless of the input. the length of the output must be 1.\nRun ?dplyr::select to learn more of the selection methods."
  },
  {
    "objectID": "tidyverse.html#filter-rows-with-filter",
    "href": "tidyverse.html#filter-rows-with-filter",
    "title": "tidyverse",
    "section": "Filter rows with filter",
    "text": "Filter rows with filter\nThis is used to obtain a subset of the observations in the dataset. It enables us to keep/retain rows that satisfy desired condition(s).\nTo be retained, the row must produce a value of TRUE for all conditions. Note that when a condition evaluates to NA the row will be dropped, unlike base subsetting with [.\nfilter rows where species ie equal to \"Human\"\n\nfilter(starwars, species == \"Human\")\n\n# A tibble: 35 × 14\n   name     height  mass hair_color skin_color eye_color birth_year sex   gender\n   &lt;chr&gt;     &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; \n 1 Luke Sk…    172    77 blond      fair       blue            19   male  mascu…\n 2 Darth V…    202   136 none       white      yellow          41.9 male  mascu…\n 3 Leia Or…    150    49 brown      light      brown           19   fema… femin…\n 4 Owen La…    178   120 brown, gr… light      blue            52   male  mascu…\n 5 Beru Wh…    165    75 brown      light      blue            47   fema… femin…\n 6 Biggs D…    183    84 black      light      brown           24   male  mascu…\n 7 Obi-Wan…    182    77 auburn, w… fair       blue-gray       57   male  mascu…\n...\n\n\nfilter rows where mass is greater than 1000\n\nfilter(starwars, mass &gt; 1000)\n\n# A tibble: 1 × 14\n  name      height  mass hair_color skin_color eye_color birth_year sex   gender\n  &lt;chr&gt;      &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; \n1 Jabba De…    175  1358 &lt;NA&gt;       green-tan… orange           600 herm… mascu…\n# ℹ 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;,\n#   vehicles &lt;list&gt;, starships &lt;list&gt;\n\n\nfilters rows where mass is greater than the global average:\n\nstarwars %&gt;% filter(mass &gt; mean(mass, na.rm = TRUE))\n\n# A tibble: 10 × 14\n   name     height  mass hair_color skin_color eye_color birth_year sex   gender\n   &lt;chr&gt;     &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; \n 1 Darth V…    202   136 none       white      yellow          41.9 male  mascu…\n 2 Owen La…    178   120 brown, gr… light      blue            52   male  mascu…\n 3 Chewbac…    228   112 brown      unknown    blue           200   male  mascu…\n 4 Jabba D…    175  1358 &lt;NA&gt;       green-tan… orange         600   herm… mascu…\n 5 Jek Ton…    180   110 brown      fair       blue            NA   male  mascu…\n 6 IG-88       200   140 none       metal      red             15   none  mascu…\n 7 Bossk       190   113 none       green      red             53   male  mascu…\n...\n\n\nfiltering by multiple criteria within a single logical expression\n\nfilter(starwars, hair_color == \"none\" & eye_color == \"black\")\n\n# A tibble: 9 × 14\n  name      height  mass hair_color skin_color eye_color birth_year sex   gender\n  &lt;chr&gt;      &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; \n1 Nien Nunb    160    68 none       grey       black             NA male  mascu…\n2 Gasgano      122    NA none       white, bl… black             NA male  mascu…\n3 Kit Fisto    196    87 none       green      black             NA male  mascu…\n4 Plo Koon     188    80 none       orange     black             22 male  mascu…\n5 Lama Su      229    88 none       grey       black             NA male  mascu…\n6 Taun We      213    NA none       grey       black             NA fema… femin…\n7 Shaak Ti     178    57 none       red, blue… black             NA fema… femin…\n...\n\nfilter(starwars, hair_color == \"none\" | eye_color == \"black\")\n\n# A tibble: 38 × 14\n   name     height  mass hair_color skin_color eye_color birth_year sex   gender\n   &lt;chr&gt;     &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; \n 1 Darth V…    202   136 none       white      yellow          41.9 male  mascu…\n 2 Greedo      173    74 &lt;NA&gt;       green      black           44   male  mascu…\n 3 IG-88       200   140 none       metal      red             15   none  mascu…\n 4 Bossk       190   113 none       green      red             53   male  mascu…\n 5 Lobot       175    79 none       light      blue            37   male  mascu…\n 6 Ackbar      180    83 none       brown mot… orange          41   male  mascu…\n 7 Nien Nu…    160    68 none       grey       black           NA   male  mascu…\n...\n\n# When multiple expressions are used, they are combined using &\nfilter(starwars, hair_color == \"none\", eye_color == \"black\")\n\n# A tibble: 9 × 14\n  name      height  mass hair_color skin_color eye_color birth_year sex   gender\n  &lt;chr&gt;      &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; \n1 Nien Nunb    160    68 none       grey       black             NA male  mascu…\n2 Gasgano      122    NA none       white, bl… black             NA male  mascu…\n3 Kit Fisto    196    87 none       green      black             NA male  mascu…\n4 Plo Koon     188    80 none       orange     black             22 male  mascu…\n5 Lama Su      229    88 none       grey       black             NA male  mascu…\n6 Taun We      213    NA none       grey       black             NA fema… femin…\n7 Shaak Ti     178    57 none       red, blue… black             NA fema… femin…\n...\n\n\nselect the numeric variables and filter if any of the variables have NA. ie The result should contain at least 1 NA per observation/row:\n\nstarwars %&gt;% \n  select(where(is.numeric)) %&gt;% \n  filter(if_any(everything(), is.na))\n\n# A tibble: 51 × 3\n   height  mass birth_year\n    &lt;int&gt; &lt;dbl&gt;      &lt;dbl&gt;\n 1     97    32         NA\n 2    180    NA         64\n 3    180   110         NA\n 4    150    NA         48\n 5     NA    NA         NA\n 6    160    68         NA\n 7    191    90         NA\n...\n\n\nselect the numeric variables and filter if all of the numeric variables have NA. ie the result should contain NA in all the variables:\n\nstarwars %&gt;% \n  select(where(is.numeric)) %&gt;% \n  filter(if_all(everything(), is.na))\n\n# A tibble: 6 × 3\n  height  mass birth_year\n   &lt;int&gt; &lt;dbl&gt;      &lt;dbl&gt;\n1     NA    NA         NA\n2     NA    NA         NA\n3     NA    NA         NA\n4     NA    NA         NA\n5     NA    NA         NA\n6     NA    NA         NA\n\n\nWell the above results is not useful. But the logic is helpful.\nNow filter if all numeric variables have NA. Note that you are not required to select. You just need to have same result as above with the other non-numeric columns included.\n\nstarwars %&gt;% \n  filter(if_all(where(is.numeric), is.na))\n\n# A tibble: 6 × 14\n  name      height  mass hair_color skin_color eye_color birth_year sex   gender\n  &lt;chr&gt;      &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; \n1 Arvel Cr…     NA    NA brown      fair       brown             NA male  mascu…\n2 Finn          NA    NA black      dark       dark              NA male  mascu…\n3 Rey           NA    NA brown      light      hazel             NA fema… femin…\n4 Poe Dame…     NA    NA brown      light      brown             NA male  mascu…\n5 BB8           NA    NA none       none       black             NA none  mascu…\n6 Captain …     NA    NA unknown    unknown    unknown           NA &lt;NA&gt;  &lt;NA&gt;  \n# ℹ 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;,\n...\n\n\nThis shows us the actors who’s all of the numeric information is missing.\nObtain actors who have all their numeric information above average. ie their mass is greater than the mean of mass, their height is greater than the mean of height, they are young ie year of birth is greater than the average year of birth,etc\nNotice that in this dataset, we only have 3 numeric variables and therefore we can easily do:\n\nstarwars %&gt;% \n  filter(mass &gt; mean(mass, na.rm =TRUE),\n         height &gt; mean(height, na.rm = TRUE),\n         birth_year &gt; mean(birth_year, na.rm = TRUE))%&gt;%\n  select(name)\n\n# A tibble: 2 × 1\n  name                 \n  &lt;chr&gt;                \n1 Chewbacca            \n2 Jabba Desilijic Tiure\n\n\nBut what if we had a lot of numeric variables? Note that the code above feels repetitive. W e could use if_all\n\nstarwars %&gt;% \n  filter(if_all(where(is.numeric), ~.x &gt; mean(.x, na.rm = TRUE)))%&gt;%\n  select(name)\n\n# A tibble: 2 × 1\n  name                 \n  &lt;chr&gt;                \n1 Chewbacca            \n2 Jabba Desilijic Tiure\n\n\nWe introduced two functions: if_any and if_all. They both take in the columns selected, and the function to be performed on each of the columns, then they combine the results to a single column using either | for if_any or & for if_all\nMore example:\n\nFrom the iris dataset, select/filter rows whereby both the Petal.Width and the Sepal.Width are greater than or equal to 2.5\n\niris %&gt;%\n   filter(if_all(c(Petal.Width, Sepal.Width), ~ . &gt;= 2.5))\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\n1          6.3         3.3          6.0         2.5 virginica\n2          7.2         3.6          6.1         2.5 virginica\n3          6.7         3.3          5.7         2.5 virginica\n\n\nNotice that for the above example, each observation has petal width &gt;= 2.5 and sepal width&gt;=2.5\nThe question could have been rephrased as to filter rows whereby the columns that end in Width are greater than or equal to 2.5\n\niris %&gt;%\n  filter(if_all(ends_with(\"Width\"), ~ . &gt;= 2.5))\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\n1          6.3         3.3          6.0         2.5 virginica\n2          7.2         3.6          6.1         2.5 virginica\n3          6.7         3.3          5.7         2.5 virginica\n\n\nFrom the iris dataset, select/filter rows whereby any of the columns that end with Width is greater than 4\n\niris %&gt;%\n  filter(if_any(ends_with(\"Width\"), ~ . &gt; 4))\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.7         4.4          1.5         0.4  setosa\n2          5.2         4.1          1.5         0.1  setosa\n3          5.5         4.2          1.4         0.2  setosa\n\n\n\nUsing the starwars dataset obtain the tallest actor\n\nstarwars %&gt;% \n  filter(height == max(height, na.rm = TRUE))\n\n# A tibble: 1 × 14\n  name      height  mass hair_color skin_color eye_color birth_year sex   gender\n  &lt;chr&gt;      &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; \n1 Yarael P…    264    NA none       white      yellow            NA male  mascu…\n# ℹ 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;,\n#   vehicles &lt;list&gt;, starships &lt;list&gt;\n\n\nWhat about the shortest actor?\n\nstarwars %&gt;% \n  filter(height == min(height, na.rm = TRUE))\n\n# A tibble: 1 × 14\n  name  height  mass hair_color skin_color eye_color birth_year sex   gender   \n  &lt;chr&gt;  &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;    \n1 Yoda      66    17 white      green      brown            896 male  masculine\n# ℹ 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;,\n#   vehicles &lt;list&gt;, starships &lt;list&gt;\n\n\nThe notion of filtering the minimum and maximum is so common that dplyr provides functions slice_min and slice_max to do the same:\n\nslice_min(starwars, height)\n\n# A tibble: 1 × 14\n  name  height  mass hair_color skin_color eye_color birth_year sex   gender   \n  &lt;chr&gt;  &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;    \n1 Yoda      66    17 white      green      brown            896 male  masculine\n# ℹ 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;,\n#   vehicles &lt;list&gt;, starships &lt;list&gt;\n\nstarwars %&gt;% \n  slice_max(height)\n\n# A tibble: 1 × 14\n  name      height  mass hair_color skin_color eye_color birth_year sex   gender\n  &lt;chr&gt;      &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; \n1 Yarael P…    264    NA none       white      yellow            NA male  mascu…\n# ℹ 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;,\n#   vehicles &lt;list&gt;, starships &lt;list&gt;\n\n\nWe could also filter the youngest actor\n\nslice_max(starwars, birth_year)\n\n# A tibble: 1 × 14\n  name  height  mass hair_color skin_color eye_color birth_year sex   gender   \n  &lt;chr&gt;  &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;    \n1 Yoda      66    17 white      green      brown            896 male  masculine\n# ℹ 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;,\n#   vehicles &lt;list&gt;, starships &lt;list&gt;\n\n\nWhat if for every sex, we wanted to determine the shortest/tallest actor? we will use .by argument. and select the relevant columns to display, ie name,height and sex\n\nstarwars %&gt;%\n  filter(height == max(height, na.rm =TRUE), .by = sex) %&gt;%\n  select(name, height, sex)\n\n# A tibble: 6 × 3\n  name                  height sex           \n  &lt;chr&gt;                  &lt;int&gt; &lt;chr&gt;         \n1 Jabba Desilijic Tiure    175 hermaphroditic\n2 IG-88                    200 none          \n3 Ric Olié                 183 &lt;NA&gt;          \n4 Quarsh Panaka            183 &lt;NA&gt;          \n5 Yarael Poof              264 male          \n6 Taun We                  213 female        \n\n\nUsing the slice_max:\n\nstarwars %&gt;%\n  slice_max(height,by = sex)%&gt;%\n  select(name, height, sex)\n\n# A tibble: 6 × 3\n  name                  height sex           \n  &lt;chr&gt;                  &lt;int&gt; &lt;chr&gt;         \n1 Yarael Poof              264 male          \n2 IG-88                    200 none          \n3 Taun We                  213 female        \n4 Jabba Desilijic Tiure    175 hermaphroditic\n5 Ric Olié                 183 &lt;NA&gt;          \n6 Quarsh Panaka            183 &lt;NA&gt;          \n\n\nThis can also be accomplished using the group_by function:\n\nstarwars %&gt;%\n  group_by(sex) %&gt;% \n  filter(height == max(height, na.rm =TRUE)) %&gt;%\n  select(name, height, sex)\n\n# A tibble: 6 × 3\n# Groups:   sex [5]\n  name                  height sex           \n  &lt;chr&gt;                  &lt;int&gt; &lt;chr&gt;         \n1 Jabba Desilijic Tiure    175 hermaphroditic\n2 IG-88                    200 none          \n3 Ric Olié                 183 &lt;NA&gt;          \n4 Quarsh Panaka            183 &lt;NA&gt;          \n5 Yarael Poof              264 male          \n6 Taun We                  213 female        \n\n\nUsing iris dataset, select observation with the minimum sepal length within each species\n\niris %&gt;% \n  slice_min(Sepal.Length, by = Species)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width    Species\n1          4.3         3.0          1.1         0.1     setosa\n2          4.9         2.4          3.3         1.0 versicolor\n3          4.9         2.5          4.5         1.7  virginica\n\n\nWhat if we wanted the observations with the smallest and the second smallest sepal length within each species?\n\niris %&gt;% \n  slice_min(Sepal.Length, n = 2, by = Species, with_ties = FALSE)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width    Species\n1          4.3         3.0          1.1         0.1     setosa\n2          4.4         2.9          1.4         0.2     setosa\n3          4.9         2.4          3.3         1.0 versicolor\n4          5.0         2.0          3.5         1.0 versicolor\n5          4.9         2.5          4.5         1.7  virginica\n6          5.6         2.8          4.9         2.0  virginica\n\n\nNote: You cannot use both group_by and by/.by in one call. ie if the data is grouped, you cannot use by/.by\nRun ?dplyr::filter to learn more regarding data filtering."
  },
  {
    "objectID": "tidyverse.html#ordering-the-observations-using-arrange",
    "href": "tidyverse.html#ordering-the-observations-using-arrange",
    "title": "tidyverse",
    "section": "Ordering the observations using arrange",
    "text": "Ordering the observations using arrange\narrange() orders the rows of a data frame by the values of selected columns.\nUnlike other dplyr verbs, arrange() largely ignores grouping; you need to explicitly mention grouping variables (or use .by_group = TRUE) in order to group by them, and functions of variables are evaluated once per data frame, not once per group.\narrange trees dataset with descending volume value\n\ntrees %&gt;% \n  arrange(desc(Volume))\n\n   Girth Height Volume\n1   20.6     87   77.0\n2   17.9     80   58.3\n3   17.5     82   55.7\n4   17.3     81   55.4\n5   18.0     80   51.5\n6   18.0     80   51.0\n7   16.3     77   42.6\n8   16.0     72   38.3\n9   14.5     74   36.3\n...\n\n\n\narrange(mtcars, cyl, disp)\n\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nToyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nHonda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nFiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nFiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nLotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nDatsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nToyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nPorsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nVolvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n...\n\n\narrange by descending wt per cyl group\n\nmtcars %&gt;% \n  group_by(cyl) %&gt;% \n  arrange(desc(wt), .by_group = TRUE)\n\n# A tibble: 32 × 11\n# Groups:   cyl [3]\n     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1  24.4     4 147.     62  3.69  3.19  20       1     0     4     2\n 2  22.8     4 141.     95  3.92  3.15  22.9     1     0     4     2\n 3  21.4     4 121     109  4.11  2.78  18.6     1     1     4     2\n 4  21.5     4 120.     97  3.7   2.46  20.0     1     0     3     1\n 5  22.8     4 108      93  3.85  2.32  18.6     1     1     4     1\n 6  32.4     4  78.7    66  4.08  2.2   19.5     1     1     4     1\n...\n\n\nArrange the iris dataset in descending order of the variables that start with Sepal\n\nas_tibble(iris) %&gt;% \n  arrange(across(starts_with(\"Sepal\"), desc))\n\n# A tibble: 150 × 5\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species  \n          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;    \n 1          7.9         3.8          6.4         2   virginica\n 2          7.7         3.8          6.7         2.2 virginica\n 3          7.7         3            6.1         2.3 virginica\n 4          7.7         2.8          6.7         2   virginica\n 5          7.7         2.6          6.9         2.3 virginica\n 6          7.6         3            6.6         2.1 virginica\n 7          7.4         2.8          6.1         1.9 virginica\n..."
  },
  {
    "objectID": "tidyverse.html#adding-variables-using-mutate",
    "href": "tidyverse.html#adding-variables-using-mutate",
    "title": "tidyverse",
    "section": "Adding variables using mutate",
    "text": "Adding variables using mutate\nApart from selecting a subset of the data, we often also desire to add new variables to our existing data. The new variables often tend to be a function of the already existing variables. mutate() always adds new columns at the end of your dataset. You can always change the position where the variable is added.\nfirst select the name, height and mass. Compute height in inches(ie 2.54cm = 1 inch), mass in pounds (ie 1kg = 2.2lbs)\n\nstarwars %&gt;% \n  select(name, gender, height, mass) %&gt;% \n  mutate(height_inches = height/2.54, \n         mass_lbs = mass * 2.2)\n\n# A tibble: 87 × 6\n   name               gender    height  mass height_inches mass_lbs\n   &lt;chr&gt;              &lt;chr&gt;      &lt;int&gt; &lt;dbl&gt;         &lt;dbl&gt;    &lt;dbl&gt;\n 1 Luke Skywalker     masculine    172    77          67.7    169. \n 2 C-3PO              masculine    167    75          65.7    165  \n 3 R2-D2              masculine     96    32          37.8     70.4\n 4 Darth Vader        masculine    202   136          79.5    299. \n 5 Leia Organa        feminine     150    49          59.1    108. \n 6 Owen Lars          masculine    178   120          70.1    264  \n 7 Beru Whitesun lars feminine     165    75          65.0    165  \n...\n\n\nUsing the iris dataset, scale the numeric variables. ie \\(\\frac{x - \\mu_x}{\\sigma_x}\\)\n\niris %&gt;%\n  mutate(across(where(is.numeric), ~(.x - mean(.x))/sd(.x)))\n\n    Sepal.Length Sepal.Width Petal.Length   Petal.Width    Species\n1    -0.89767388  1.01560199  -1.33575163 -1.3110521482     setosa\n2    -1.13920048 -0.13153881  -1.33575163 -1.3110521482     setosa\n3    -1.38072709  0.32731751  -1.39239929 -1.3110521482     setosa\n4    -1.50149039  0.09788935  -1.27910398 -1.3110521482     setosa\n5    -1.01843718  1.24503015  -1.33575163 -1.3110521482     setosa\n6    -0.53538397  1.93331463  -1.16580868 -1.0486667950     setosa\n7    -1.50149039  0.78617383  -1.33575163 -1.1798594716     setosa\n8    -1.01843718  0.78617383  -1.27910398 -1.3110521482     setosa\n9    -1.74301699 -0.36096697  -1.33575163 -1.3110521482     setosa\n...\n\n\nNote that the code looks almost similar to using filter +if_any/if_all. Instead, we used mutate + across While if_any/if_all combined the logical columns to generate 1 logical vector, across does not combine the results of the vectors. Also the function passed to across does not have to be a logical function.\nBy default, mutate() keeps all columns from the input data.\n\ndf &lt;- tibble(x = 1, y = 2, a = \"a\", b = \"b\")\ndf %&gt;% mutate(z = x + y, .keep = \"all\") # the default\n\n# A tibble: 1 × 5\n      x     y a     b         z\n  &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1     2 a     b         3\n\ndf %&gt;% mutate(z = x + y, .keep = \"used\")\n\n# A tibble: 1 × 3\n      x     y     z\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1     1     2     3\n\ndf %&gt;% mutate(z = x + y, .keep = \"unused\")\n\n# A tibble: 1 × 3\n  a     b         z\n  &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt;\n1 a     b         3\n\ndf %&gt;% mutate(z = x + y, .keep = \"none\")\n\n# A tibble: 1 × 1\n      z\n  &lt;dbl&gt;\n1     3\n\n\nBy default, mutate adds the new column at the end\n\ndf %&gt;% mutate(z = x + y)\n\n# A tibble: 1 × 5\n      x     y a     b         z\n  &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1     2 a     b         3\n\ndf %&gt;% mutate(z = x + y, .before = x)\n\n# A tibble: 1 × 5\n      z     x     y a     b    \n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;\n1     3     1     2 a     b    \n\ndf %&gt;% mutate(z = x + y, .after = x)\n\n# A tibble: 1 × 5\n      x     z     y a     b    \n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;\n1     1     3     2 a     b    \n\n\nNow scale the iris data within each species:\n\niris %&gt;% \n  group_by(Species) %&gt;% \n  mutate(across(everything(), ~(.x - mean(.))/sd(.)))\n\n# A tibble: 150 × 5\n# Groups:   Species [3]\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;  \n 1       0.267       0.190        -0.357      -0.436 setosa \n 2      -0.301      -1.13         -0.357      -0.436 setosa \n 3      -0.868      -0.601        -0.933      -0.436 setosa \n 4      -1.15       -0.865         0.219      -0.436 setosa \n 5      -0.0170      0.454        -0.357      -0.436 setosa \n 6       1.12        1.25          1.37        1.46  setosa \n...\n\n\nWhy use everything(). Since Species has been taken to be the grouping column, we can use everything() to refer to all the columns apart from Species\nThis is equivalent to\n\niris %&gt;% \n  mutate(across(everything(), ~(.x - mean(.))/sd(.)), .by = Species)\n\n    Sepal.Length Sepal.Width Petal.Length Petal.Width    Species\n1     0.26667447  0.18994136  -0.35701125 -0.43649232     setosa\n2    -0.30071802 -1.12909583  -0.35701125 -0.43649232     setosa\n3    -0.86811050 -0.60148096  -0.93283584 -0.43649232     setosa\n4    -1.15180675 -0.86528840   0.21881335 -0.43649232     setosa\n5    -0.01702177  0.45374879  -0.35701125 -0.43649232     setosa\n6     1.11776320  1.24517111   1.37046253  1.46130036     setosa\n7    -1.15180675 -0.07386608  -0.35701125  0.51240402     setosa\n8    -0.01702177 -0.07386608   0.21881335 -0.43649232     setosa\n9    -1.71919923 -1.39290327  -0.35701125 -0.43649232     setosa\n...\n\n\nwhat if we wanted to have the new columns together with the original columns? We use the .names parameter.\n\ntrees %&gt;%\n  mutate(across(everything(), log, .names = 'log_{col}'))\n\n   Girth Height Volume log_Girth log_Height log_Volume\n1    8.3     70   10.3  2.116256   4.248495   2.332144\n2    8.6     65   10.3  2.151762   4.174387   2.332144\n3    8.8     63   10.2  2.174752   4.143135   2.322388\n4   10.5     72   16.4  2.351375   4.276666   2.797281\n5   10.7     81   18.8  2.370244   4.394449   2.933857\n6   10.8     83   19.7  2.379546   4.418841   2.980619\n7   11.0     66   15.6  2.397895   4.189655   2.747271\n8   11.0     75   18.2  2.397895   4.317488   2.901422\n9   11.1     80   22.6  2.406945   4.382027   3.117950\n...\n\n\n\nUseful mutate functions\n\n+, -, log(), etc., for their usual mathematical meanings\nlead(), lag()\ndense_rank(), min_rank(), percent_rank(), row_number(), cume_dist(), ntile()\ncumsum(), cummean(), cummin(), cummax(), cumany(), cumall()\nna_if(), coalesce() replace_na\nif_else(), recode(), case_when()\nconsecutive_id()\n\nExample of using coalesce\nReplace the NA’s with the mean of the data within each sex category for the numeric data, and for the characters, replace the NA with the mode, ie most occurring value.\n\nstarwars %&gt;%\n  group_by(sex) %&gt;% \n  mutate(across(where(is.numeric), ~coalesce(.x, mean(.x, na.rm = TRUE))),\n        across(where(is.character), ~coalesce(.x,gtools::stat_mode(.x))))\n\n# A tibble: 87 × 14\n# Groups:   sex [5]\n   name     height  mass hair_color skin_color eye_color birth_year sex   gender\n   &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; \n 1 Luke Sk…    172    77 blond      fair       blue            19   male  mascu…\n 2 C-3PO       167    75 none       gold       yellow         112   none  mascu…\n 3 R2-D2        96    32 none       white, bl… red             33   none  mascu…\n 4 Darth V…    202   136 none       white      yellow          41.9 male  mascu…\n 5 Leia Or…    150    49 brown      light      brown           19   fema… femin…\n 6 Owen La…    178   120 brown, gr… light      blue            52   male  mascu…\n...\n\n\nCheck the reference page to get more information about the above functions."
  },
  {
    "objectID": "tidyverse.html#summarize-using-summarise",
    "href": "tidyverse.html#summarize-using-summarise",
    "title": "tidyverse",
    "section": "Summarize using summarise",
    "text": "Summarize using summarise\nWhile mutate adds a new column, summarize aggregates the data to produce aggregated results.\nGive the mean of the iris data\n\niris %&gt;%\n  summarise(across(-Species, mean))\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width\n1     5.843333    3.057333        3.758    1.199333\n\n\nGive the mean of the iris data per species\n\niris %&gt;%\n  summarise(across(everything(), mean), .by = Species)\n\n     Species Sepal.Length Sepal.Width Petal.Length Petal.Width\n1     setosa        5.006       3.428        1.462       0.246\n2 versicolor        5.936       2.770        4.260       1.326\n3  virginica        6.588       2.974        5.552       2.026\n\n\nGive the count of actors per sex in the starwars data\n\nstarwars %&gt;% \n  summarise(number = n(), .by = sex)\n\n# A tibble: 5 × 2\n  sex            number\n  &lt;chr&gt;           &lt;int&gt;\n1 male               60\n2 none                6\n3 female             16\n4 hermaphroditic      1\n5 &lt;NA&gt;                4\n\n\nNote the use of the n() function which gives the total number of observations per group.\nSince counting is a common task, there is a function written to do the tast:\n\nstarwars %&gt;% \n  count(sex)\n\n# A tibble: 5 × 2\n  sex                n\n  &lt;chr&gt;          &lt;int&gt;\n1 female            16\n2 hermaphroditic     1\n3 male              60\n4 none               6\n5 &lt;NA&gt;               4\n\n\nWith the notion of grouping and summarizing/mutating within each group, we can be able to run various models within the sub groups without using for-loops:\nrun linear regression model on the iris dataset for each species whereby the Sepal.Length is the response variable\n\niris %&gt;% \n  summarise(broom::tidy(lm(Sepal.Length~., cur_data())), .by = Species)\n\nWarning: There was 1 warning in `summarise()`.\nℹ In argument: `broom::tidy(lm(Sepal.Length ~ ., cur_data()))`.\nℹ In group 1: `Species = setosa`.\nCaused by warning:\n! `cur_data()` was deprecated in dplyr 1.1.0.\nℹ Please use `pick()` instead.\n\n\nWarning: Returning more (or less) than 1 row per `summarise()` group was deprecated in\ndplyr 1.1.0.\nℹ Please use `reframe()` instead.\nℹ When switching from `summarise()` to `reframe()`, remember that `reframe()`\n  always returns an ungrouped data frame and adjust accordingly.\n\n\n      Species         term   estimate  std.error  statistic      p.value\n1      setosa  (Intercept)  2.3518898 0.39286751  5.9864707 3.034183e-07\n2      setosa  Sepal.Width  0.6548350 0.09244742  7.0833236 6.834434e-09\n3      setosa Petal.Length  0.2375602 0.20801921  1.1420107 2.593594e-01\n4      setosa  Petal.Width  0.2521257 0.34686362  0.7268727 4.709870e-01\n5  versicolor  (Intercept)  1.8955395 0.50705524  3.7383295 5.112246e-04\n6  versicolor  Sepal.Width  0.3868576 0.20454490  1.8913091 6.488965e-02\n7  versicolor Petal.Length  0.9083370 0.16543248  5.4906811 1.666695e-06\n8  versicolor  Petal.Width -0.6792238 0.43538206 -1.5600639 1.255990e-01\n9   virginica  (Intercept)  0.6998830 0.53360089  1.3116227 1.961563e-01\n...\n\n\nNotice that we do get a warning claiming this use of summarise was deprecated. We therefore need to use the correct function ie reframe. Note reframe is similar to summarize with the difference being that reframe does output a dataframe back while summarise only has to output one value per column per group.\n\niris %&gt;% \n  reframe(broom::tidy(lm(Sepal.Length~., cur_data())), .by = Species)\n\n      Species         term   estimate  std.error  statistic      p.value\n1      setosa  (Intercept)  2.3518898 0.39286751  5.9864707 3.034183e-07\n2      setosa  Sepal.Width  0.6548350 0.09244742  7.0833236 6.834434e-09\n3      setosa Petal.Length  0.2375602 0.20801921  1.1420107 2.593594e-01\n4      setosa  Petal.Width  0.2521257 0.34686362  0.7268727 4.709870e-01\n5  versicolor  (Intercept)  1.8955395 0.50705524  3.7383295 5.112246e-04\n6  versicolor  Sepal.Width  0.3868576 0.20454490  1.8913091 6.488965e-02\n7  versicolor Petal.Length  0.9083370 0.16543248  5.4906811 1.666695e-06\n8  versicolor  Petal.Width -0.6792238 0.43538206 -1.5600639 1.255990e-01\n9   virginica  (Intercept)  0.6998830 0.53360089  1.3116227 1.961563e-01\n...\n\n\nTo compare with the setosa we could run:\n\nlm(Sepal.Length~Sepal.Width + Petal.Length + Petal.Width, iris, Species == 'setosa')\n\n\nCall:\nlm(formula = Sepal.Length ~ Sepal.Width + Petal.Length + Petal.Width, \n    data = iris, subset = Species == \"setosa\")\n\nCoefficients:\n (Intercept)   Sepal.Width  Petal.Length   Petal.Width  \n      2.3519        0.6548        0.2376        0.2521"
  },
  {
    "objectID": "tidyverse.html#exercise-2",
    "href": "tidyverse.html#exercise-2",
    "title": "tidyverse",
    "section": "Exercise:",
    "text": "Exercise:\n\nGiven data below, double numeric columns that do not contain missing values. [1]\n\ndf &lt;- tibble(x=1:10, y=101:110,\n             w=c(6,NA,4,NA, 5,0,NA,4,8,17 ),\n             z=c(2,3,4,NA, 5,10,22,34,58,7 ),\n             k=rep(\"A\",10))\n\nI’m attempting to reproduce the following code across 36 seperate columns in a df. So instead of having to retype this code 36 times, how can I write a function to apply this for all columns at once? Apply the code only to columns that begin with score [2]\ndf &lt;- df %&gt;% \n      mutate(percent_score_1 = (score_1 / 5) * 100,  \n            percent_score_2 = (score_2 / 5) * 100) \nThe data looks like this:\n   score_1   score_2    \n      2         3     \n      3         4    \n      5         1\nmutate [3]\nmutate [4]\nmutate [5]\nfilter: [6]\nfilter: [7]\nsummarise [8]"
  },
  {
    "objectID": "try1.html",
    "href": "try1.html",
    "title": "Kriging Based Sequential Region Shrinkage with EGO For Hyper-parameter Optimization",
    "section": "",
    "text": "This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see http://rmarkdown.rstudio.com.\nWhen you click the Knit button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:\n\nsummary(cars)\n\n     speed           dist       \n Min.   : 4.0   Min.   :  2.00  \n 1st Qu.:12.0   1st Qu.: 26.00  \n Median :15.0   Median : 36.00  \n Mean   :15.4   Mean   : 42.98  \n 3rd Qu.:19.0   3rd Qu.: 56.00  \n Max.   :25.0   Max.   :120.00"
  },
  {
    "objectID": "try1.html#r-markdown",
    "href": "try1.html#r-markdown",
    "title": "Kriging Based Sequential Region Shrinkage with EGO For Hyper-parameter Optimization",
    "section": "",
    "text": "This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see http://rmarkdown.rstudio.com.\nWhen you click the Knit button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:\n\nsummary(cars)\n\n     speed           dist       \n Min.   : 4.0   Min.   :  2.00  \n 1st Qu.:12.0   1st Qu.: 26.00  \n Median :15.0   Median : 36.00  \n Mean   :15.4   Mean   : 42.98  \n 3rd Qu.:19.0   3rd Qu.: 56.00  \n Max.   :25.0   Max.   :120.00"
  },
  {
    "objectID": "try1.html#including-plots",
    "href": "try1.html#including-plots",
    "title": "Kriging Based Sequential Region Shrinkage with EGO For Hyper-parameter Optimization",
    "section": "Including Plots",
    "text": "Including Plots\nYou can also embed plots, for example:\n\n\n\n\n\nNote that the echo = FALSE parameter was added to the code chunk to prevent printing of the R code that generated the plot.\n\nplot(1:10)\nplot(cars, pch = 19)\nboxplot(Sepal.Width ~ Species, data = iris)\n\n\n\n\n\n\nyuuurp\n\n\n\n\n\n\n\nwds\n\n\n\n\n\n\n\n\n\ntototo\n\n\n\n\nFigure 1\n\n\n\n\nFor mange Aar siden levede en Keiser, som holdt saa uhyre meget af\nsmukke nye Kl\\ae der, at han gav alle sine Penge ud for ret at blive\npyntet. Han br\\o d sig ikke om sine Soldater, br\\o d sig ei om\nComedie eller om at kj\\o re i Skoven, uden alene for at vise sine\nnye Kl\\ae der. Han havde en Kjole for hver Time paa Dagen, og\nligesom man siger om en Konge, han er i Raadet, saa sagde man altid\nher: &gt;&gt;Keiseren er i Garderoben!&lt;&lt;~--\nBlack box optimization is a fundamental problem in many fields, such as engineering, finance, and machine learning. The objective usually, is to find the optimal solution of a complex function that is expensive or impossible to evaluate analytically. \\[\nx^* = \\underset{x\\in A}{\\arg\\min f(x)}\n\\] where \\(A\\) denotes the search space of \\(x\\).\\ The optimization of \\(f(x)\\) is a non-trivial task. There are two main methods that are used: (a) derivative-based optimization methods and (b) derivative-free optimization methods. Derivative-based methods require the computation of the derivatives of the objective function. They are typically used when \\(f(x)\\) is smooth and well-behaved and the derivatives are tractable. On the other hand derivative-free methods are invoked when the function is unknown or when the derivatives are intractable or computationally infeasible to compute. As the black-box functions are usually unknown, often the derivative free based approaches are used to optimize them. The Hyperparameter Optimization (HPO) lies in this category.\\\\ In HPO, the task involves choosing a set of optimal hyperparameters for a learning algorithm. The performance of these algorithms highly depends on these chosen hyperparameter configurations and may flactuate drastically under different architectures. Hyperparameters are the parameters of a model that control the model’s behavior that are set before training. They include the learning rate, regularization method, optimization algorithm chosen etc. Currently, there are several methods for HPO. The mainly used ones are grid search, random search , and Bayesian optimization . Grid search involves specifying a set of hyperparameters and evaluating the model’s performance for each combination of hyperparameters in a grid then choosing the configuration that yields the best function evaluation. Random search involves randomly sampling hyperparameters from a predefined distribution with a predefined domain and evaluating the model’s performance for each set of hyperparameters then selecting the best configuration. Bayesian optimization involves iteratively constructing a probabilistic model of the objective function by combining the prior distribution of \\(f(x)\\) with the sample information to obtain the posterior function; which is then optimized according to a chosen acquisition function to obtain the next set of hyperparameters. These is repeated until no further improvement can be done and the final set of configuration is taken to be the optimal setting."
  },
  {
    "objectID": "vector.html",
    "href": "vector.html",
    "title": "Vectors",
    "section": "",
    "text": "A vector is substantially a list that contains elements of the same kind. There are two types of vectors, Atomic Vectors and Generic Vectors. We will first talk of those that are one dimensional and atomic. By atomic we mean that the elements within the vector cannot by themselves hold other elements. Due to the simplicity structure, we can manipulate all the elements within a vector simultaneously."
  },
  {
    "objectID": "vector.html#vector-creation",
    "href": "vector.html#vector-creation",
    "title": "Vectors",
    "section": "Vector Creation",
    "text": "Vector Creation\nDifferent functions have been provided in R to be able to create vector. The most common function is the c function which is used for concatenation. Eg To create a vector that contains the elements 1 to 5, we could do the following.\n\nc(1, 2, 3, 4, 5)\n\n[1] 1 2 3 4 5\n\nc(10, 100, 20, -4)\n\n[1]  10 100  20  -4\n\nc(2, 2, 2)\n\n[1] 2 2 2\n\n\nAt times we need to generate a sequence of numbers. The : operator is used for this task.\n\n1:5\n\n[1] 1 2 3 4 5\n\n0.1:5.1\n\n[1] 0.1 1.1 2.1 3.1 4.1 5.1\n\n\nNotice that the sequence has an increment of 1. This is too restrictive. What if we need a sequence with increment of say 2 or even 0.2? We then use the function seq.\n\nseq(10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nseq(1, 10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nseq(1, 2, 0.1)\n\n [1] 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0\n\nseq(1, 2, length.out = 11)\n\n [1] 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0\n\nseq(c(1,4,6,8,-2))\n\n[1] 1 2 3 4 5\n\nsequence(1:3)\n\n[1] 1 1 2 1 2 3\n\n\nOther vector functions include rep for repetition and length to determine the length.\nExamples:\n\nrep(2, 4)\n\n[1] 2 2 2 2\n\nrep(c(2,3), 4)\n\n[1] 2 3 2 3 2 3 2 3\n\nrep(c(2,3), each = 4)\n\n[1] 2 2 2 2 3 3 3 3\n\nrep(c(2,3), c(4,4))\n\n[1] 2 2 2 2 3 3 3 3\n\n\nWith vectors, we can easily carry out arithmetic manipulations for each element simultaneously. That is because most of R’s functions are VECTORIZED, meaning that the function will operate on all elements of a vector without needing to loop through and act on each element one at a time. This makes writing code more concise, easy to read, and less error prone.\n\nc(1,2,3) + c(6,7,8)\n\n[1]  7  9 11\n\nlog(c(-4, 10, 6, 8))\n\nWarning in log(c(-4, 10, 6, 8)): NaNs produced\n\n\n[1]      NaN 2.302585 1.791759 2.079442\n\n\nNotice that log(-4) produced NaN while the others gave results. This shows that the computation of rest do not depend on the one with a warning. Also, NaN is a numeric variable that stands for not a number."
  },
  {
    "objectID": "vector.html#vector-recycling",
    "href": "vector.html#vector-recycling",
    "title": "Vectors",
    "section": "Vector Recycling",
    "text": "Vector Recycling\nWe can see vector recycling, when we perform some kind of operations like addition, subtraction. . . .etc on two vectors of unequal length. The vector with a small length will be repeated as long as the operation completes on the longer vector. If we perform an addition operation on a vector of equal length the first value of vector1 is added with the first value of vector 2 like that. So, the repetition of small length vector as long as completion of operation on long length vector is known as vector recycling. This is the special property of vectors is available in R language. Let us see the implementation of vector recycling.\n\n# creating vector with\n# 1 to 6 values\nvec1 &lt;- 1:6\n\n# creating vector with 1:2\n# values\nvec2 &lt;- 1:2\n\n# adding vector1 and vector2\nprint(vec1 + vec2)\n\n[1] 2 4 4 6 6 8\n\n\nIn vector recycling, the length of the long length vector should be the multiple of the length of a small length vector. If not we will get a warning that longer object length is not a multiple of shorter object length. Here the longer object length is multiple of the shortest object length. So, we didn’t get a warning message.\n\n# creating vector with 10 to 14 values\nvec1 &lt;- 10:14\n\n# creating vector with 3 to 5 values\nvec2 &lt;- 3:5\n\n# adding vector1 and vector2\nprint(vec1 + vec2)\n\nWarning in vec1 + vec2: longer object length is not a multiple of shorter\nobject length\n\n\n[1] 13 15 17 16 18\n\n\nThe notion of vector recycling is the main idea behind R programming language."
  },
  {
    "objectID": "vector.html#vector-manipulation",
    "href": "vector.html#vector-manipulation",
    "title": "Vectors",
    "section": "Vector Manipulation",
    "text": "Vector Manipulation\n\nvec1 &lt;- c(-3,-2,-2,-1,-1,1,2,3,3)\n\nlength of vector:\n\nlength(vec1)\n\n[1] 9\n\n\nAbsolute value for each element of the vector\n\nabs(vec1)\n\n[1] 3 2 2 1 1 1 2 3 3\n\n\nsum all the elements in the vector\n\nsum(vec1)\n\n[1] 0\n\n\nmean of all the elements in the vector\n\nmean(vec1)\n\n[1] 0\n\n\nmedian of all the elements in the vector\n\nmedian(vec1)\n\n[1] -1\n\n\nminimum of all the elements in the vector\n\nmin(vec1)\n\n[1] -3\n\n\nPosition of the minimum in the vector\n\nwhich.min(vec1)\n\n[1] 1\n\n\nmaximum value of all the elements in the vector\n\nmax(vec1)\n\n[1] 3\n\n\nPosition of the maximum in the vector\n\nwhich.max(vec1)\n\n[1] 8\n\n\nvariance\n\nvar(vec1)\n\n[1] 5.25\n\n\nstandard deviation\n\nsd(vec1)\n\n[1] 2.291288\n\n\ncovariance between vec1 and vec1\n\ncov(vec1, vec1)\n\n[1] 5.25\n\n\ncorrelation\n\ncor(vec1, vec1)\n\n[1] 1\n\n\nfrequency table of the values in the vector\n\ntable(vec1)\n\nvec1\n-3 -2 -1  1  2  3 \n 1  2  2  1  1  2 \n\n\nSorting the vector in ascending order\n\nsort(vec1)\n\n[1] -3 -2 -2 -1 -1  1  2  3  3\n\n\nsorting the vector in descending order\n\nsort(vec1, decreasing = TRUE)\n\n[1]  3  3  2  1 -1 -1 -2 -2 -3\n\n\nranking the vector\n\nrank(vec1)\n\n[1] 1.0 2.5 2.5 4.5 4.5 6.0 7.0 8.5 8.5\n\n\nranking vector and in case of ties, we take the minimum rank\n\nrank(vec1,ties.method = 'min')\n\n[1] 1 2 2 4 4 6 7 8 8\n\n\nThe position each element would take if the vector was to be sorted\n\norder(vec1)\n\n[1] 1 2 3 4 5 6 7 8 9\n\n\nPosition that satisfy a condition:\n\nwhich(vec1&gt;=3) # Indices of vector 1 where it is greater than 3\n\n[1] 8 9\n\n\nFirst difference: The difference between the current valueand the previous value for all the elements in a vector\n\ndiff(vec1)\n\n[1] 1 0 1 0 2 1 1 0\n\n\nThe unique values of a vector\n\nunique(vec1)\n\n[1] -3 -2 -1  1  2  3\n\n\nReturn a logical value if it is duplicated\n\nduplicated(vec1)\n\n[1] FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE\n\n\nAre all the values in the vector positive ie all greater than 0?\n\nall(vec1&gt;0)\n\n[1] FALSE\n\n\nIs any of the values in the vector greater than 0?\n\nany(vec1&gt;0)\n\n[1] TRUE\n\n\nLet us do some matching:\n\nvec2 &lt;- c(5,-2,-1,1,3,-3,7)\n\nTo obtain the position of elements of vec1 inside vec2\n\nmatch(vec1, vec2) #Position of vec1 in vec2. Why NA?\n\n[1]  6  2  2  3  3  4 NA  5  5\n\n\nEnsure any element in vec1 that is not in vec2 to be given position value 0\n\nmatch(vec1, vec2, 0)\n\n[1] 6 2 2 3 3 4 0 5 5\n\n\nWhich values in vec1 are in vec2?\n\nvec1 %in% vec2\n\n[1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE\n\nmatch(vec1, vec2, 0) &gt; 0\n\n[1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE\n\n\nWhich values in vec2 are in vec1?\n\nvec2 %in% vec1\n\n[1] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n\n\ninner product\n\nvec1 %*% vec1\n\n     [,1]\n[1,]   42\n\nsum(vec1^2)\n\n[1] 42\n\n\neuclidean norm/ magnitude of a vector\n\nsqrt(sum(vec1^2))\n\n[1] 6.480741\n\nsqrt(vec1 %*% vec1)\n\n         [,1]\n[1,] 6.480741\n\nnorm(vec1, '2')\n\n[1] 6.480741\n\n\nElement-wise minimum and maximum\n\npmin(-3:3, 0)\n\n[1] -3 -2 -1  0  0  0  0\n\npmin(c(1,3,5,10), c(-1,4,3,11)) \n\n[1] -1  3  3 10\n\npmax(c(1,3,5,10), c(-1,4,3,11))\n\n[1]  1  4  5 11\n\n\nNeed more functions? - we shall discuss this in class\n\nfindInterval(vec1, c(-2,0,2))\n\n[1] 0 1 1 1 1 2 3 3 3"
  },
  {
    "objectID": "vector.html#vector-attributes",
    "href": "vector.html#vector-attributes",
    "title": "Vectors",
    "section": "Vector Attributes",
    "text": "Vector Attributes\nIn computing, an attribute is defined as a piece of information which determines the properties of a field or tag in a database or a string of characters in a display. This is quite a lot of jargon. As for now, understand an attribute to be an extra information contained within an object. This information is not the main information, but rather the object carries it along and it gives more description to the object itself. NB: So far we have not tackled what an object is. In this lesson, take a vector to be the object.\nThe common attribute that a vector can posses is the element names. That is each element in the vector can contain a name. Lets look at the example below.\n\nvec3 &lt;- c(a = 1, b = 3, c = 5)\nvec3\n\na b c \n1 3 5 \n\n\nThe first element of the vector above is named as a while the last element is d. These names are NOT the values of the vector. The vector still has the values 1, 3, 5 and in addition each element is named.\nNotice that we can still do math manipulation on the vector as the values are numeric:\n\nvec3 * 5\n\n a  b  c \n 5 15 25 \n\n\nHow can we access the names? By using the names function:\n\nnames(vec3)\n\n[1] \"a\" \"b\" \"c\"\n\n\nIt is also possible to set the names to a vector that does not contain names:\n\nvec_4 &lt;- c(1, 3, 5)\nnames(vec_4) &lt;- c(\"a\", \"b\", \"c\")\nvec_4\n\na b c \n1 3 5 \n\n\nTo remove the names, we simply set the names to NULL\n\nnames(vec_4) &lt;- NULL\nvec_4\n\n[1] 1 3 5\n\n\nOf course we can add attributes to a vector by using the attr or the attributes functions.\n\npoint &lt;- c(3,4,5)\nattr(point, 'names') &lt;- c('a', 'b', 'c')\npoint\n\na b c \n3 4 5 \n\n\nNotice that R realized the metadata we added and printed the information accordingly.\nSometimes we need to add metadata that is not recognized by R. For example, assume we are calculating the value of a function but at the same time need the gradient score at that particular point. We could save this extra information as an attribute.\n\npoint &lt;- c(3,4,5)\nattr(point, 'gradient') &lt;- 10\npoint\n\n[1] 3 4 5\nattr(,\"gradient\")\n[1] 10\n\n\nMore information on this later."
  },
  {
    "objectID": "vector.html#vector-sub-setting",
    "href": "vector.html#vector-sub-setting",
    "title": "Vectors",
    "section": "Vector Sub-setting",
    "text": "Vector Sub-setting\nThis is the process of extracting components/elements from the vector to obtain a smaller vector. Notice that in R, an atomic object of length 1 is still considered a vector of length 1.\nTo accomplish this, we use the extracting functions. ie [ or [[ or even getElement, together with either the element position or name in case where the elements contain names.\n\nUsing Position and Names\n\nvec3 &lt;- c(a = 1, b = 3, c = 5, d = NA) # d is a missing value\nvec3[1] #Get the first element\n\na \n1 \n\nvec3['a'] #Get element named a\n\na \n1 \n\nvec3[-2] #remove the second element\n\n a  c  d \n 1  5 NA \n\nvec3[-c(2,4)]\n\na c \n1 5 \n\ngetElement(vec3, 'b')\n\n[1] 3\n\ngetElement(vec3, 2)\n\n[1] 3\n\nvec3[vec3&gt;3]\n\n   c &lt;NA&gt; \n   5   NA \n\nvec3[vec3&lt;=2]\n\n   a &lt;NA&gt; \n   1   NA \n\nvec3[vec3&gt;6]\n\n&lt;NA&gt; \n  NA \n\nvec3[!is.na(vec3)]\n\na b c \n1 3 5 \n\nna.omit(vec3)\n\na b c \n1 3 5 \nattr(,\"na.action\")\nd \n4 \nattr(,\"class\")\n[1] \"omit\"\n\n\nVec3 above contains a missing value represented by NA. Notice that I do not have quotes around NA as it is a special value in R.\nHow would I compute sum of vec3?\n\nsum(vec3)\n\n[1] NA\n\nsum(na.omit(vec3))\n\n[1] 9\n\nsum(vec3, na.rm = TRUE)\n\n[1] 9\n\nmax(vec3, na.rm = TRUE)\n\n[1] 5\n\n\nNote that the getElement function was introduced recently and does not support extracting more than one elements.\nFor vectors, the [[ is used when you desire to drop the attributes. eg Notice the difference between the following two commands\n\nvec3[1]\n\na \n1 \n\nvec3[[1]]\n\n[1] 1\n\n\nor even\n\nvec3[['a']]\n\n[1] 1\n\n\nThe extraction functions can also be used to replace values in a vector\n\nvec3 # Remind ourselves what vec3 is\n\n a  b  c  d \n 1  3  5 NA \n\nvec3[3] &lt;- 10\nvec3['c'] &lt;- 5\n\nWhat happens if you use a position that does not exist?\n\nvec3[-10]\n\n a  b  c  d \n 1  3  5 NA \n\nvec3[0]\n\nnamed numeric(0)\n\n\nReplace many at once\n\nindex &lt;- vec3&gt;1 & !is.na(vec3)\nvec3[index] &lt;- vec3[index] + 10\nvec3\n\n a  b  c  d \n 1 13 15 NA"
  },
  {
    "objectID": "vector.html#advanced-vector-functions",
    "href": "vector.html#advanced-vector-functions",
    "title": "Vectors",
    "section": "Advanced vector functions",
    "text": "Advanced vector functions\nSuppose 5 exams were taken by 2 students. The score of the exams are 98,90,70,92,87. Suppose you have a second vector which contains the student who did the exam, ie 1,2,1,1,2 whereby student 1 scored grades 98,70,92 and student 2 scored the grades 90,87. How can we find the mean for each student? what about the sum? sd?max? etc.\nThis is considered as grouping of data. Many functions can be used to manipulate this. The well known one is tapply:\ntapply(your_vector, grouping_vector, your_function)\n\nmarks &lt;- c(98,90,70,92,87)\nstudent &lt;- c(1,2,1,1,2)\ntapply(marks, student, mean)\n\n       1        2 \n86.66667 88.50000 \n\ntapply(marks, student, max)\n\n 1  2 \n98 90 \n\n\nSuppose we wanted to replace the values with their average instead of only computing the means?\nOne way we could do that is get the students, match them against their grade means then replace:\n\nmarks &lt;- c(98,90,70,92,87)\nstudent &lt;- c(1,2,1,1,2)\nmeans &lt;- tapply(marks, student, mean)\nmeans[student]\n\n       1        2        1        1        2 \n86.66667 88.50000 86.66667 86.66667 88.50000 \n\n\nAt the same time we could use a function known as ave:\n\nmarks &lt;- c(98,90,70,92,87)\nstudent &lt;- c(1,2,1,1,2)\nave(marks, student)\n\n[1] 86.66667 88.50000 86.66667 86.66667 88.50000\n\n\nWhat about if there was an NA how would you approach that?\n\nmarks &lt;- c(98,90,70,92,87, NA)\nstudent &lt;- c(1,2,1,1,2,2)\ntapply(marks, student, mean, na.rm =TRUE) # The na.rm =TRUE is for the mean and not tapply\n\n       1        2 \n86.66667 88.50000"
  },
  {
    "objectID": "vector.html#exercise-5",
    "href": "vector.html#exercise-5",
    "title": "Vectors",
    "section": "Exercise 5",
    "text": "Exercise 5\n\nSequence generation: Write R code to generate the following sequences:\n\n\n1,1,2,1,2,3,1,2,3,4,1,2,3,4,5\n1,2,3,1,2,3,1,2,3,1,2\n1,1,1,2,2,2,3,3,3,1,1\n\n\nSet Operations: Given that the first vector A contains the values 3,3,4,4,4,10,-2 while the second vector B contains the values 4,3,6,-1 obtain the following in R: example\n\na. The unique values of A and of B\nb. The frequency of `A` ie a table showing the number of times each unique element occurs. eg 3 occurs 2 times\nc. Which values in A are in B? What about values in B that are in A?\nd. Obtain the position of the elements in A in the vector B ie the first element in A is in position 2 in B\ne. What is the intersection, union, set difference of the unique values of A and B?\nf. Obtain the position of the duplicated values in A\ng. Find the cumulative sum, product, cumulative minimum and maximum of A\n\n\n\n\nGiven the data 4,7,2,8,1,1,2 compute the standard deviation. \\(sd = \\sqrt{\\frac{1}{n-1}\\sum_{i=1}^n(x_i - \\bar x)^2}\\) where \\(\\bar x = \\frac{1}{n}\\sum_{i=1}^nx_i\\)\nTriangle numbers: Obtain the first 5 triangle numbers.\nNearest neighbor: Given a vector x, for every element in x find the closest value in THAT SAME vector excluding the element in question. Let x be the vector below:\n1 5 6 2 3 0 5 2 1 9\nThe results should be\n1 5 5 2 2 1 5 2 1 6\nIe: The first number 1, is closest to 1 which is 2nd last. The last number 9 is closest to 6.\nWrite a function named nearest_neighbor that would solve the above for any vector x.\nDense Ranking: Suppose 8 students did an exam and the results were as follows: 98, 98, 96, 93, 85, 80, 85, 91. Rank the students to obtain the following results.\nie Notice that normal ranking would give us the results:\n1 1 3 4 6 8 6 5\nAnd the dense rank would give us:\n1 1 2 3 5 6 5 4\nUse R to obtain the results above.\nWrite an R function that would perform the dense rank on any given vector.\nName the function dense_rank and will take two parameters. A numeric vector x and a logical parameter decreasing .\nValue redistribution: Suppose we have a vector with many zeros.\nv &lt;- c(3,0,0,5,0,0,0,10,0,0,0,0)\nWe want to distribute the nonzero numbers forward and replace everything before a nonzero number with the average. For example (3,0,0) should be replaced by (1,1,1).\n(3+0+0)/3=1\nv should become\n(1,1,1,1.25,1.25,1.25,1.25,2,2,2,2,2)\nHow can we solve this using R?\nsearchsorted Given two vectors, a and v, Find indices where elements should be inserted to maintain order. ie Find the indices into a sorted array a such that, if the corresponding elements in v were inserted before the indices, the order of a would be preserved.\n\na &lt;- 1:5\nv &lt;- c(-10,10,2,3)\n\nThe result should be:\n1, 6, 2, 3 or 0, 5, 1, 2\nWrite a function named search_sorted that would accomplish the task above given any two arrays. Let the first array be the sorted array a and the second array be v . Refer to week 1 notes on how to write a basic function\n(Continuation form 7) Using the idea above, assume the vector is not sorted. You need to determine the index of the first element in vector a that is greater than the element in question in vector v:\nWrite a function named search_unsorted to accomplish this. Test it on the two vectors below\nExample: suppose we have the data below:\n\nx &lt;- c(1, -3, 5, 10, 13, 4, 8, 20, 24) \ny &lt;- c(2, 17, 23, -10, 12) \n\nWe see that the results should be 3, 8, 9, 1, 5 or 2, 7, 8, 0, 4\nHow? first \\(2\\le5\\) , so the index of 5 is 3. then \\(17\\le20\\) so the index of 20 is 8. etc\nWrite a code to obtain the results above\nRun Length Encoding: Given a vector \\(x\\) obtain its RLE. RLE is defined as a form of lossless data compression in which runs of data (sequences in which the same data value occurs in many consecutive data elements) are stored as a single data value and count, rather than as the original run.(Wikipedia)\nExample:\nSuppose we have: 1, 1, 1, 3, 3, 3, 3, 1, 1, 1, 1, 1, 2, 2, 3, 2, 2, 2\nWe see that we have 3 1’s, followed by 4 3’s followed by 5 1’s then 2 2’s, 1 3 and finally 3 2’s.\nwrite a function named my_rle that would solve the task at hand. Note that you should output the vector of values, with a lengths attribute that contains the lengths.\nCompare your output to the output of the function call below:\n\nx &lt;- c(1,1,1,3,3,3,3,1,1,1,1,1,2,2,3,2,2)\nrle(x)\n\nRun Length Encoding\n  lengths: int [1:6] 3 4 5 2 1 2\n  values : num [1:6] 1 3 1 2 3 2\n\n\n(Continuation from 9): Write a function named rle_id that would Create a grouping vector for each run length of a vector \\(x\\) . ie when you run your function on the vector x above ie rle_id(x) Your results should be: 1,1,1,2,2,2,2,3,3,3,3,3,4,4,5,6,6\nAlso write a function named row_id that would create a element id within each rle group: and when called on x above ie row_id(x) should result in: 1,2,3,1,2,3,4,1,2,3,4,5,1,2,1,1,2"
  }
]